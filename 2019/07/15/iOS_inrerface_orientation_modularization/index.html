<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
    
  
  <link href="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







  

<link href="https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS," />





  <link rel="alternate" href="/atom.xml" title="🐼黑超熊猫zuik's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="关于组件化的探讨已经有不少了，在之前的文章”iOS VIPER架构实践(三)：面向接口的路由设计”中，综合比较了各种方案后，我倾向于使用面向接口的方式进行组件化。
这是一篇从代码层面讲解模块解耦的文章，会全方位地展示如何实践面向接口的思想，尽量全面地探讨在模块管理和解耦的过程中，需要考虑到的各种问题，并且给出实际的解决方案，以及对应的模块管理开源工具：ZIKRouter。你也可以根据本文的内容改造">
<meta property="og:type" content="article">
<meta property="og:title" content="打造完备的iOS组件化方案：如何面向接口进行模块解耦">
<meta property="og:url" content="http://zuikyo.github.io/2019/07/15/iOS_inrerface_orientation_modularization/index.html">
<meta property="og:site_name" content="🐼黑超熊猫zuik's blog">
<meta property="og:description" content="关于组件化的探讨已经有不少了，在之前的文章”iOS VIPER架构实践(三)：面向接口的路由设计”中，综合比较了各种方案后，我倾向于使用面向接口的方式进行组件化。
这是一篇从代码层面讲解模块解耦的文章，会全方位地展示如何实践面向接口的思想，尽量全面地探讨在模块管理和解耦的过程中，需要考虑到的各种问题，并且给出实际的解决方案，以及对应的模块管理开源工具：ZIKRouter。你也可以根据本文的内容改造">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/a56805369b065650db2f10ccefbadd94.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/53462b3a71a530f39b8042142750cdf3.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/6d9bfdfaf3ff341569b51c92ae70ef9e.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/047d9020dc7caf1f81be8a6c60008bc2.png">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5879294-6309bffe07ebf178.png?imageMogr2/auto-orient/strip%7CimageView2/2">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/aaaab3ad9c1df51b288da15f93af0786.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/69b2e2874f7232fb64195380b1eb3e43.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/99ae2c260a4ed9834d6710d30d987316.png">
<meta property="og:updated_time" content="2019-07-17T14:23:54.290Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="打造完备的iOS组件化方案：如何面向接口进行模块解耦">
<meta name="twitter:description" content="关于组件化的探讨已经有不少了，在之前的文章”iOS VIPER架构实践(三)：面向接口的路由设计”中，综合比较了各种方案后，我倾向于使用面向接口的方式进行组件化。
这是一篇从代码层面讲解模块解耦的文章，会全方位地展示如何实践面向接口的思想，尽量全面地探讨在模块管理和解耦的过程中，需要考虑到的各种问题，并且给出实际的解决方案，以及对应的模块管理开源工具：ZIKRouter。你也可以根据本文的内容改造">
<meta name="twitter:image" content="https://images.xiaozhuanlan.com/photo/2019/a56805369b065650db2f10ccefbadd94.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://zuikyo.github.io/2019/07/15/iOS_inrerface_orientation_modularization/"/>

  <title> 打造完备的iOS组件化方案：如何面向接口进行模块解耦 | 🐼黑超熊猫zuik's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">🐼黑超熊猫zuik's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">iOS 开发修行之路</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                打造完备的iOS组件化方案：如何面向接口进行模块解耦
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-07-15T01:33:00+08:00" content="2019-07-15">
              2019-07-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/代码架构/" itemprop="url" rel="index">
                    <span itemprop="name">代码架构</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/代码架构/组件化/" itemprop="url" rel="index">
                    <span itemprop="name">组件化</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/代码架构/组件化/解耦/" itemprop="url" rel="index">
                    <span itemprop="name">解耦</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>关于组件化的探讨已经有不少了，在之前的文章”iOS VIPER架构实践(三)：面向接口的路由设计”中，综合比较了各种方案后，我倾向于使用面向接口的方式进行组件化。</p>
<p>这是一篇从代码层面讲解模块解耦的文章，会全方位地展示如何实践面向接口的思想，尽量全面地探讨在模块管理和解耦的过程中，需要考虑到的各种问题，并且给出实际的解决方案，以及对应的模块管理开源工具：<a href="https://github.com/Zuikyo/ZIKRouter" target="_blank" rel="external">ZIKRouter</a>。你也可以根据本文的内容改造自己现有的方案。</p>
<p>文章主要内容：</p>
<ul>
<li>如何衡量模块解耦的程度</li>
<li>对比不同方案的优劣</li>
<li>在编译时进行静态路由检查，避免使用不存在的模块</li>
<li>如何进行模块解耦，包括模块重用、模块适配、模块间通信、子模块交互</li>
<li>模块的接口和依赖管理</li>
<li>管理界面跳转逻辑</li>
</ul>
<h2 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h2><p>将模块单独抽离、分层，并制定模块间通信的方式，从而实现解耦，以及适应团队开发。</p>
<h2 id="为什么需要组件化"><a href="#为什么需要组件化" class="headerlink" title="为什么需要组件化"></a>为什么需要组件化</h2><p>主要有4个原因：</p>
<ul>
<li>模块间解耦</li>
<li>模块重用</li>
<li>提高团队协作开发效率</li>
<li>单元测试</li>
</ul>
<p>当项目越来越大的时候，各个模块之间如果是直接互相引用，就会产生许多耦合，导致接口滥用，当某天需要进行修改时，就会牵一发而动全身，难以维护。</p>
<p>问题主要体现在：</p>
<ul>
<li>修改某个模块的功能时，需要修改许多其他模块的代码，因为这个模块被其他模块引用</li>
<li>模块对外的接口不明确，外部甚至会调用不应暴露的私有接口，修改时会耗费大量时间</li>
<li>修改的模块涉及范围较广，很容易影响其他团队成员的开发，产生代码冲突</li>
<li>当需要抽离模块到其他地方重用时，会发现耦合导致根本无法单独抽离</li>
<li>模块间的耦合导致接口和依赖混乱，难以编写单元测试</li>
</ul>
<p>所以需要减少模块之间的耦合，用更规范的方式进行模块间交互。这就是组件化，也可以叫做模块化。</p>
<h2 id="你的项目是否需要组件化"><a href="#你的项目是否需要组件化" class="headerlink" title="你的项目是否需要组件化"></a>你的项目是否需要组件化</h2><p>组件化也不是必须的，有些情况下并不需要组件化：</p>
<ul>
<li>项目较小，模块间交互简单，耦合少</li>
<li>模块没有被多个外部模块引用，只是一个单独的小模块</li>
<li>模块不需要重用，代码也很少被修改</li>
<li>团队规模很小</li>
<li>不需要编写单元测试</li>
</ul>
<p>组件化也是有一定成本的，你需要花时间设计接口，分离代码，所以并不是所有的模块都需要组件化。</p>
<p>不过，当你发现这几个迹象时，就需要考虑组件化了：</p>
<ul>
<li>模块逻辑复杂，多个模块间频繁互相引用</li>
<li>项目规模逐渐变大，修改代码变得越来越困难</li>
<li>团队人数变多，提交的代码经常和其他成员冲突</li>
<li>项目编译耗时较大</li>
<li>模块的单元测试经常由于其他模块的修改而失败</li>
</ul>
<h2 id="组件化方案的8条指标"><a href="#组件化方案的8条指标" class="headerlink" title="组件化方案的8条指标"></a>组件化方案的8条指标</h2><p>决定了要开始组件化之路后，就需要思考我们的目标了。一个组件化方案需要达到怎样的效果呢？我在这里给出8个理想情况下的指标：</p>
<ol>
<li>模块间没有直接耦合，一个模块内部的修改不会影响到另一个模块</li>
<li>模块可以被单独编译</li>
<li>模块间能够清晰地进行数据传递</li>
<li>模块可以随时被另一个提供了相同功能的模块替换</li>
<li>模块的对外接口容易查找和维护</li>
<li>当模块的接口改变时，使用此模块的外部代码能够被高效地重构</li>
<li>尽量用最少的修改和代码，让现有的项目实现模块化</li>
<li>支持 Objective-C 和 Swift，以及混编</li>
</ol>
<p>前4条用于衡量一个模块是否真正解耦，后4条用于衡量在项目实践中的易用程度。最后一条必须支持 Swift，是因为 Swift 是一个必然的趋势，如果你的方案不支持 Swift，说明这个方案在将来的某个时刻必定要改进改变，而到时候所有基于这个方案实现的模块都会受到影响。</p>
<p>基于这8个指标，我们就能在一定程度上对我们的方案做出衡量了。</p>
<h2 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h2><p>现在主要有3种组件化方案：URL 路由、target-action、protocol 匹配。</p>
<p>接下来我们就比较一下这几种组件化方案，看看它们各有什么优缺点。这部分在之前的文章中已经探讨过，这里再重新比较一次，补充一些细节。必须要先说明的是，没有一个完美的方案能满足所有场景下的需求，需要根据每个项目的需求选择最适合的方案。</p>
<h3 id="URL-路由"><a href="#URL-路由" class="headerlink" title="URL 路由"></a>URL 路由</h3><p>目前 iOS 上绝大部分的路由工具都是基于 URL 匹配的，或者是根据命名约定，用 runtime 方法进行动态调用。</p>
<p>这些动态化的方案的优点是实现简单，缺点是需要维护字符串表，或者依赖于命名约定，无法在编译时暴露出所有问题，需要在运行时才能发现错误。</p>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 注册某个URL</div><div class="line">[URLRouter registerURL:@&quot;app://editor&quot; handler:^(NSDictionary *userInfo) &#123;</div><div class="line">    UIViewController *editorViewController = [[EditorViewController alloc] initWithParam:userInfo];</div><div class="line">    return editorViewController;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 调用路由</div><div class="line">[URLRouter openURL:@&quot;app://editor/?debug=true&quot; completion:^(NSDictionary *info) &#123;</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>URL router 的优点：</p>
<ul>
<li>极高的动态性，适合经常开展运营活动的 app，例如电商</li>
<li>方便地统一管理多平台的路由规则</li>
<li>易于适配 URL Scheme</li>
</ul>
<p>URL router 的缺点：</p>
<ul>
<li>传参方式有限，并且无法利用编译器进行参数类型检查，因此所有的参数都只能从字符串中转换而来</li>
<li>只适用于界面模块，不适用于通用模块</li>
<li>不能使用 designated initializer 声明必需参数</li>
<li>要让 view controller 支持 url，需要为其新增初始化方法，因此需要对模块做出修改</li>
<li>不支持 storyboard</li>
<li>无法明确声明模块提供的接口，只能依赖于接口文档，重构时无法确保修改正确</li>
<li>依赖于字符串硬编码，难以管理</li>
<li>无法保证所使用的模块一定存在</li>
<li>解耦能力有限，url 的”注册”、”实现”、”使用”必须用相同的字符规则，一旦任何一方做出修改都会导致其他方的代码失效，并且重构难度大</li>
</ul>
<h4 id="字符串解耦的问题"><a href="#字符串解耦的问题" class="headerlink" title="字符串解耦的问题"></a>字符串解耦的问题</h4><p>如果用上面的8个指标来衡量，URL 路由只能满足”支持模块单独编译”、”支持 OC 和 Swift”两条。它的解耦程度非常一般。</p>
<p>所有基于字符串的解耦方案其实都可以说是伪解耦，它们只是放弃了编译依赖，但是当代码变化之后，即便能够编译运行，逻辑仍然是错误的。</p>
<p>例如修改了模块定义时的 URL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 注册某个URL</div><div class="line">[URLRouter registerURL:@&quot;app://editorView&quot; handler:^(NSDictionary *userInfo) &#123;</div><div class="line">    ...</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>那么调用者的 URL 也必须修改，代码仍然是有耦合的，只不过此时编译器无法检查而已。这会导致维护更加困难，一旦 URL 中的参数有了增减，或者决定替换为另一个模块，参数命名有了变化，几乎没有高效的方式来重构代码。可以使用宏定义来管理字符串，不过这要求所有模块都使用同一个头文件，并且也无法解决参数类型和数量变化的问题。</p>
<p>URL 路由适合用来做远程模块的网络协议交互，而在管理本地模块时，最大的甚至是唯一的优势，就是适合经常跨多端运营活动的 app，因为可以由运营人员统一管理多平台的路由规则。</p>
<h4 id="代表框架"><a href="#代表框架" class="headerlink" title="代表框架"></a>代表框架</h4><ul>
<li><a href="https://github.com/clayallsopp/routable-ios" target="_blank" rel="external">routable-ios</a></li>
<li><a href="https://github.com/joeldev/JLRoutes" target="_blank" rel="external">JLRoutes</a></li>
<li><a href="https://github.com/meili/MGJRouter" target="_blank" rel="external">MGJRouter</a></li>
<li><a href="https://github.com/lightory/HHRouter" target="_blank" rel="external">HHRouter</a></li>
</ul>
<h4 id="改进：避免字符串管理"><a href="#改进：避免字符串管理" class="headerlink" title="改进：避免字符串管理"></a>改进：避免字符串管理</h4><p>改进 URL 路由的方式，就是避免使用字符串，通过接口管理模块。</p>
<p>参数可以通过 protocol 直接传递，能够利用编译器检查参数类型，并且在 ZIKRouter 中，能通过路由声明和编译检查，保证所使用的模块一定存在。在为模块创建路由时，也无需修改模块的代码。</p>
<p>但是必须要承认的是，尽管 URL 路由缺点多多，但它在跨平台路由管理上的确是最适合的方案。因此 ZIKRouter 也对 URL 路由做出了支持，在用 protocol 管理的同时，可以通过字符串匹配 router，也能和其他 URL router 框架对接。</p>
<h3 id="Target-Action-方案"><a href="#Target-Action-方案" class="headerlink" title="Target-Action 方案"></a>Target-Action 方案</h3><p>有一些模块管理工具基于 Objective-C 的 runtime、category 特性动态获取模块。例如通过<code>NSClassFromString</code>获取类并创建实例，通过<code>performSelector:</code> <code>NSInvocation</code>动态调用方法。</p>
<p>例如基于 target-action 模式的设计，大致是利用 category 为路由工具添加新接口，在接口中通过字符串获取对应的类，再用 runtime 创建实例，动态调用实例的方法。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 模块管理者，提供了动态调用 target-action 的基本功能</div><div class="line">@interface Mediator : NSObject</div><div class="line"></div><div class="line">+ (instancetype)sharedInstance;</div><div class="line"></div><div class="line">- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 在 category 中定义新接口</div><div class="line">@interface Mediator (ModuleActions)</div><div class="line">- (UIViewController *)Mediator_editorViewController;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Mediator (ModuleActions)</div><div class="line"></div><div class="line">- (UIViewController *)Mediator_editorViewController &#123;</div><div class="line">    // 使用字符串硬编码，通过 runtime 动态创建 Target_Editor，并调用 Action_viewController:</div><div class="line">    UIViewController *viewController = [self performTarget:@&quot;Editor&quot; action:@&quot;viewController&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;];</div><div class="line">    return viewController;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line">  </div><div class="line">// 调用者通过 Mediator 的接口调用模块</div><div class="line">UIViewController *editor = [[Mediator sharedInstance] Mediator_editorViewController];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 模块提供者提供 target-action 的调用方式</div><div class="line">@interface Target_Editor : NSObject</div><div class="line">- (UIViewController *)Action_viewController:(NSDictionary *)params;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Target_Editor</div><div class="line"></div><div class="line">- (UIViewController *)Action_viewController:(NSDictionary *)params &#123;</div><div class="line">    // 参数通过字典传递，无法保证类型安全</div><div class="line">    EditorViewController *viewController = [[EditorViewController alloc] init];</div><div class="line">    viewController.valueLabel.text = params[@&quot;key&quot;];</div><div class="line">    return viewController;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>利用 category 可以明确声明接口，进行编译检查</li>
<li>实现方式轻量</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要在 mediator 和 target 中重新添加每一个接口，模块化时代码较为繁琐</li>
<li>在 category 中仍然引入了字符串硬编码，内部使用字典传参，一定程度上也存在和 URL 路由相同的问题</li>
<li>无法保证所使用的模块一定存在，target 模块在修改后，使用者只有在运行时才能发现错误</li>
<li>过于依赖 runtime 特性，无法应用到纯 Swift 上。在 Swift 中扩展 mediator 时，无法使用纯 Swift 类型的参数</li>
<li>可能会创建过多的 target 类</li>
<li>使用 runtime 相关的接口调用任意类的任意方法，需要注意别被苹果的审核误伤。参考：<a href="https://stackoverflow.com/questions/42662028/are-performselector-and-respondstoselector-banned-by-app-store" target="_blank" rel="external">Are performSelector and respondsToSelector banned by App Store?</a></li>
</ul>
<h4 id="字典传参的问题"><a href="#字典传参的问题" class="headerlink" title="字典传参的问题"></a>字典传参的问题</h4><p>字典传参时无法保证参数的数量和类型，只能依赖调用约定，就和字符串传参一样，一旦某一方做出修改，另一方也必须修改。</p>
<p>相比于 URL 路由，target-action 通过 category 的接口把字符串管理的问题缩小到了 mediator 内部，不过并没有完全消除，而且在其他方面仍然有很多改进空间。上面的8个指标中其实只能满足第2个”支持模块单独编译”，另外在和接口相关的第3、5、6点上，比 URL 路由要有改善。</p>
<h4 id="代表框架-1"><a href="#代表框架-1" class="headerlink" title="代表框架"></a>代表框架</h4><p><a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">CTMediator</a></p>
<h4 id="改进：避免字典传参"><a href="#改进：避免字典传参" class="headerlink" title="改进：避免字典传参"></a>改进：避免字典传参</h4><p>Target-Action 方案最大的优点就是整个方案实现轻量，并且也一定程度上明确了模块的接口。只是这些接口都需要通过 Target-Action 封装一次，并且每个模块都要创建一个 target 类，既然如此，直接用 protocol 进行接口管理会更加简单。</p>
<p>ZIKRouter 避免使用 runtime 获取和调用模块，因此可以适配 OC 和 swift。同时，基于 protocol 匹配的方式，避免引入字符串硬编码，能够更好地管理模块，也避免了字典传参。</p>
<h3 id="基于-protocol-匹配的方案"><a href="#基于-protocol-匹配的方案" class="headerlink" title="基于 protocol 匹配的方案"></a>基于 protocol 匹配的方案</h3><p>有一些模块管理工具或者依赖注入工具，也实现了基于接口的管理方式。实现思路是将 protocol 和对应的类进行字典匹配，之后就可以用 protocol 获取 class，再动态创建实例。</p>
<p>BeeHive 示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 注册模块 (protocol-class 匹配)</div><div class="line">[[BeeHive shareInstance] registerService:@protocol(EditorViewProtocol) service:[EditorViewController class]];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 获取模块 (用 runtime 创建 EditorViewController 实例)</div><div class="line">id&lt;EditorViewProtocol&gt; editor = [[BeeHive shareInstance] createService:@protocol(EditorViewProtocol)];</div></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>利用接口调用，实现了参数传递时的类型安全</li>
<li>直接使用模块的 protocol 接口，无需再重复封装</li>
</ul>
<p>缺点：</p>
<ul>
<li>由框架来创建所有对象，创建方式有限，例如不支持外部传入参数，再调用自定义初始化方法</li>
<li>用 OC runtime 创建对象，不支持 Swift</li>
<li>只做了 protocol 和 class 的匹配，不支持更复杂的创建方式和依赖注入</li>
<li>无法保证所使用的 protocol 一定存在对应的模块，也无法直接判断某个 protocol 是否能用于获取模块</li>
</ul>
<p>相比直接 protocol-class 匹配的方式，protocol-block 的方式更加易用。例如 Swinject。</p>
<p>Swinject 示例代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> container = <span class="type">Container</span>()</div><div class="line"></div><div class="line"><span class="comment">// 注册模块</span></div><div class="line">container.register(<span class="type">EditorViewProtocol</span>.<span class="keyword">self</span>) &#123; <span class="number">_</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> <span class="type">EditorViewController</span>()</div><div class="line">&#125;</div><div class="line"><span class="comment">// 获取模块</span></div><div class="line"><span class="keyword">let</span> editor = container.resolve(<span class="type">EditorViewProtocol</span>.<span class="keyword">self</span>)!</div></pre></td></tr></table></figure>
<h4 id="代表框架-2"><a href="#代表框架-2" class="headerlink" title="代表框架"></a>代表框架</h4><p><a href="https://github.com/alibaba/BeeHive" target="_blank" rel="external">BeeHive</a></p>
<p><a href="https://github.com/Swinject/Swinject" target="_blank" rel="external">Swinject</a></p>
<h4 id="改进：离散式管理"><a href="#改进：离散式管理" class="headerlink" title="改进：离散式管理"></a>改进：离散式管理</h4><p>BeeHive 这种方式和 ZIKRouter 的思路类似，但是所有的模块在注册后，都是由 BeeHive 单例来创建，使用场景十分有限，例如不支持纯 Swift 类型，不支持使用自定义初始化方法以及额外的依赖注入。 </p>
<p>ZIKRouter 进行了进一步的改进，并不是直接对 protocol 和 class 进行匹配，而是将 protocol 和 router 子类或者 router 对象进行匹配，在 router 子类中再提供创建模块的实例的方式。这时，模块的创建职责就从 BeeHive 单例上转到了每个单独的 router 上，从集约型变成了离散型，扩展性进一步提升。</p>
<h2 id="Protocol-Router-匹配方案"><a href="#Protocol-Router-匹配方案" class="headerlink" title="Protocol-Router 匹配方案"></a>Protocol-Router 匹配方案</h2><p>变成 protocol-router 匹配后，代码将会变成这样：</p>
<p>一个 router 父类提供基础的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZIKViewRouter</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 获取模块</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">makeDestination</span> -&gt; <span class="title">Any</span>? </span>&#123;</div><div class="line">        <span class="keyword">let</span> router = <span class="keyword">self</span>.<span class="keyword">init</span>(with: <span class="type">ViewRouteConfig</span>())</div><div class="line">        <span class="keyword">return</span> router.destination(with: router.configuration) </div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 让子类重写</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">Any</span>? &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZIKViewRouter</span>: <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZIKViewRouter</span></span></div><div class="line">  </div><div class="line">...</div><div class="line"><span class="comment">// 获取模块</span></div><div class="line">+ (<span class="keyword">id</span>)makeDestination &#123;</div><div class="line">    ZIKViewRouter *router = [<span class="keyword">self</span> alloc] initWithConfiguration:[ZIKViewRouteConfiguration new]];</div><div class="line">    <span class="keyword">return</span> [router destinationWithConfiguration:router.configuration];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 让子类重写</span></div><div class="line">- (<span class="keyword">id</span>)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>每个模块各自编写自己的 router 子类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span> </span>&#123;</div><div class="line">    <span class="comment">// 子类重写，创建模块</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">Any</span>? &#123;</div><div class="line">        <span class="keyword">let</span> destination = <span class="type">EditorViewController</span>()</div><div class="line">        <span class="keyword">return</span> destination</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewRouter</span> : <span class="title">ZIKViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewRouter</span></span></div><div class="line"></div><div class="line"><span class="comment">// 子类重写，创建模块</span></div><div class="line">- (EditorViewController *)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    EditorViewController *destination = [[EditorViewController alloc] init];</div><div class="line">    <span class="keyword">return</span> destination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>把 protocol 和 router 类进行注册绑定：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">EditorViewRouter</span>.register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;())</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册 protocol 和 router</span></div><div class="line">[EditorViewRouter registerViewProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">EditorViewProtocol</span>)];</span></div></pre></td></tr></table></figure><br><br></details>

<p>然后就可以用 protocol 获取 router 类，再进一步获取模块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取模块的 router 类</span></div><div class="line"><span class="keyword">let</span> routerClass = <span class="type">Router</span>.to(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;())</div><div class="line"><span class="comment">// 获取 EditorViewProtocol 模块</span></div><div class="line"><span class="keyword">let</span> destination = routerClass?.makeDestination()</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取模块的 router 类</span></div><div class="line">Class routerClass = ZIKViewRouter.toView(<span class="class"><span class="keyword">@protocol</span>(<span class="title">EditorViewProtocol</span>));</span></div><div class="line"><span class="comment">// 获取 EditorViewProtocol 模块</span></div><div class="line"><span class="keyword">id</span>&lt;EditorViewProtocol&gt; destination = [routerClass makeDestination];</div></pre></td></tr></table></figure><br><br></details>

<p>加了一层 router 中间层之后，解耦能力一下子就增强了：</p>
<ul>
<li>可以在 router 上添加许多通用的扩展接口，例如创建模块、依赖注入、界面跳转、界面移除，甚至增加 URL 路由支持</li>
<li>在每个 router 子类中可以进行更详细的依赖注入和自定义操作</li>
<li>可以自定义创建对象的方式，例如自定义初始化方法、工厂方法，在重构时可以直接搬运现有的创建代码，无需在原来的类上增加或修改接口，减少模块化过程中的工作量</li>
<li>可以让多个 protocol 和同一个模块进行匹配</li>
<li>可以让模块进行接口适配，允许外部做完适配后，为 router 添加新的 protocol，解决编译依赖的问题</li>
<li>返回的对象只需符合 protocol，不再和某个单一的类绑定。因此可以根据条件，返回不同的对象，例如适配不同系统版本时，返回不同的控件，让外部只关注接口</li>
</ul>
<h2 id="动态化的风险"><a href="#动态化的风险" class="headerlink" title="动态化的风险"></a>动态化的风险</h2><p>大部分组件化方案都会带来一个问题，就是减弱甚至抛弃编译检查，因为模块已经变得高度动态化了。</p>
<p>当调用一个模块时，怎么能保证这个模块一定存在？直接引用类时，如果类不存在，编译器会给出引用错误，但是动态组件就无法在静态时检查了。</p>
<p>例如 URL 地址变化了，但是代码中的某些 URL 没有及时更新；使用 protocol 获取模块时，protocol 并没有注册对应的模块。这些问题都只能在运行时才能发现。</p>
<p> 那么有没有一种方式，可以让模块既高度解耦，又能在编译时保证调用的模块一定存在呢？</p>
<p>答案是 YES。</p>
<h2 id="静态路由检查"><a href="#静态路由检查" class="headerlink" title="静态路由检查"></a>静态路由检查</h2><p>ZIKRouter 最特别的功能，就是能够保证所使用的 protocol 一定存在，在编译阶段就能防止使用不存在的模块。这个功能可以让你更安全、更简单地管理所使用的路由接口，不必再用其他复杂的方式进行检查和维护。</p>
<p>当使用了错误的 protocol 时，会产生编译错误。</p>
<p>Swift 中使用未声明的 protocol：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/a56805369b065650db2f10ccefbadd94.png" alt="Swift路由检查"></p>
<p>Objective-C 中使用未声明的 protocol：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/53462b3a71a530f39b8042142750cdf3.png" alt="OC路由检查"></p>
<p>这个特性通过两个机制来实现：</p>
<ul>
<li>只有被声明为可路由的 protocol 才能用于路由，否则会产生编译错误</li>
<li>可路由的 protocol 必定有一个对应的模块存在</li>
</ul>
<p>下面就一步步讲解，怎么在保持动态解耦特性的同时，实现一套完备的静态类型检查的机制。</p>
<h3 id="路由声明"><a href="#路由声明" class="headerlink" title="路由声明"></a>路由声明</h3><p>怎么才能声明一个 protocol 是可以用于路由的呢？</p>
<p>要实现第一个机制，关键就是要为 protocol 添加特殊的属性或者类型，使用时，如果 protocol 不符合特定类型，就产生编译错误。</p>
<p>原生 Xcode 并不支持这样的静态检查，这时候就要考验我们的创造力了。</p>
<h4 id="Objective-C：protocol-继承链"><a href="#Objective-C：protocol-继承链" class="headerlink" title="Objective-C：protocol 继承链"></a>Objective-C：protocol 继承链</h4><p>在 Objective-C 中，可以要求 protocol 必须继承自某个特定的父 protocol，并且通过宏定义 + protocol 限定，对 protocol 的父 protocol 继承链进行静态检查。</p>
<p>例如 ZIKRouter 中获取 router 类的方法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@protocol ZIKViewRoutable</div><div class="line">@end</div><div class="line"></div><div class="line">@interface ZIKViewRouter()</div><div class="line">@property (nonatomic, class, readonly) ZIKViewRouterType *(^toView)(Protocol&lt;ZIKViewRoutable&gt; *viewProtocol);</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>toView</code>用类属性的方式提供，以方便链式调用，这个 block 接收一个<code>Protocol&lt;ZIKViewRoutable&gt; *</code>类型的 protocol，返回对应的 router 类。</p>
<p><code>Protocol&lt;ZIKViewRoutable&gt; *</code>表示这个 protocol 必须继承自<code>ZIKViewRoutable</code>。普通 protocol 的类型是<code>Protocol *</code>，所以如果传入<code>@protocol(EditorViewProtocol)</code>就会产生编译警告。</p>
<p>而如果用宏定义再给 protocol 变量加上一个 protocol 限定，进行一次类型转换，就可以利用编译器检查 protocol 的继承链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 声明时继承自 ZIKViewRoutable</div><div class="line">@protocol EditorViewProtocol &lt;ZIKViewRoutable&gt;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 宏定义，为 protocol 变量添加 protocol 限定</div><div class="line">#define ZIKRoutable(RoutableProtocol) (Protocol&lt;RoutableProtocol&gt;*)@protocol(RoutableProtocol)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 用 protocol 获取 router</div><div class="line">ZIKViewRouter.toView(ZIKRoutable(EditorViewProtocol))</div></pre></td></tr></table></figure>
<p><code>ZIKRoutable(EditorViewProtocol)</code>展开后是<code>(Protocol&lt;EditorViewProtocol&gt; *)@protocol(EditorViewProtocol)</code>，类型为<code>Protocol&lt;EditorViewProtocol&gt; *</code>。在 Objective-C 中<code>Protocol&lt;EditorViewProtocol&gt; *</code>是<code>Protocol&lt;ZIKViewRoutable&gt; *</code>的子类型，编译器将不会有警告。</p>
<p>但是当传入的 protocol 没有继承自<code>ZIKViewRoutable</code>时，例如<code>ZIKRoutable(UndeclaredProtocol)</code>的类型是<code>Protocol&lt;UndeclaredProtocol&gt; *</code>，编译器在检查 protocol 的继承链时，由于<code>UndeclaredProtocol</code>没有继承自<code>ZIKViewRoutable</code>，因此<code>Protocol&lt;UndeclaredProtocol&gt; *</code>不是<code>Protocol&lt;ZIKViewRoutable&gt; *</code>的子类型，编译器会给出类型错误的警告。在<code>Build Settings</code>中可以把<code>incompatible pointer types</code>警告变成编译错误。</p>
<p>最后，把<code>ZIKViewRouter.toView(ZIKRoutable(EditorViewProtocol))</code>用宏定义简化一下，变成<code>ZIKViewRouterToView(EditorViewProtocol)</code>，就能在获取 router 的时候方便地静态检查 protocol 的类型了。</p>
<h4 id="Swift：条件扩展"><a href="#Swift：条件扩展" class="headerlink" title="Swift：条件扩展"></a>Swift：条件扩展</h4><p>Swift 中不支持宏定义，也不能随意进行类型转换，因此需要换一种方式来进行编译检查。</p>
<p>可以用 struct 的泛型传递 protocol，然后用条件扩展为特定泛型的 struct 添加初始化方法，从而让没有声明过的泛型类型不能直接创建 struct。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用 RoutableView 的泛型来传递 protocol</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RoutableView</span>&lt;<span class="title">Protocol</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 禁止默认的初始化方法</span></div><div class="line">    <span class="meta">@available</span>(*, unavailable, message: <span class="string">"Protocol is not declared as routable"</span>)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 泛型为 EditorViewProtocol 的扩展</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RoutableView</span> <span class="title">where</span> <span class="title">Protocol</span> == <span class="title">EditorViewProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// 允许初始化</span></div><div class="line">    <span class="keyword">init</span>() &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 泛型为 EditorViewProtocol 时可以初始化</span></div><div class="line"><span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;()</div><div class="line"></div><div class="line"><span class="comment">// 没有声明过的泛型无法初始化，会产生编译错误</span></div><div class="line"><span class="type">RoutableView</span>&lt;<span class="type">UndeclaredProtocol</span>&gt;()</div></pre></td></tr></table></figure>
<p>此时 Xcode 还可以给出自动补全，列出所有声明过的 protocol：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/6d9bfdfaf3ff341569b51c92ae70ef9e.png" alt="自动补全"></p>
<h3 id="路由检查"><a href="#路由检查" class="headerlink" title="路由检查"></a>路由检查</h3><p>通过路由声明，我们做到了在编译时对所使用的 protocol 做出限制。下一步就是保证声明过的 protocol 必定有对应的模块，类似于程序在 link 阶段，会检查头文件中声明过的类必定有对应的实现。</p>
<p>这一步是无法直接在编译阶段实现的，不过可以参考 iOS 在启动时检查动态库的方式，我们可以在启动阶段实现这个功能。</p>
<h4 id="Objective-C-protocol-遍历"><a href="#Objective-C-protocol-遍历" class="headerlink" title="Objective-C: protocol 遍历"></a>Objective-C: protocol 遍历</h4><p>在 app 以 DEBUG 模式启动时，我们可以遍历所有继承自 ZIKViewRoutable 的 protocol，在注册表中检查是否有对应的 router，如果没有，就给出断言错误。</p>
<p>另外，还可以让 router 同时注册创建模块时用到类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">EditorViewRouter</span>.registerView(<span class="type">EditorViewController</span>.<span class="keyword">self</span>)</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册 protocol 和 router</span></div><div class="line">[EditorViewRouter registerView:[EditorViewController <span class="keyword">class</span>]];</div></pre></td></tr></table></figure><br><br></details>

<p>从而进一步检查 router 中的 class 是否遵守对应的 protocol。这时整个类型检查过程就完整了。</p>
<h4 id="Swift-符号遍历"><a href="#Swift-符号遍历" class="headerlink" title="Swift: 符号遍历"></a>Swift: 符号遍历</h4><p>但是 Swift 中的 protocol 是静态类型，并不能通过 OC runtime 直接遍历。是不是就无法动态检查了呢？其实只要发挥创造力，一样能做到。</p>
<p>Swift 的泛型名会在符号名中体现出来。例如上面声明的 init 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MyApp 中，泛型为 EditorViewProtocol 的扩展</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RoutableView</span> <span class="title">where</span> <span class="title">Protocol</span> == <span class="title">EditorViewProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// 允许初始化</span></div><div class="line">    <span class="keyword">init</span>() &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在还原符号后就是<code>(extension in MyApp):ZRouter.RoutableView&lt;A where A == MyApp.EditorViewProtocol&gt;.init() -&gt; ZRouter.RoutableView&lt;MyApp.EditorViewProtocol&gt;</code>。</p>
<p>此时我们可以遍历 app 的符号表，来查找 RoutableView 的所有扩展，从而提取出所有声明过的 protocol 类型，再去检查是否有对应的 router。</p>
<h5 id="Swift-Runtime-和-ABI"><a href="#Swift-Runtime-和-ABI" class="headerlink" title="Swift Runtime 和 ABI"></a>Swift Runtime 和 ABI</h5><p>但是如果要进一步检查 router 中的 class 是否遵守 router 中的 protocol，就会遇到问题了。在 Swift 中怎么检查某个任意的 class 遵守某个 Swift protocol ？</p>
<p>Swift 中没有直接提供<code>class_conformsToProtocol</code>这样的函数，不过我们可以通过 Swift Runtime 提供的标准函数和 Swift ABI 中定义的内存结构，完成同样的功能。</p>
<p>这部分的实现可以参考代码：<a href="https://github.com/Zuikyo/ZIKRouter/blob/acb923bcdd09c65672977b5a20f7c527e459ead5/ZIKRouter/Utilities/ZIKRouterRuntimeDebug.h#L41" target="_blank" rel="external">_swift_typeIsTargetType</a>。之后我会写几篇文章详细讲解 Swift ABI 的底层内容。</p>
<p>路由检查这部分只在 DEBUG 模式下进行，因此可以放开折腾。</p>
<h3 id="自动推断返回值类型"><a href="#自动推断返回值类型" class="headerlink" title="自动推断返回值类型"></a>自动推断返回值类型</h3><p>还有最后一个问题，在 BeeHive 中使用<code>[[BeeHive shareInstance] createService:@protocol(EditorViewProtocol)]</code>获取模块时，返回值是一个<code>id</code>类型，使用者需要手动指定返回变量的类型，在 Swift 中更是需要手动类型转换，而这一步是可能出错的，并且编译器无法检查。要实现最完备的类型检查，就不能忽视这个问题。</p>
<p>有没有一种方式能让返回值的类型和 protocol 的类型对应呢？OC 中的泛型在这时候就发挥作用了。</p>
<p>可以在 router 上声明模块的泛型：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZIKViewRouter</span>&lt;<span class="title">__covariant</span> <span class="title">Destination</span>, <span class="title">__covariant</span> <span class="title">RouteConfig</span>: <span class="title">ZIKViewRouteConfiguration</span> *&gt; : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这里使用了两个泛型参数 <code>Destination</code> 和 <code>RouteConfig</code>，分别表示此 router 所管理的模块类型和路由 config 的类型。<code>__covariant</code>则表示这个泛型支持协变，也就是子类型可以和父类型一样使用。</p>
<p>声明了泛型参数后，我们可以在方法中的参数声明中使用泛型：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZIKViewRouter</span>&lt;<span class="title">__covariant</span> <span class="title">Destination</span>, <span class="title">__covariant</span> <span class="title">RouteConfig</span>: <span class="title">ZIKViewRouteConfiguration</span> *&gt; : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> Destination)makeDestination;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> Destination)destinationWithConfiguration:(RouteConfig)configuration;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>此时在获取 router 时，就可以把 protocol 的类型作为 router 的泛型参数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define ZIKRouterToView(ViewProtocol) [ZIKViewRouter<span class="meta-string">&lt;id&lt;ViewProtocol&gt;</span>,ZIKViewRouteConfiguration *&gt; toView](ZIKRoutable(ViewProtocol))</span></div></pre></td></tr></table></figure>
<p>使用<code>ZIKRouterToView(EditorViewProtocol)</code>获取的 router 类型就是<code>ZIKViewRouter&lt;id&lt;EditorViewProtocol&gt;,ZIKViewRouteConfiguration *&gt;</code>。在这个 router 上调用<code>makeDestination</code>时，返回值的类型就是<code>id&lt;EditorViewProtocol&gt;</code>，从而实现了完整的类型传递。</p>
<p>而在 Swift 中，直接用函数泛型就能实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">to</span>&lt;Protocol&gt;<span class="params">(<span class="number">_</span> routableView: RoutableView&lt;<span class="keyword">Protocol</span>&gt;)</span></span> -&gt; <span class="type">ViewRouter</span>&lt;<span class="type">Protocol</span>, <span class="type">ViewRouteConfig</span>&gt;?</div><div class="line">    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>使用<code>Router.to(RoutableView&lt;EditorViewProtocol&gt;())</code>时，获得的 router 类型就是<code>ViewRouter&lt;EditorViewProtocol, ViewRouteConfig&gt;?</code>，在调用<code>makeDestination</code>时，返回值类型就是<code>EditorViewProtocol</code>，无需手动类型转换。</p>
<p>如果你使用协议组合，还能同时指明多个类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typealias</span> <span class="type">EditorViewProtocol</span> = <span class="type">UIViewController</span> &amp; <span class="type">EditorViewInput</span></div></pre></td></tr></table></figure>
<p>并且在 router 子类中重写对应方法时，也能用泛型进一步确保类型正确：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewProtocol</span>, <span class="title">ZIKViewRouteConfiguration</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ZIKViewRouteConfiguration)</span></span> -&gt; <span class="type">EditorViewProtocol</span>? &#123;</div><div class="line">        <span class="comment">// 函数重写时，参数类型会和泛型一致，实现时能确保返回值的类型是正确的</span></div><div class="line">        <span class="keyword">return</span> <span class="type">EditorViewController</span>()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们完成了一套完备的类型检查机制，而且这套检查同时支持 OC 和 Swift。</p>
<p>至此，一个基于接口的、类型安全的模块管理工具就完成了。使用 <code>makeDestination</code> 创建模块只是最基本的功能，我们可以在父类 router 中进行许多有用的功能扩展，例如依赖注入、界面跳转、接口适配，来更好地进行面向接口的开发。</p>
<h2 id="模块解耦"><a href="#模块解耦" class="headerlink" title="模块解耦"></a>模块解耦</h2><p>那么在面向接口编程时，我们还需要哪些功能呢？在扩展之前，我们先来讨论一下如何使用接口进行模块解耦，首先从理论层面梳理，再把理论转化为工具。</p>
<h3 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h3><p><img src="https://images.xiaozhuanlan.com/photo/2019/047d9020dc7caf1f81be8a6c60008bc2.png" alt=""></p>
<p>不同模块对解耦的要求是不同的。模块从层级上可以从低到高分类：</p>
<ul>
<li>底层功能模块，功能单一，有一定通用性，例如各种功能组件(日志、数据库)。底层模块的主要目的是复用</li>
<li>中间层的通用业务模块，可以在不同项目中通用。会引用各种底层模块，以及和其他业务模块通信</li>
<li>中间层的特殊功能模块，提供了独特的功能，没有通用性，可能会引用一些底层模块，例如性能监控模块。这种模块可以被其他模块直接引用，不用太多考虑模块间解耦的问题</li>
<li>上层的专有业务模块，属于某个项目中独有的业务。会引用各种底层模块，以及和其他业务模块通信，和中间层的差别就是上层的解耦要求没有中间层那么高</li>
</ul>
<h3 id="什么是解耦"><a href="#什么是解耦" class="headerlink" title="什么是解耦"></a>什么是解耦</h3><p>首先明确一下什么才是解耦，梳理这个问题能够帮助我们明确目标。</p>
<p>解耦的目的基本上就是两个：提高代码的可维护性、模块重用。指导思想就是面向对象的设计原则。</p>
<p>解耦也有不同的程度，从低到高，差不多可以分为3层：</p>
<ol>
<li>模块间使用抽象接口交互，没有直接类型耦合，一个模块内部的修改不会影响到另一个模块 (单一职责、依赖倒置)</li>
<li>模块可重用，可以被单独编译 (接口隔离、依赖倒置、控制反转)</li>
<li>模块可以随时被另一个提供了相同功能的模块替换 (开闭原则、依赖倒置、控制反转)</li>
</ol>
<h4 id="第一层：抽象接口，提取依赖关系"><a href="#第一层：抽象接口，提取依赖关系" class="headerlink" title="第一层：抽象接口，提取依赖关系"></a>第一层：抽象接口，提取依赖关系</h4><p>第一层解耦，是为了减少不同代码间的依赖关系，让代码更容易维护。例如把类替换为 protocol，隔绝模块的私有接口，把依赖关系最小化。</p>
<p>解耦的整个过程，就是梳理和管理依赖的过程。因此模块的内聚性越高越好，外部依赖越少越好，这样维护起来才更简单。</p>
<p>如果模块不需要重用，那在这一层基本上就够了。</p>
<h4 id="第二层：模块重用，管理模块间通信"><a href="#第二层：模块重用，管理模块间通信" class="headerlink" title="第二层：模块重用，管理模块间通信"></a>第二层：模块重用，管理模块间通信</h4><p>第二层解耦，是把代码单独抽离，做到了模块重用，可以交给不同的成员维护，对模块间通信提出了更高的要求。模块需要在接口中声明外部依赖，去除对特定类型的耦合。</p>
<p>此时影响最大的地方就是模块间通信的方式，有时候即便是能够单独编译了，也不意味着解耦。例如 URL 路由，只是放弃了编译检查，耦合关系还是存在于 URL 字符串中，一方的 URL 改变，其他方的代码逻辑就会出错，所以逻辑上仍然是耦合的。因此所有基于某种隐式调用约定的方案（例如字符串匹配），都只是解除编译检查，而不是真正的解耦。</p>
<p>有人说使用 protocol 进行模块间通信，会导致模块和 protocol 耦合。这个观点是错误的。 protocol 恰恰是把模块的依赖明确地提取出来，是一种更高效的方法。否则完全用隐式约定来进行通信，没有编译器的辅助，一旦模块的接口名、参数类型、参数数量需要更新，将会非常难以维护。</p>
<p>而且，通过设计模式，是可以解除对特定 protocol 的依赖的，下文将会对此进行讲解。</p>
<h4 id="第三层：去除隐式约定"><a href="#第三层：去除隐式约定" class="headerlink" title="第三层：去除隐式约定"></a>第三层：去除隐式约定</h4><p>第三层解耦，模块间做到了真正的解耦，只要两个模块提供了相同的功能，就可以无缝替换，并且调用方无需任何修改。被替换的模块只需要提供相同功能的接口，通过适配器对接即可，没有其他任何限制，不存在任何其他的隐式调用约定。</p>
<p>一般有这种解耦要求的，都是那些跨项目的通用模块，而项目内专有的业务模块则没有这么高的要求。不过那些跨多端的模块和远程模块无法做到这样的解耦，因为跨多端时没有统一的定义接口的方式，因此只能通过隐式约定或者网络协议定义接口，例如 URL 路由。</p>
<p><strong>总的来说，解耦的过程就是职责分离、依赖管理（依赖声明和注入）、模块通信 这三大部分。</strong></p>
<h3 id="模块重用"><a href="#模块重用" class="headerlink" title="模块重用"></a>模块重用</h3><p>要做到模块重用，模块需要尽量减少外部依赖，并且把依赖提取出来，体现到模块的接口上，让调用者主动注入。同时，把模块的各种事件也提取出来，让调用者进行处理。</p>
<p>这样一来，模块就只需要负责自身的逻辑，不需要关心调用者如何使用模块。那些每个应用各自专有的应用层逻辑也就从模块中分离出来了。</p>
<p><strong>因此，要想做好模块解耦，管理好依赖是非常重要的。而 protocol 接口就是管理依赖的最高效的方式。</strong></p>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>依赖，就是模块中用到的外部数据和外部模块。接下来讨论如何使用 protocol 管理依赖，并且演示如何用 router 实现。</p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>先来复习一下依赖注入的概念。依赖注入和依赖查找是实现控制反转思想的具体方式。</p>
<p>控制反转是将对象依赖的获取从主动变为被动，从对象内部直接引用并获取依赖，变为由外部向对象提供对象所要求的依赖，把不属于自己的职责移交出去，从而让对象和其依赖解耦。此时控制流的主动权从内部转移到了外部，因此称为控制反转。</p>
<p>依赖注入就是指外部向对象传入依赖。</p>
<p>一个类 A 在接口中体现出内部需要用到的一些依赖(例如内部需要用到类B的实例)，从而让使用者从外部注入这些依赖，而不是在类内部直接引用依赖并创建类 B。依赖可以用 protocol 的方式声明，这样就可以使类 A 和所使用的依赖类 B 进行解耦。</p>
<h3 id="分离模块创建和配置"><a href="#分离模块创建和配置" class="headerlink" title="分离模块创建和配置"></a>分离模块创建和配置</h3><p>那么如何用 router 进行依赖注入呢？</p>
<p>模块创建了实例后，经常还需要进行一些配置。模块管理工具应该从设计上提供配置功能。</p>
<p>最简单的方式，就是在<code>destinationWithConfiguration:</code>中创建 destination 时进行配置。但是我们还可以更进一步，把 destination 的创建和配置分离开。分离之后，router 就可以单独提供配置功能，去配置那些不是由 router 创建的 destination，例如 storyboard 中创建的 view、各种接口回调中返回的实例对象。这样就可以覆盖更多现存的使用场景，减少代码修改。</p>
<h4 id="Prepare-Destination"><a href="#Prepare-Destination" class="headerlink" title="Prepare Destination"></a>Prepare Destination</h4><p>可以在 router 子类中的<code>prepareDestination:configuration:</code>中进行模块配置，也就是依赖注入，而模块的调用者无需关心这部分依赖是如何配置的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// router 父类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZIKViewRouter</span>&lt;<span class="title">Destination</span>, <span class="title">RouteConfig</span>&gt;: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">makeDestination</span> -&gt; <span class="title">Destination</span>? </span>&#123;</div><div class="line">        <span class="keyword">let</span> router = <span class="keyword">self</span>.<span class="keyword">init</span>(with: <span class="type">ViewRouteConfig</span>())</div><div class="line">        <span class="keyword">let</span> destination = router.destination(with: router.configuration)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> destination = destination &#123;</div><div class="line">            <span class="comment">// router 父类中调用模块配置方法</span></div><div class="line">            router.prepareDestination(destination, configuration: router.configuration)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> destination</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 模块创建，让子类重写</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">Destination</span>? &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 模块配置，让子类重写</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">prepareDestination</span><span class="params">(<span class="number">_</span> destination: Destination, configuration: RouteConfig)</span></span> &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewController</span>, <span class="title">ViewRouteConfig</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">EditorViewController</span>? &#123;</div><div class="line">        <span class="keyword">let</span> destination = <span class="type">EditorViewController</span>()</div><div class="line">        <span class="keyword">return</span> destination</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 配置模块，注入静态依赖</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareDestination</span><span class="params">(<span class="number">_</span> destination: EditorViewController, configuration: ViewRouteConfig)</span></span> &#123;</div><div class="line">        <span class="comment">// 注入 service 依赖</span></div><div class="line">        destination.storageService = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableService</span>&lt;<span class="type">EditorStorageServiceInput</span>&gt;())</div><div class="line">        <span class="comment">// 其他配置</span></div><div class="line">        destination.title = <span class="string">"默认标题"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// router 父类</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZIKViewRouter</span>&lt;<span class="title">__covariant</span> <span class="title">Destination</span>, <span class="title">__covariant</span> <span class="title">RouteConfig</span>: <span class="title">ZIKViewRouteConfiguration</span> *&gt;: <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZIKViewRouter</span></span></div><div class="line">  </div><div class="line">...</div><div class="line">+ (<span class="keyword">id</span>)makeDestination &#123;</div><div class="line">    ZIKViewRouter *router = [<span class="keyword">self</span> alloc] initWithConfiguration:[ZIKViewRouteConfiguration new]];</div><div class="line">    <span class="keyword">id</span> destination = [router destinationWithConfiguration:router.configuration];</div><div class="line">    <span class="keyword">if</span> (destination) &#123;</div><div class="line">        <span class="comment">// router 父类中调用模块配置方法</span></div><div class="line">        [router prepareDestination:destination configuration:router.configuration];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> destination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 模块创建，让子类重写</span></div><div class="line">- (<span class="keyword">id</span>)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 模块配置，让子类重写</span></div><div class="line">- (<span class="keyword">void</span>)prepareDestination:(<span class="keyword">id</span>)destination configuration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewRouter</span> : <span class="title">ZIKViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewRouter</span></span></div><div class="line"></div><div class="line">- (EditorViewController *)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    EditorViewController *destination = [[EditorViewController alloc] init];</div><div class="line">    <span class="keyword">return</span> destination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 配置模块，注入静态依赖</span></div><div class="line">- (<span class="keyword">void</span>)prepareDestination:(EditorViewController *)destination configuration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="comment">// 注入 service 依赖</span></div><div class="line">    destination.storageService = [ZIKRouterToService(EditorStorageServiceInput) makeDestination];</div><div class="line">    <span class="comment">// 其他配置</span></div><div class="line">    destination.title = <span class="string">@"默认标题"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>此时调用者中如果有某些对象不是创建自 router的，就可以直接用对应的 router 进行配置，执行依赖注入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> destination: <span class="type">EditorViewProtocol</span> = ...</div><div class="line"><span class="type">Router</span>.to(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;())?.prepare(destination: destination, configuring: &#123; (config, <span class="number">_</span>) <span class="keyword">in</span></div><div class="line">    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span>&lt;EditorViewProtocol&gt; destination = ...</div><div class="line">[ZIKRouterToView(EditorViewProtocol) prepareDestination:destination configuring:^(ZIKViewRouteConfiguration *config) &#123;</div><div class="line">    </div><div class="line">&#125;];</div></pre></td></tr></table></figure><br><br></details>

<p>独立的配置功能在某些场景下是非常有用的，尤其是在重构现有代码的时候。有一些系统接口的设计就是在接口中返回对象，但是这些对象是由系统自动创建的，而不是通过 router 创建的，因此需要通过 router 对其进行配置，例如 storyboard 中创建的 view controller。此时将 view controller 模块化后，依然可以保持现有代码，只需要调用一句<code>prepareDestination:configuration:</code>配置即可，模块化的过程中就能让代码的修改最小化。</p>
<h3 id="可选依赖：属性注入和方法注入"><a href="#可选依赖：属性注入和方法注入" class="headerlink" title="可选依赖：属性注入和方法注入"></a>可选依赖：属性注入和方法注入</h3><p>当依赖是可选的，并不是创建对象所必需的，可以用属性注入和方法注入。</p>
<p>属性注入是指外部设置对象的属性。方法注入是指外部调用对象的方法，从而传入依赖。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PersonType</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> wife: <span class="type">Person</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">// 可选的属性依赖</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addChild</span><span class="params">(<span class="number">_</span> child: Person)</span></span> -&gt; <span class="type">Void</span> <span class="comment">// 可选的方法注入</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Child</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> parent: <span class="type">Person</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">PersonType</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> wife: <span class="type">Person</span>? = <span class="literal">nil</span></div><div class="line">    <span class="keyword">var</span> childs: <span class="type">Set</span>&lt;<span class="type">Child</span>&gt; = []</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addChild</span><span class="params">(<span class="number">_</span> child: Child)</span></span> &#123;</div><div class="line">        childs.insert(child)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">PersonType</span>: <span class="title">ZIKServiceRoutable</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) Person *wife; <span class="comment">// 可选的属性依赖</span></div><div class="line">- (<span class="keyword">void</span>)addChild:(Person *)child; <span class="comment">// 可选的方法注入</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Child</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *parent;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>: <span class="title">NSObject</span> &lt;<span class="title">PersonType</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) Person *wife;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSSet</span>&lt;<span class="keyword">id</span>&lt;Child&gt;&gt; childs;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>在 router 里，可以注入一些默认的依赖：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">Person</span>, <span class="title">PerformRouteConfig</span>&gt; </span>&#123;</div><div class="line">    ...    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: PerformRouteConfig)</span></span> -&gt; <span class="type">Person</span>? &#123;</div><div class="line">        <span class="keyword">let</span> person = <span class="type">Person</span>()</div><div class="line">        <span class="keyword">return</span> person</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 配置模块，注入静态依赖</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareDestination</span><span class="params">(<span class="number">_</span> destination: Person, configuration: PerformRouteConfig)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> destination.wife != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//设置默认值</span></div><div class="line">        <span class="keyword">let</span> wife: <span class="type">Person</span> = ...</div><div class="line">        person.wife = wife</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PersonRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">Person</span> *, <span class="title">ZIKPerformRouteConfiguration</span> *&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonRouter</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> Person *)destinationWithConfiguration:(ZIKPerformRouteConfiguration *)configuration &#123;</div><div class="line">    Person *person = [Person new];</div><div class="line">    <span class="keyword">return</span> person;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 配置模块，注入静态依赖</span></div><div class="line">- (<span class="keyword">void</span>)prepareDestination:(Person *)destination configuration:(ZIKPerformRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">if</span> (destination.wife != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    Person *wife = ...</div><div class="line">    destination.wife = wife;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h4 id="模块间参数传递"><a href="#模块间参数传递" class="headerlink" title="模块间参数传递"></a>模块间参数传递</h4><p>在执行路由操作的同时，调用者也可以用<code>PersonType</code>动态地注入依赖，也就是向模块传参。</p>
<p>configuration 就是用来进行各种功能扩展的。Router 可以在 configuration 上提供<code>prepareDestination</code>，让调用者设置，就能让调用者配置 destination。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> wife: <span class="type">Person</span> = ...</div><div class="line"><span class="keyword">let</span> child: <span class="type">Child</span> = ...</div><div class="line"><span class="keyword">let</span> person = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableService</span>&lt;<span class="type">PersonType</span>&gt;(), configuring: &#123; (config, <span class="number">_</span>) <span class="keyword">in</span></div><div class="line">    <span class="comment">// 获取模块的同时进行配置</span></div><div class="line">    config.prepareDestination = &#123; destination <span class="keyword">in</span></div><div class="line">        destination.wife = wife</div><div class="line">        destination.addChild(child)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Person *wife = ...</div><div class="line">Child *child = ...</div><div class="line">Person *person = [ZIKRouterToService(PersonType) </div><div class="line">         makeDestinationWithConfiguring:^(ZIKPerformRouteConfiguration *config) &#123;</div><div class="line">    <span class="comment">// 获取模块的同时进行配置</span></div><div class="line">    config.prepareDestination = ^(<span class="keyword">id</span>&lt;PersonType&gt; destination) &#123;</div><div class="line">        destination.wife = wife;</div><div class="line">        [destination addChild:child];</div><div class="line">    &#125;;</div><div class="line">&#125;];</div></pre></td></tr></table></figure><br><br></details>

<p>封装一下就能变成更简单的接口：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> wife: <span class="type">Person</span> = ...</div><div class="line"><span class="keyword">let</span> child: <span class="type">Child</span> = ...</div><div class="line"><span class="keyword">let</span> person = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableService</span>&lt;<span class="type">PersonType</span>&gt;(), preparation: &#123; destination <span class="keyword">in</span></div><div class="line">            destination.wife = wife</div><div class="line">            destination.addChild(child)</div><div class="line">        &#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Person *wife = ...</div><div class="line">Child *child = ...</div><div class="line">Person *person = [ZIKRouterToService(PersonType) </div><div class="line">         makeDestinationWithPreparation:^(<span class="keyword">id</span>&lt;PersonType&gt; destination) &#123;</div><div class="line">            destination.wife = wife;</div><div class="line">            [destination addChild:child];</div><div class="line">        &#125;];</div></pre></td></tr></table></figure><br><br></details>

<h3 id="必需依赖：工厂方法"><a href="#必需依赖：工厂方法" class="headerlink" title="必需依赖：工厂方法"></a>必需依赖：工厂方法</h3><p>有一些参数是在 destination 类创建前就需要传入的必需参数，例如初始化方法中的参数，就是必需依赖。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">PersonType</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="comment">// 初始化方法，需要必需参数</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>: <span class="title">NSObject</span> &lt;<span class="title">PersonType</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="comment">// 初始化方法，需要必需参数</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>这些必需参数有时候是由调用者提供的。在 URL 路由中，这种”必需”特性就无法体现出来，而用接口的方式就能简单地实现。</p>
<p>传递必需依赖需要用工厂模式，在工厂方法上声明必需参数和模块接口。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PersonTypeFactory</span> </span>&#123;</div><div class="line">  <span class="comment">// 工厂方法，声明了必需参数 name，返回 PersonType 类型的 destination</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeDestinationWith</span><span class="params">(<span class="number">_</span> name: String)</span></span> -&gt; <span class="type">PersonType</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">PersonTypeFactory</span>: <span class="title">ZIKServiceModuleRoutable</span></span></div><div class="line"><span class="comment">// 工厂方法，声明了必需参数 name，返回 PersonType 类型的 destination</span></div><div class="line">- (<span class="keyword">id</span>&lt;PersonType&gt;)makeDestinationWith:(<span class="built_in">NSString</span> *)name;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>那么如何用 router 传递必需参数呢？</p>
<p>Router 的 configuration 可以用来进行自定义参数扩展。可以把必需参数保存到 configuration 上，或者更直接点，由 configuration 来提供工厂方法，然后使用工厂方法的 protocol 来获取模块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通用 configuration，可以提供自定义工厂方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonModuleConfiguration</span>: <span class="title">PerformRouteConfig</span>, <span class="title">PersonTypeFactory</span> </span>&#123;</div><div class="line">    <span class="comment">// 工厂方法</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeDestinationWith</span><span class="params">(<span class="number">_</span> name: String)</span></span> -&gt; <span class="type">PersonType</span>? &#123;</div><div class="line">        <span class="keyword">self</span>.makedDestination = <span class="type">Person</span>(name: name)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.makedDestination</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 由工厂方法创建的 destination，提供给 router</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> makedDestination: <span class="type">Destination</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通用 configuration，可以提供自定义工厂方法</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PersonModuleConfiguration</span>: <span class="title">ZIKPerformRouteConfiguration</span>&lt;<span class="title">PersonTypeFactory</span>&gt;</span></div><div class="line"><span class="comment">// 由工厂方法创建的 destination，提供给 router</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span>&lt;PersonTypeFactory&gt; makedDestination;</div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonModuleConfiguration</span></span></div><div class="line"><span class="comment">// 工厂方法</span></div><div class="line">-(<span class="keyword">id</span>&lt;PersonTypeFactory&gt;)makeDestinationWith:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="keyword">self</span>.makedDestination = [[Person alloc] initWithName:name];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.makedDestination;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>在 router 中使用自定义 configuration：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">Person</span>, <span class="title">PersonModuleConfiguration</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 重写 defaultRouteConfiguration，使用自定义 configuration</span></div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultRouteConfiguration</span>() -&gt; <span class="title">PersonModuleConfiguration</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">PersonModuleConfiguration</span>()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: PersonModuleConfiguration)</span></span> -&gt; <span class="type">Person</span>? &#123;</div><div class="line">        <span class="comment">// 使用工厂方法创建的 destination</span></div><div class="line">        <span class="keyword">return</span> config.makedDestination</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PersonRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">id</span>&lt;<span class="title">PersonType</span>&gt;, <span class="title">PersonModuleConfiguration</span> *&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonRouter</span></span></div><div class="line">  </div><div class="line"><span class="comment">// 重写 defaultRouteConfiguration，使用自定义 configuration</span></div><div class="line">+ (PersonModuleConfiguration *)defaultRouteConfiguration &#123;</div><div class="line">    <span class="keyword">return</span> [PersonModuleConfiguration new];</div><div class="line">&#125;</div><div class="line">  </div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;PersonType&gt;)destinationWithConfiguration:(PersonModuleConfiguration *)configuration &#123;</div><div class="line">    <span class="comment">// 使用工厂方法创建的 destination</span></div><div class="line">    <span class="keyword">return</span> configuration.makedDestination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>然后把<code>PersonTypeFactory</code>协议和 router 进行注册：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">PersonRouter</span>.register(<span class="type">RoutableServiceModule</span>&lt;<span class="type">PersonTypeFactory</span>&gt;())</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[PersonRouter registerModuleProtocol:ZIKRoutable(PersonTypeFactory)];</div></pre></td></tr></table></figure><br><br></details>

<p>就可以用<code>PersonTypeFactory</code>获取模块了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name: <span class="type">String</span> = ...</div><div class="line"><span class="type">Router</span>.makeDestination(to: <span class="type">RoutableServiceModule</span>&lt;<span class="type">PersonTypeFactory</span>&gt;(), configuring: &#123; (config, <span class="number">_</span>) <span class="keyword">in</span></div><div class="line">    <span class="comment">// config 遵守 PersonTypeFactory</span></div><div class="line">    config.makeDestinationWith(name)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *name = ...</div><div class="line">ZIKRouterToServiceModule(PersonTypeFactory) makeDestinationWithConfiguring:^(ZIKPerformRouteConfiguration&lt;PersonTypeFactory&gt; *config) &#123;</div><div class="line">    <span class="comment">// config 遵守 PersonTypeFactory</span></div><div class="line">    [config makeDestinationWith:name];</div><div class="line">&#125;]</div></pre></td></tr></table></figure><br><br></details>

<h4 id="用泛型代替-configuration-子类"><a href="#用泛型代替-configuration-子类" class="headerlink" title="用泛型代替 configuration 子类"></a>用泛型代替 configuration 子类</h4><p>如果你不需要在 configuration 上保存其他自定义参数，也不想创建过多的 configuration 子类，可以用一个通用的泛型类来实现子类重写的效果。</p>
<p>泛型可以自定义参数类型，此时可以直接把工厂方法用 block 保存在 configuration 的属性上。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通用 configuration，可以提供自定义工厂方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceMakeableConfiguration</span>&lt;<span class="title">Destination</span>, <span class="title">Constructor</span>&gt;: <span class="title">PerformRouteConfig</span> </span>&#123;    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> makeDestinationWith: <span class="type">Constructor</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> makedDestination: <span class="type">Destination</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZIKServiceMakeableConfiguration</span>&lt;<span class="title">__covariant</span> <span class="title">Destination</span>&gt;: <span class="title">ZIKPerformRouteConfiguration</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) Destination(^makeDestinationWith)();</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) Destination makedDestination;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>在 router 中使用自定义 configuration：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">Person</span>, <span class="title">PerformRouteConfig</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 重写 defaultRouteConfiguration，使用自定义 configuration</span></div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultRouteConfiguration</span>() -&gt; <span class="title">PerformRouteConfig</span> </span>&#123;</div><div class="line">        <span class="keyword">let</span> config = <span class="type">ServiceMakeableConfiguration</span>&lt;<span class="type">PersonType</span>, (<span class="type">String</span>) -&gt; <span class="type">PersonType</span>&gt;(&#123; <span class="number">_</span> <span class="keyword">in</span>&#125;)</div><div class="line">        <span class="comment">// 设置工厂方法，让调用者使用</span></div><div class="line">        config.makeDestinationWith = &#123; [<span class="keyword">unowned</span> config] name <span class="keyword">in</span></div><div class="line">            config.makedDestination = <span class="type">Person</span>(name: name)</div><div class="line">            <span class="keyword">return</span> config.makedDestination</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> config</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: PerformRouteConfig)</span></span> -&gt; <span class="type">Person</span>? &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> config = configuration <span class="keyword">as</span>? <span class="type">ServiceMakeableConfiguration</span>&lt;<span class="type">PersonType</span>, (<span class="type">String</span>) -&gt; <span class="type">PersonType</span>&gt; &#123;</div><div class="line">            <span class="comment">// 使用工厂方法创建的 destination</span></div><div class="line">            <span class="keyword">return</span> config.makedDestination</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 让对应泛型的 configuration 遵守 PersonTypeFactory</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServiceMakeableConfiguration</span>: <span class="title">PersonTypeFactory</span> <span class="title">where</span> <span class="title">Destination</span> == <span class="title">PersonType</span>, <span class="title">Constructor</span> == (<span class="title">String</span>) -&gt; <span class="title">PersonType</span> </span>&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PersonRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">id</span>&lt;<span class="title">PersonType</span>&gt;, <span class="title">ZIKServiceMakeableConfiguration</span> *&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonRouter</span></span></div><div class="line"></div><div class="line"><span class="comment">// 重写 defaultRouteConfiguration，使用自定义 configuration</span></div><div class="line">+ (ZIKServiceMakeableConfiguration *)defaultRouteConfiguration &#123;</div><div class="line">    ZIKServiceMakeableConfiguration *config = [ZIKServiceMakeableConfiguration new];</div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(config) weakConfig = config;</div><div class="line">    <span class="comment">// 设置工厂方法，让调用者使用</span></div><div class="line">    config.makeDestinationWith = <span class="keyword">id</span> ^(<span class="built_in">NSString</span> *name) &#123;</div><div class="line">        weakConfig.makedDestination = [[Person alloc] initWithName:name];</div><div class="line">        <span class="keyword">return</span> weakConfig.makedDestination;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> config;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;PersonType&gt;)destinationWithConfiguration:(ZIKServiceMakeableConfiguration *)configuration &#123;</div><div class="line">    <span class="comment">// 使用工厂方法创建的 destination</span></div><div class="line">    <span class="keyword">return</span> configuration.makedDestination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="避免接口污染"><a href="#避免接口污染" class="headerlink" title="避免接口污染"></a>避免接口污染</h3><p>除了必需依赖，还有一些参数是不属于 destination 类的，而是属于模块内其他组件的，也不能通过 destination 的接口来传递。例如 MVVM 和 VIPER 架构中，model 参数不能传给 view，而是应该交给 view model 或者 interactor。此时可以使用相同的模式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">EditorViewModuleInput</span> </span>&#123;</div><div class="line">  <span class="comment">// 工厂方法，声明了参数 note，返回 EditorViewInput 类型的 destination</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeDestinationWith</span><span class="params">(<span class="number">_</span> note: Note)</span></span> -&gt; <span class="type">EditorViewInput</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">EditorViewModuleInput</span>: <span class="title">ZIKViewModuleRoutable</span></span></div><div class="line"><span class="comment">// 工厂方法，声明了参数 note，返回 EditorViewInput 类型的 destination</span></div><div class="line">- (<span class="keyword">id</span>&lt;EditorViewInput&gt;)makeDestinationWith:(Note *)note;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewInput</span>, <span class="title">ViewRouteConfig</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 重写 defaultRouteConfiguration，使用自定义 configuration</span></div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultRouteConfiguration</span>() -&gt; <span class="title">ViewRouteConfig</span> </span>&#123;</div><div class="line">        <span class="keyword">let</span> config = <span class="type">ViewMakeableConfiguration</span>&lt;<span class="type">EditorViewInput</span>, (<span class="type">Note</span>) -&gt; <span class="type">EditorViewInput</span>&gt;(&#123; <span class="number">_</span> <span class="keyword">in</span>&#125;)</div><div class="line">        <span class="comment">// 设置工厂方法，让调用者使用</span></div><div class="line">        config.makeDestinationWith = &#123; [<span class="keyword">unowned</span> config] note <span class="keyword">in</span>            </div><div class="line">            config.makedDestination = <span class="keyword">self</span>.makeDestinationWith(note: note)</div><div class="line">            <span class="keyword">return</span> config.makedDestination</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> config</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">makeDestinationWith</span>(<span class="title">note</span>: <span class="title">Note</span>) -&gt; <span class="title">EditorViewInput</span> </span>&#123;</div><div class="line">        <span class="keyword">let</span> view = <span class="type">EditorViewController</span>()</div><div class="line">        <span class="keyword">let</span> presenter = <span class="type">EditorViewPresenter</span>(view)</div><div class="line">        <span class="keyword">let</span> interactor = <span class="type">EditorInteractor</span>(<span class="type">Presenter</span>)</div><div class="line">        <span class="comment">// 把 model 传递给数据管理者，view 不接触 model</span></div><div class="line">        interactor.note = note</div><div class="line">        <span class="keyword">return</span> view</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">EditorViewInput</span>? &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> config = configuration <span class="keyword">as</span>? <span class="type">ViewMakeableConfiguration</span>&lt;<span class="type">EditorViewInput</span>, (<span class="type">Note</span>) -&gt; <span class="type">EditorViewInput</span>&gt; &#123;</div><div class="line">            <span class="comment">// 使用工厂方法创建的 destination</span></div><div class="line">            <span class="keyword">return</span> config.makedDestination</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">id</span>&lt;<span class="title">EditorViewInput</span>&gt;, <span class="title">ZIKViewMakeableConfiguration</span> *&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonRouter</span></span></div><div class="line"></div><div class="line"><span class="comment">// 重写 defaultRouteConfiguration，使用自定义 configuration</span></div><div class="line">+ (ZIKViewMakeableConfiguration *)defaultRouteConfiguration &#123;</div><div class="line">    ZIKViewMakeableConfiguration *config = [ZIKViewMakeableConfiguration new];</div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(config) weakConfig = config;</div><div class="line">    <span class="comment">// 设置工厂方法，让调用者使用</span></div><div class="line">    config.makeDestinationWith = <span class="keyword">id</span> ^(Note *note) &#123;</div><div class="line">        weakConfig.makedDestination = [<span class="keyword">self</span> makeDestinationWith:note];</div><div class="line">        <span class="keyword">return</span> weakConfig.makedDestination;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> config;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>&lt;EditorViewInput&gt;)makeDestinationWith:(Note *)note &#123;</div><div class="line">    EditorViewController *view = [[EditorViewController alloc] init];</div><div class="line">    EditorViewPresenter *presenter = [[EditorViewPresenter alloc] initWithView:view];</div><div class="line">    EditorInteractor *interactor = [[EditorInteractor alloc] initWithPresenter:presenter];</div><div class="line">    <span class="comment">// 把 model 传递给数据管理者，view 不接触 model</span></div><div class="line">    interactor.note = note;</div><div class="line">    <span class="keyword">return</span> view;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;EditorViewInput&gt;)destinationWithConfiguration:(ZIKViewMakeableConfiguration *)configuration &#123;</div><div class="line">    <span class="comment">// 使用工厂方法创建的 destination</span></div><div class="line">    <span class="keyword">return</span> configuration.makedDestination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>就可以用<code>EditorViewModuleInput</code>获取模块了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> note: <span class="type">Note</span> = ...</div><div class="line"><span class="type">Router</span>.makeDestination(to: <span class="type">RoutableViewModule</span>&lt;<span class="type">EditorViewModuleInput</span>&gt;(), configuring: &#123; (config, <span class="number">_</span>) <span class="keyword">in</span></div><div class="line">    <span class="comment">// config 遵守 EditorViewModuleInput</span></div><div class="line">    config.makeDestinationWith(note)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Note *note = ...</div><div class="line">ZIKRouterToViewModule(EditorViewModuleInput) makeDestinationWithConfiguring:^(ZIKViewRouteConfiguration&lt;EditorViewModuleInput&gt; *config) &#123;</div><div class="line">    <span class="comment">// config 遵守 EditorViewModuleInput</span></div><div class="line">    config.makeDestinationWith(note);</div><div class="line">&#125;]</div></pre></td></tr></table></figure><br><br></details>

<h3 id="依赖查找"><a href="#依赖查找" class="headerlink" title="依赖查找"></a>依赖查找</h3><p>当模块的必需依赖很多时，如果把依赖都放在初始化接口中，就会出现一个非常长的方法。</p>
<p>除了让模块把依赖声明在接口中，模块内部也可以用模块管理工具动态查找依赖，例如用 router 查找 protocol 对应的模块。如果要使用这种模式，那么所有模块都需要统一使用相同的模块管理工具。</p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> storageService: <span class="type">EditorStorageServiceInput</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableService</span>&lt;<span class="type">EditorStorageServiceInput</span>&gt;())!</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewController</span> : <span class="title">UIViewController</span>()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;EditorStorageServiceInput&gt; storageService;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewController</span></span></div><div class="line">  </div><div class="line">- (<span class="keyword">id</span>&lt;EditorStorageServiceInput&gt;)storageService &#123;</div><div class="line">    <span class="keyword">if</span> (!_storageService) &#123;</div><div class="line">        _storageService = [ZIKRouterToService(EditorStorageServiceInput) makeDestination];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _storageService;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>使用依赖注入时，有些特殊情况需要处理，例如循环依赖的无限递归问题。</p>
<p>循环依赖是指两个对象互相依赖。</p>
<p>在 router 内部动态注入依赖时，如果注入的依赖同时依赖于被注入的对象，则必须在 protocol 中声明。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="comment">// Parent 依赖 Child</span></div><div class="line">    <span class="keyword">var</span> child: <span class="type">Child</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Child</span> </span>&#123;</div><div class="line">    <span class="comment">// Child 依赖 Parent</span></div><div class="line">    <span class="keyword">var</span> parent: <span class="type">Parent</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentObject</span>: <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> child: <span class="type">Child</span>!</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildObject</span>: <span class="title">Child</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> parent: <span class="type">Parent</span>!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Parent</span> &lt;<span class="title">ZIKServiceRoutable</span>&gt;</span></div><div class="line"><span class="comment">// Parent 依赖 Child</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;Child&gt; child;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Child</span> &lt;<span class="title">ZIKServiceRoutable</span>&gt;</span></div><div class="line"><span class="comment">// Child 依赖 Parent</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;Parent&gt; parent;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ParentObject</span>: <span class="title">NSObject</span>&lt;<span class="title">Parent</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ParentObject</span>: <span class="title">NSObject</span>&lt;<span class="title">Child</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">ParentObject</span>, <span class="title">PerformRouteConfig</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: PerformRouteConfig)</span></span> -&gt; <span class="type">ParentObject</span>? &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">ParentObject</span>()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareDestination</span><span class="params">(<span class="number">_</span> destination: ParentObject, configuration: PerformRouteConfig)</span></span> &#123;</div><div class="line">        <span class="keyword">guard</span> destination.child == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 只有在外部没有设置 child 时，才去主动寻找依赖</span></div><div class="line">        <span class="keyword">let</span> child = <span class="type">Router</span>.makeDestination(to <span class="type">RoutableService</span>&lt;<span class="type">Child</span>&gt;(), preparation &#123; child <span class="keyword">in</span></div><div class="line">            <span class="comment">// 设置 child 的依赖，防止 child 内部再去寻找 parent 依赖，导致循环</span></div><div class="line">            child.parent = destination</div><div class="line">        &#125;)</div><div class="line">        destination.child = child</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">ChildObject</span>, <span class="title">PerformRouteConfig</span>&gt; </span>&#123;</div><div class="line">      </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: PerformRouteConfig)</span></span> -&gt; <span class="type">ChildObject</span>? &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">ChildObject</span>()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareDestination</span><span class="params">(<span class="number">_</span> destination: ChildObject, configuration: PerformRouteConfig)</span></span> &#123;</div><div class="line">        <span class="keyword">guard</span> destination.parent == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 只有在外部没有设置 parent 时，才去主动寻找依赖</span></div><div class="line">        <span class="keyword">let</span> parent = <span class="type">Router</span>.makeDestination(to <span class="type">RoutableService</span>&lt;<span class="type">Parent</span>&gt;(), preparation &#123; parent <span class="keyword">in</span></div><div class="line">            <span class="comment">// 设置 parent 的依赖，防止 parent 内部再去寻找 child 依赖，导致循环</span></div><div class="line">            parent.child = destination</div><div class="line">        &#125;)</div><div class="line">        destination.parent = parent</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ParentRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">ParentObject</span> *, <span class="title">ZIKPerformRouteConfiguration</span> *&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ParentRouter</span></span></div><div class="line"></div><div class="line">- (ParentObject *)destinationWithConfiguration:(ZIKPerformRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">return</span> [ParentObject new];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)prepareDestination:(ParentObject *)destination configuration:(ZIKPerformRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">if</span> (destination.child) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 只有在外部没有设置 child 时，才去主动寻找依赖</span></div><div class="line">    destination.child = [ZIKRouterToService(Child) makeDestinationWithPreparation:^(<span class="keyword">id</span>&lt;Child&gt; child) &#123;</div><div class="line">        <span class="comment">// 设置 child 的依赖，防止 child 内部再去寻找 parent 依赖，导致循环</span></div><div class="line">        child.parent = destination;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ChildRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">ChildObject</span> *, <span class="title">ZIKPerformRouteConfiguration</span> *&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ChildRouter</span></span></div><div class="line"></div><div class="line">- (ChildObject *)destinationWithConfiguration:(ZIKPerformRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">return</span> [ChildObject new];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)prepareDestination:(ChildObject *)destination configuration:(ZIKPerformRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">if</span> (destination.parent) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 只有在外部没有设置 parent 时，才去主动寻找依赖</span></div><div class="line">    destination.parent = [ZIKRouterToService(Parent) makeDestinationWithPreparation:^(<span class="keyword">id</span>&lt;Parent&gt; parent) &#123;</div><div class="line">        <span class="comment">// 设置 parent 的依赖，防止 parent 内部再去寻找 child 依赖，导致循环</span></div><div class="line">        parent.child = destination;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>这样就能避免循环依赖导致的无限递归问题。</p>
<h2 id="模块适配器"><a href="#模块适配器" class="headerlink" title="模块适配器"></a>模块适配器</h2><p>当使用 protocol 管理模块时，protocol 必定会出现在多个模块中。那么此时如何让每个模块单独编译呢？</p>
<p>一个方式是把 protocol 在每个用到的模块里复制一份，而且无需修改 protocol 名，Xcode 不会报错。</p>
<p>另一个方式是使用适配器模式，可以让不同模块使用各自不同的 protocol 和同一个模块交互。</p>
<h3 id="required-protocol-和-provided-protocol"><a href="#required-protocol-和-provided-protocol" class="headerlink" title="required protocol 和 provided protocol"></a>required protocol 和 provided protocol</h3><p>你可以为同一个 router 注册多个 protocol。</p>
<p>根据依赖关系，接口可以分为<code>required protocol</code>和<code>provided protocol</code>。模块本身提供的接口是<code>provided protocol</code>，模块的调用者需要使用的接口是<code>required protocol</code>。</p>
<p><code>required protocol</code>是<code>provided protocol</code>的子集，调用者只需要声明自己用到的那些接口，不必引入整个<code>provided protocol</code>，这样可以让模块间的耦合进一步减少。</p>
<p>在 UML 的<a href="http://www.uml-diagrams.org/component-diagrams.html" target="_blank" rel="external">组件图</a>中，就很明确地表现出了这两者的概念。下图中的半圆就是<code>Required Interface</code>，框外的圆圈就是<code>Provided Interface</code>：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5879294-6309bffe07ebf178.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="组件图"></p>
<p>那么如何实施<code>Required Interface</code>和<code>Provided Interface</code>？从架构分层上看，所有的模块都是依附于一个更上层的宿主 app 环境存在的，应该由使用这些模块的宿主 app 在一个 adapter 里进行接口适配，从而使得调用者可以继续在内部使用<code>required protocol</code>，adapter 负责把<code>required protocol</code>和修改后的<code>provided protocol</code>进行适配。整个过程模块都无感知。</p>
<p>这时候，调用者中定义的<code>required protocol</code>就相当于是在声明自己所依赖的外部模块。</p>
<h3 id="为provided模块添加required-protocol"><a href="#为provided模块添加required-protocol" class="headerlink" title="为provided模块添加required protocol"></a>为<code>provided</code>模块添加<code>required protocol</code></h3><p>模块适配的工作全部由模块的使用和装配者 App Context 完成，最少时只需要两行代码。</p>
<p>例如，某个模块需要展示一个登陆界面，而且这个登陆界面可以显示一段自定义的提示语。</p>
<p>调用者模块示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用者中声明的依赖接口，表明自身依赖一个登陆界面</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RequiredLoginViewInput</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> message: <span class="type">String</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">//显示在登陆界面上的自定义提示语</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用者中调用 login 模块</span></div><div class="line"><span class="type">Router</span>.makeDestination(to: <span class="type">RoutableView</span>&lt;<span class="type">RequiredLoginViewInput</span>&gt;(), preparation: &#123;</div><div class="line">    destination.message = <span class="string">"请登录"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用者中声明的依赖接口，表明自身依赖一个登陆界面</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RequiredLoginViewInput</span> &lt;<span class="title">ZIKViewRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *message;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 调用者中调用 login 模块</span></div><div class="line">[ZIKRouterToView(RequiredLoginViewInput) makeDestinationWithPraparation:^(<span class="keyword">id</span>&lt;RequiredLoginViewInput&gt; destination) &#123;</div><div class="line">    destination.message = <span class="string">@"请登录"</span>;</div><div class="line">&#125;];</div></pre></td></tr></table></figure><br><br></details>

<p>实际登陆界面提供的接口则是<code>ProvidedLoginViewInput</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实际登陆界面提供的接口</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProvidedLoginViewInput</span> </span>&#123;</div><div class="line">   <span class="keyword">var</span> message: <span class="type">String</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实际登陆界面提供的接口</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProvidedLoginViewInput</span> &lt;<span class="title">ZIKViewRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *message;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>适配的代码由宿主 app 实现，让登陆界面支持 <code>RequiredLoginViewInput</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 让模块支持 required protocol，只需要添加一个 protocol 扩展即可</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LoginViewController</span>: <span class="title">RequiredLoginViewInput</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 让模块支持 required protocol，只需要添加一个 protocol 扩展即可</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LoginViewController</span> (<span class="title">ModuleAAdapter</span>) &lt;<span class="title">RequiredLoginViewInput</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LoginViewController</span> (<span class="title">ModuleAAdapter</span>)</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>并且让登陆界面的 router 也支持 <code>RequiredLoginViewInput</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果可以获取到 router 类，可以直接为 router 添加 RequiredLoginViewInput</span></div><div class="line"><span class="type">LoginViewRouter</span>.register(<span class="type">RoutableView</span>&lt;<span class="type">RequiredLoginViewInput</span>&gt;())</div><div class="line"><span class="comment">// 如果不能得到对应模块的 router，可以用 adapter 进行转发</span></div><div class="line"><span class="type">ZIKViewRouteAdapter</span>.register(adapter: <span class="type">RoutableView</span>&lt;<span class="type">RequiredLoginViewInput</span>&gt;(), forAdaptee: <span class="type">RoutableView</span>&lt;<span class="type">ProvidedLoginViewInput</span>&gt;())</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果可以获取到 router 类，可以直接为 router 添加 RequiredLoginViewInput</span></div><div class="line">[LoginViewRouter registerViewProtocol:ZIKRoutable(RequiredLoginViewInput)];</div><div class="line"><span class="comment">//如果不能得到对应模块的 router，可以注册 adapter</span></div><div class="line">[<span class="keyword">self</span> registerDestinationAdapter:ZIKRoutable(RequiredLoginViewInput) forAdaptee:ZIKRoutable(ProvidedLoginViewInput)];</div></pre></td></tr></table></figure><br><br></details>

<p>适配之后，<code>RequiredLoginViewInput</code>就能和<code>ProvidedLoginViewInput</code>一样使用，获取到同一个模块了：</p>
<p>调用者模块示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="type">Router</span>.makeDestination(to: <span class="type">RoutableView</span>&lt;<span class="type">RequiredLoginViewInput</span>&gt;(), preparation: &#123;</div><div class="line">    destination.message = <span class="string">"请登录"</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// ProvidedLoginViewInput 和 RequiredLoginViewInput 能获取到同一个 router</span></div><div class="line"><span class="type">Router</span>.makeDestination(to: <span class="type">RoutableView</span>&lt;<span class="type">ProvidedLoginViewInput</span>&gt;(), preparation: &#123;</div><div class="line">    destination.message = <span class="string">"请登录"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[ZIKRouterToView(RequiredLoginViewInput) makeDestinationWithPraparation:^(<span class="keyword">id</span>&lt;RequiredLoginViewInput&gt; destination) &#123;</div><div class="line">    destination.message = <span class="string">@"请登录"</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// ProvidedLoginViewInput 和 RequiredLoginViewInput 能获取到同一个 router</span></div><div class="line">[ZIKRouterToView(RequiredLoginViewInput) makeDestinationWithPraparation:^(<span class="keyword">id</span>&lt;ProvidedLoginViewInput&gt; destination) &#123;</div><div class="line">    destination.message = <span class="string">@"请登录"</span>;</div><div class="line">&#125;];</div></pre></td></tr></table></figure><br><br></details>

<h3 id="接口适配"><a href="#接口适配" class="headerlink" title="接口适配"></a>接口适配</h3><p>有时候<code>ProvidedLoginViewInput</code>和<code>RequiredLoginViewInput</code>的接口名可能会稍有不同，此时需要用 category、extension、子类、proxy 类等方式进行接口适配。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProvidedLoginViewInput</span> </span>&#123;</div><div class="line">   <span class="keyword">var</span> notifyString: <span class="type">String</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">// 接口名不同</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProvidedLoginViewInput</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *notifyString; <span class="comment">// 接口名不同</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>适配时需要进行接口转发，让登陆界面支持 <code>RequiredLoginViewInput</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LoginViewController</span>: <span class="title">RequiredLoginViewInput</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> message: <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> notifyString</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            notifyString = newValue</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LoginViewController</span> (<span class="title">ModuleAAdapter</span>) &lt;<span class="title">RequiredLoginViewInput</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *message;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LoginViewController</span> (<span class="title">ModuleAAdapter</span>)</span></div><div class="line">- (<span class="keyword">void</span>)setMessage:(<span class="built_in">NSString</span> *)message &#123;</div><div class="line">true<span class="keyword">self</span>.notifyString = message;</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSString</span> *)message &#123;</div><div class="line">true<span class="keyword">return</span> <span class="keyword">self</span>.notifyString;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="用中介者转发接口"><a href="#用中介者转发接口" class="headerlink" title="用中介者转发接口"></a>用中介者转发接口</h3><p>如果不能直接为模块添加<code>required protocol</code>，比如 protocol 里的一些 delegate 需要兼容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RequiredLoginViewDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didFinishLogin</span><span class="params">()</span></span> -&gt; <span class="type">Void</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RequiredLoginViewInput</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> message: <span class="type">String</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">  <span class="keyword">var</span> delegate: <span class="type">RequiredLoginViewDelegate</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RequiredLoginViewDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)didFinishLogin;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RequiredLoginViewInput</span> &lt;<span class="title">ZIKViewRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *message;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;RequiredLoginViewDelegate&gt; delegate;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>而模块里的 delegate 接口不一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProvidedLoginViewDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didLogin</span><span class="params">()</span></span> -&gt; <span class="type">Void</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProvidedLoginViewInput</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> notifyString: <span class="type">String</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">  <span class="keyword">var</span> delegate: <span class="type">ProvidedLoginViewDelegate</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProvidedLoginViewDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)didLogin;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProvidedLoginViewInput</span> &lt;<span class="title">ZIKViewRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *notifyString;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;ProvidedLoginViewDelegate&gt; delegate;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>相同方法有不同参数类型时，可以用一个新的 router 代替真正的 router，在新的 router 里插入一个中介者，负责转发接口：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReqiredLoginViewRouter</span>: <span class="title">ProvidedLoginViewRouter</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ZIKViewRouteConfiguration)</span></span> -&gt; <span class="type">RequiredLoginViewInput</span>? &#123;</div><div class="line">       <span class="keyword">let</span> realDestination: <span class="type">ProvidedLoginViewInput</span> = <span class="keyword">super</span>.destination(with configuration)</div><div class="line">       <span class="comment">// proxy 负责把 RequiredLoginViewInput 转发为 ProvidedLoginViewInput</span></div><div class="line">       <span class="keyword">let</span> proxy: <span class="type">RequiredLoginViewInput</span> = <span class="type">ProxyForDestination</span>(realDestination)</div><div class="line">       <span class="keyword">return</span> proxy</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ReqiredLoginViewRouter</span> : <span class="title">ProvidedLoginViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RequiredLoginViewRouter</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">   <span class="keyword">id</span>&lt;ProvidedLoginViewInput&gt; realDestination = [<span class="keyword">super</span> destinationWithConfiguration:configuration];</div><div class="line">    <span class="comment">// proxy 负责把 RequiredLoginViewInput 转发为 ProvidedLoginViewInput</span></div><div class="line">    <span class="keyword">id</span>&lt;RequiredLoginViewInput&gt; proxy = ProxyForDestination(realDestination);</div><div class="line">    <span class="keyword">return</span> mediator;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>对于普通OC类，proxy 可以用 NSProxy 来实现。对于 UIKit 中的那些复杂的 UI 类，或者 Swift 类，可以用子类，然后在子类中重写方法，进行模块适配。</p>
<h3 id="声明式依赖"><a href="#声明式依赖" class="headerlink" title="声明式依赖"></a>声明式依赖</h3><p>利用之前的静态路由检查机制，模块只需要声明 required 接口，就能保证对应的模块必定存在。</p>
<p>模块无需在自己的接口里声明依赖，如果模块需要新增依赖，只需要创建新的 required 接口即可，无需修改接口本身。这样也能避免依赖变动导致的接口变化，减少接口维护的成本。</p>
<h3 id="模块提供默认的依赖配置"><a href="#模块提供默认的依赖配置" class="headerlink" title="模块提供默认的依赖配置"></a>模块提供默认的依赖配置</h3><p>每次引入模块，宿主 app 都需要写一份适配代码，虽然大多数情况下只有两行，但是我们想尽量减少宿主 app 的维护职责。</p>
<p>此时，可以让模块提供一份默认的依赖，用宏定义包裹，绕过编译检查。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#<span class="keyword">if</span> <span class="type">USE_DEFAULT_DEPENDENCY</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> ProvidedLoginModule</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">registerDefaultDependency</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="type">ZIKViewRouteAdapter</span>.register(adapter: <span class="type">RoutableView</span>&lt;<span class="type">RequiredLoginViewInput</span>&gt;(), forAdaptee: <span class="type">RoutableView</span>&lt;<span class="type">ProvidedLoginViewInput</span>&gt;())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProvidedLoginViewController</span>: <span class="title">RequiredLoginViewInput</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if USE_DEFAULT_DEPENDENCY</span></div><div class="line"></div><div class="line"><span class="keyword">@import</span> ProvidedLoginModule;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> registerDefaultDependency() &#123;</div><div class="line">    [ZIKViewRouteAdapter registerDestinationAdapter:ZIKRoutable(RequiredLoginViewInput) forAdaptee:ZIKRoutable(ProvidedLoginViewInput)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 宏定义，默认的适配代码</span></div><div class="line"><span class="meta">#define ADAPT_DEFAULT_DEPENDENCY    \</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ProvidedLoginViewController</span> (<span class="title">Adapter</span>) &lt;<span class="title">RequiredLoginViewInput</span>&gt;    \</span></div><div class="line"><span class="keyword">@end</span>    \</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ProvidedLoginViewController</span> (<span class="title">Adapter</span>) \</span></div><div class="line"><span class="keyword">@end</span>    \</div><div class="line"></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure><br><br></details>

<p>如果宿主 app 要使用默认依赖，就在<code>.xcconfig</code>里设置<code>Preprocessor Macros</code>，开启宏定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GCC_PREPROCESSOR_DEFINITIONS = $(inherited) USE_DEFAULT_DEPENDENCY=1</div></pre></td></tr></table></figure>
<p>如果是 Swift 模块，需要在模块的 target 里设置<code>Active Compilation Conditions</code>，添加编译宏<code>USE_DEFAULT_DEPENDENCY</code>。</p>
<p>宿主 app 直接调用默认的适配代码即可，不用再负责维护：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">registerAdapters</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 注册默认的依赖</span></div><div class="line">    registerDefaultDependency()</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> registerAdapters() &#123;</div><div class="line">    <span class="comment">// 注册默认的依赖</span></div><div class="line">    registerDefaultDependency();</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用默认的适配代码</span></div><div class="line">ADAPT_DEFAULT_DEPENDENCY</div></pre></td></tr></table></figure><br><br></details>

<p>如果宿主 app 需要替换使用另一个 provided 模块，可以关闭宏定义，再写一份另外的适配代码，即可替换依赖。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p><img src="https://images.xiaozhuanlan.com/photo/2019/aaaab3ad9c1df51b288da15f93af0786.png" alt=""></p>
<p>区分了<code>required protocol</code>和<code>provided protocol</code>后，就可以实现真正的模块化。在调用者声明了所需要的<code>required protocol</code>后，被调用模块就可以随时被替换成另一个相同功能的模块。</p>
<p>参考 demo 中的<code>ZIKLoginModule</code>示例模块，登录模块依赖于一个弹窗模块，而这个弹窗模块在<code>ZIKRouterDemo</code>和<code>ZIKRouterDemo-macOS</code>中是不同的，而在切换弹窗模块时，登录模块中的代码不需要做任何改变。</p>
<h3 id="使用-adapter-的规范"><a href="#使用-adapter-的规范" class="headerlink" title="使用 adapter 的规范"></a>使用 adapter 的规范</h3><p>一般来说，并不需要立即把所有的 protocol 都分离为<code>required protocol</code>和<code>provided protocol</code>。调用模块和目的模块可以暂时共用 protocol，或者只是简单地改个名字，让<code>required protocol</code>作为<code>provided protocol</code>的子集，在第一次需要替换模块的时候再用 category、extension、proxy、subclass 等技术进行接口适配。</p>
<p>接口适配也不能滥用，因为成本比较高，而且并非所有的接口都能适配，例如同步接口和异步接口就难以适配。</p>
<p>对于模块间耦合的处理，有这么几条建议：</p>
<ul>
<li>如果依赖的是提供特定功能的模块，没有通用性，直接引用类即可</li>
<li>如果是依赖某些简单的通用模块（例如日志模块），可以在模块的接口上把依赖交给外部来设置，例如 block 的形式</li>
<li>大部分需要解耦的模块都是需要重用的业务模块，如果你的模块不需要重用，并且也不需要分工开发，直接引用对应类即可</li>
<li>大部分情况下建议共用 protocol，或者让<code>required protocol</code>作为<code>provided protocol</code>的子集，接口名保持一致</li>
<li>只有在你的业务模块的确允许使用者使用不同的依赖模块时，才进行多个接口间的适配。例如需要跨平台的模块，例如登录界面模块允许不同的 app 使用不同的登陆 service 模块</li>
</ul>
<p>通过<code>required protocol</code>和<code>provided protocol</code>，我们就实现了模块间的完全解耦。</p>
<h2 id="模块间通信"><a href="#模块间通信" class="headerlink" title="模块间通信"></a>模块间通信</h2><p>模块间通信有多种方式，解耦程度也各有不同。这里只讨论接口交互的方式。</p>
<h3 id="控制流-input-和-output"><a href="#控制流-input-和-output" class="headerlink" title="控制流 input 和 output"></a>控制流 input 和 output</h3><p><img src="https://images.xiaozhuanlan.com/photo/2019/69b2e2874f7232fb64195380b1eb3e43.png" alt=""></p>
<p>模块的对外接口可以分为 input 和 output。两者的区别主要是控制流的主动权归属不同。</p>
<p>Input 是由外部主动调用的接口，控制流的发起者在外部，例如外部调用 view 的 UI 修改接口。</p>
<p>Output 是模块内部主动调用外部实现的接口，控制流的发起者在内部，需要外部实现 output 所要求的方法。例如输出 UI 事件、事件回调、获取外部的 dataSource。iOS 中常用的 delegate 模式，也是一种 output。</p>
<h3 id="设置-input-和-output"><a href="#设置-input-和-output" class="headerlink" title="设置 input 和 output"></a>设置 input 和 output</h3><p>模块设计好 input 和 output，然后在模块创建的时候，设置好模块之间的 input 和 output 关系，即可配置好模块间通信，同时充分解耦。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoteListViewController</span>: <span class="title">UIViewController</span>, <span class="title">EditorViewOutput</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showEditor</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> destination = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableView</span>&lt;<span class="type">EditorViewInput</span>&gt;(), preparation: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] destination <span class="keyword">in</span></div><div class="line">            destination.output = <span class="keyword">self</span></div><div class="line">        &#125;)</div><div class="line">        present(destination, animated: <span class="literal">true</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">EditorViewInput</span> </span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">EditorViewOutput</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><p><img src="https://images.xiaozhuanlan.com/photo/2019/99ae2c260a4ed9834d6710d30d987316.png" alt=""></p>
<p>大部分方案都没有讨论子模块存在的情况。如果使用了 MVVM 或者 VIPER 架构，此时一个 view controller 使用了 child view controller，那多个模块的 view model 和 interactor 之间如何交互？子模块由谁初始化、由谁管理？</p>
<p>有些方案是直接在父 view model 里创建和使用子 view model，但是这样就导致了 view 的实现方式影响了view model 的实现，如果父 view 里替换使用了另一个子 view，那父 view model 里的代码也需要修改。</p>
<h4 id="子模块的来源"><a href="#子模块的来源" class="headerlink" title="子模块的来源"></a>子模块的来源</h4><p>子模块的来源有：</p>
<ul>
<li>父 view 引用了一个封装好的子 view 控件，连带着引入了子 view 的整个 MVVM 或者 VIPER 模块</li>
<li>View model 或者 interactor 里使用了一个 Service</li>
</ul>
<h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><p>子 view 可能是一个 UIView，也可能是一个 Child UIViewController。因此子 view 有可能需要向外部请求数据，也可能独立完成所有任务，不需要依赖父模块。</p>
<p>如果子 view 可以独立，那在子模块里不会出现和父模块交互的逻辑，只有把一些事件通过 output 传递出去的接口。这时只需要把子 view 的 input 接口封装在父 view 的 input 接口里即可，父 view model / presenter / interactor 是不知道父 view 提供的这几个接口是通过子 view 实现的。</p>
<p>如果父模块需要调用子模块的业务接口，或接收子模块的数据或业务事件，并且不想影响 view 的接口，可以把子 view model / presenter / interactor 作为父 view model / presenter / interactor 的一个 service，在引入子模块时，注入到父 view model / presenter / interactor，从而绕过 view 层。这样子模块和父模块就能通过 service 的形式进行通信了，而这时，父模块也不知道这个 service 是来自子模块里的。</p>
<p>在这样的设计下，子模块和父模块是不知道彼此的存在的，只是通过接口进行交互。好处是父 view 如果想要更换为另一个相同功能的子 view 控件，就只需要在父 view 里修改，不会影响其他的 view model / presenter / interactor。</p>
<p>父模块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> viewModel: <span class="type">EditorViewModel</span>!</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addTextView</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> textViewController = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableView</span>&lt;<span class="type">TextViewInput</span>&gt;()) &#123; (destination) <span class="keyword">in</span></div><div class="line">            <span class="comment">// 设置模块间交互</span></div><div class="line">            <span class="comment">// 原本父 view 是无法接触到子模块的 view model / presenter / interactor</span></div><div class="line">            <span class="comment">// 此时子模块是把这些内部组件作为业务 input 开放给了外部</span></div><div class="line">            <span class="keyword">self</span>.viewModel.textService = destination.viewModel</div><div class="line">            destination.viewModel.output = <span class="keyword">self</span>.viewModel</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        addChildViewController(textViewController)</div><div class="line">        view.addSubview(textViewController.view)</div><div class="line">        textViewController.didMove(toParentViewController: <span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewController</span>: <span class="title">UIViewController</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;EditorViewModel&gt; viewModel;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewController</span></span></div><div class="line">  </div><div class="line">- (<span class="keyword">void</span>)addTextView &#123;</div><div class="line">    <span class="built_in">UIViewController</span> *textViewController = [ZIKRouterToView(TextViewInput) makeDestinationWithPreparation:^(<span class="keyword">id</span>&lt;TextViewInput&gt; destination) &#123;</div><div class="line">        <span class="comment">// 设置模块间交互</span></div><div class="line">        <span class="comment">// 原本父 view 是无法接触到子模块的 view model / presenter / interactor</span></div><div class="line">        <span class="comment">// 此时子模块是把这些内部组件作为业务 input 开放给了外部        </span></div><div class="line">        <span class="keyword">self</span>.viewModel.textService = destination.viewModel;</div><div class="line">        destination.viewModel.output = <span class="keyword">self</span>.viewModel;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [<span class="keyword">self</span> addChildViewController:textViewController];</div><div class="line">    [<span class="keyword">self</span>.view addSubview: textViewController.view];</div><div class="line">    [textViewController didMoveToParentViewController: <span class="keyword">self</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>子模块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TextViewInput</span> </span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">TextViewModuleOutput</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">    <span class="keyword">var</span> viewModel: <span class="type">TextViewModel</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextViewController</span>: <span class="title">UIViewController</span>, <span class="title">TextViewInput</span> </span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">TextViewModuleOutput</span>?</div><div class="line">    <span class="keyword">var</span> viewModel: <span class="type">TextViewModel</span>!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">TextViewInput</span> &lt;<span class="title">ZIKViewRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;TextViewModuleOutput&gt; output;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;TextViewModel&gt; viewModel;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TextViewController</span>: <span class="title">UIViewController</span> &lt;<span class="title">TextViewInput</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;TextViewModuleOutput&gt; output;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;TextViewModel&gt; viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="Output-的适配"><a href="#Output-的适配" class="headerlink" title="Output 的适配"></a>Output 的适配</h3><p>在使用 output 时，模块适配会带来一定麻烦。</p>
<p>例如这样一对 required-provided protocol：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RequiredEditorViewInput</span> </span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">RequiredEditorViewOutput</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProvidedEditorViewInput</span> </span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">ProvidedEditorViewOutput</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RequiredEditorViewInput</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;RequiredEditorViewOutput&gt; output;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProvidedEditorViewInput</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;ProvidedEditorViewOutput&gt; output;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>由于 output 的实现者不是固定的，因此无法让所有的 output 类都同时适配<code>RequiredEditorViewOutput</code>和<code>ProvidedEditorViewOutput</code>。此时建议直接使用对应的 protocol，不使用 required-provided 模式。</p>
<p>如果你仍然想要使用 required-provided 模式，那就需要用工厂模式来传递 output ，在内部用 proxy 进行适配。</p>
<p>实际模块的 router：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProvidedEditorViewModuleInput</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> makeDestinationWith(<span class="number">_</span> output: <span class="type">ProvidedEditorViewOutput</span>?) -&gt; <span class="type">ProvidedEditorViewInput</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProvidedEditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewController</span>, <span class="title">ViewRouteConfig</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">registerRoutableDestination</span>() </span>&#123;</div><div class="line">        register(<span class="type">RoutableViewModule</span>&lt;<span class="type">ProvidedEditorViewModuleInput</span>&gt;())</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultRouteConfiguration</span>() -&gt; <span class="title">ViewRouteConfig</span> </span>&#123;</div><div class="line">        <span class="keyword">let</span> config = <span class="type">ViewMakeableConfiguration</span>&lt;<span class="type">ProvidedViewInput</span>, (<span class="type">ProvidedEditorViewOutput</span>?) -&gt; <span class="type">ProvidedViewInput</span>?&gt;(&#123; <span class="number">_</span> <span class="keyword">in</span>&#125;)</div><div class="line">        config.makeDestinationWith = &#123; [<span class="keyword">unowned</span> config] output <span class="keyword">in</span></div><div class="line">            <span class="comment">// 设置 output</span></div><div class="line">            <span class="keyword">let</span> viewModel = <span class="type">EditorViewModel</span>(output: output)</div><div class="line">            config.makedDestination = <span class="type">EditorViewController</span>(viewModel: viewModel)</div><div class="line">            <span class="keyword">return</span> config.makedDestination</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> config</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">EditorViewController</span>? &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> config = configuration <span class="keyword">as</span>? <span class="type">ViewMakeableConfiguration</span>&lt;<span class="type">ProvidedViewInput</span>, (<span class="type">ProvidedEditorViewOutput</span>?) &#123;</div><div class="line">            <span class="keyword">return</span> config.makedDestination</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProvidedEditorViewModuleInput</span> &lt;<span class="title">ZIKViewModuleRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;ProvidedEditorViewInput&gt; (makeDestinationWith)(<span class="keyword">id</span>&lt;ProvidedEditorViewOutput&gt; output);</div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ProvidedEditorViewRouter</span>: <span class="title">ZIKViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ProvidedEditorViewRouter</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)registerRoutableDestination &#123;</div><div class="line">    [<span class="keyword">self</span> registerModuleProtocol:ZIKRoutable(ProvidedEditorViewModuleInput)];  </div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (ZIKViewMakeableConfiguration *)defaultRouteConfiguration &#123;</div><div class="line">    ZIKViewMakeableConfiguration *config = [ZIKViewMakeableConfiguration new];</div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(config) weakConfig = config;</div><div class="line">    </div><div class="line">    config.makeDestinationWith = <span class="keyword">id</span> ^(<span class="keyword">id</span>&lt;ProvidedEditorViewOutput&gt; output) &#123;</div><div class="line">        <span class="comment">// 设置 output</span></div><div class="line">        EditorViewModel *viewModel = [[EditorViewModel alloc] initWithOutput:output];</div><div class="line">        weakConfig.makedDestination = [[EditorViewController alloc] initWithViewModel:viewModel];</div><div class="line">        <span class="keyword">return</span> weakConfig.makedDestination;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> config;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;PersonType&gt;)destinationWithConfiguration:(ZIKServiceMakeableConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">return</span> configuration.makedDestination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>适配代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RequiredEditorViewModuleInput</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> makeDestinationWith(<span class="number">_</span> output: <span class="type">RequiredEditorViewOutput</span>?) -&gt; <span class="type">RequiredEditorViewInput</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 用于适配的 required router</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequiredEditorViewRouter</span>: <span class="title">ProvidedEditorViewRouter</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">registerRoutableDestination</span>() </span>&#123;</div><div class="line">        register(<span class="type">RoutableViewModule</span>&lt;<span class="type">RequiredEditorViewModuleInput</span>&gt;())</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 兼容 configuration</span></div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultRouteConfiguration</span>() -&gt; <span class="title">PerformRouteConfig</span> </span>&#123;</div><div class="line">        <span class="keyword">let</span> config = <span class="keyword">super</span>.defaultRouteConfiguration()</div><div class="line">        <span class="keyword">let</span> makeDestinationWith = config.makeDestinationWith</div><div class="line">        </div><div class="line">        config.makeDestinationWith = &#123; requiredOutput <span class="keyword">in</span></div><div class="line">            <span class="comment">// proxy 负责把 RequiredEditorViewOutput 转为 ProvidedEditorViewOutput</span></div><div class="line">            <span class="keyword">let</span> providedOutput = <span class="type">EditorOutputProxy</span>(forwarding: requiredOutput)</div><div class="line">            <span class="keyword">return</span> makeDestinationWith(providedOutput)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> config</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorOutputProxy</span>: <span class="title">ProvidedEditorViewOutput</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> forwarding: <span class="type">RequiredEditorViewOutput</span></div><div class="line">    <span class="comment">// 实现 ProvidedEditorViewOutput，转发给 forwarding</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RequiredEditorViewModuleInput</span> &lt;<span class="title">ZIKViewModuleRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;RequiredEditorViewInput&gt; (makeDestinationWith)(<span class="keyword">id</span>&lt;RequiredEditorViewOutput&gt; output);</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 用于适配的 required router</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RequiredEditorViewRouter</span>: <span class="title">ProvidedEditorViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RequiredEditorViewRouter</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)registerRoutableDestination &#123;</div><div class="line">    [<span class="keyword">self</span> registerModuleProtocol:ZIKRoutable(RequiredEditorViewModuleInput)];  </div><div class="line">&#125;</div><div class="line"><span class="comment">// 兼容 configuration</span></div><div class="line">+ (ZIKViewMakeableConfiguration *)defaultRouteConfiguration &#123;</div><div class="line">    ZIKViewMakeableConfiguration *config = [<span class="keyword">super</span> defaultRouteConfiguration];</div><div class="line">    <span class="keyword">id</span>&lt;ProvidedEditorViewInput&gt;(^makeDestinationWith)(<span class="keyword">id</span>&lt;ProvidedEditorViewOutput&gt;) = config.makeDestinationWith;</div><div class="line">    </div><div class="line">    config.makeDestinationWith = <span class="keyword">id</span> ^(<span class="keyword">id</span>&lt;RequiredEditorViewOutput&gt; requiredOutput) &#123;</div><div class="line">        <span class="comment">// proxy 负责把 RequiredEditorViewOutput 转为 ProvidedEditorViewOutput</span></div><div class="line">        EditorOutputProxy *providedOutput = [[EditorOutputProxy alloc] initWithForwarding: requiredOutput];</div><div class="line">        <span class="keyword">return</span> makeDestinationWith(providedOutput);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> config;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;PersonType&gt;)destinationWithConfiguration:(ZIKServiceMakeableConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">return</span> configuration.makedDestination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="comment">// 实现 ProvidedEditorViewOutput，转发给 forwarding</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorOutputProxy</span>: <span class="title">NSProxy</span> &lt;<span class="title">ProvidedEditorViewOutput</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> forwarding;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorOutputProxy</span></span></div><div class="line">  </div><div class="line">- (<span class="keyword">instancetype</span>)initWithForwarding:(<span class="keyword">id</span>)forwarding &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">        _forwarding = forwarding;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.forwarding respondsToSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)protocol &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.forwarding conformsToProtocol:protocol];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.forwarding;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>可以看到，output 的适配有些繁琐。因此除非你的模块是通用模块，有实际的解耦需求，否则直接使用 provided protocol 即可。</p>
<h2 id="功能扩展"><a href="#功能扩展" class="headerlink" title="功能扩展"></a>功能扩展</h2><p>总结完使用接口进行模块解耦和依赖管理的方法，我们可以进一步对 router 进行扩展了。上面使用 <code>makeDestination</code> 创建模块是最基本的功能，使用 router 子类后，我们可以进行许多有用的功能扩展，这里给出一些示范。</p>
<h3 id="自动注册"><a href="#自动注册" class="headerlink" title="自动注册"></a>自动注册</h3><p>编写 router 代码时，需要注册 router 和 protocol 。在 OC 中可以在 +load 方法中注册，但是 Swift 里已经不能使用 +load 方法，而且分散在 +load 中的注册代码也不好管理。BeeHive 中通过宏定义和<code>__attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveServices&quot;&quot;&quot;)))</code>，把注册信息添加到了 mach-O 中的自定义区域，然后在启动时读取并自动注册，可惜这种方式在 Swift 中也无法使用了。</p>
<p>我们可以把注册代码写在 router 的<code>+registerRoutableDestination</code>方法里，然后逐个调用每个 router 类的<code>+registerRoutableDestination</code>方法即可。还可以更进一步，用 runtime 技术遍历 mach-O 中的<code>__DATA,__objc_classlist</code>区域的类列表，获取所有的 router 类，自动调用所有的<code>+registerRoutableDestination</code>方法。</p>
<p>把注册代码统一管理之后，如果不想使用自动注册，也能随时切换为手动注册。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span> </span>&#123;</div><div class="line">  </div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">registerRoutableDestination</span>() </span>&#123;</div><div class="line">        registerView(<span class="type">EditorViewController</span>.<span class="keyword">self</span>)</div><div class="line">        register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;())</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewRouter</span> : <span class="title">ZIKViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewRouter</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)registerRoutableDestination &#123;</div><div class="line">    [<span class="keyword">self</span> registerView:[EditorViewController <span class="keyword">class</span>]];</div><div class="line">    [<span class="keyword">self</span> registerViewProtocol:ZIKRoutable(EditorViewProtocol)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="封装界面跳转"><a href="#封装界面跳转" class="headerlink" title="封装界面跳转"></a>封装界面跳转</h3><p>iOS 中模块间耦合的原因之一，就是界面跳转的逻辑是通过 UIViewController 进行的，跳转功能被限制在了 view controller 上，导致数据流常常都绕不开 view 层。要想更好地管理跳转逻辑，就需要进行封装。</p>
<p>封装界面跳转可以屏蔽 UIKit 的细节，此时界面跳转的代码就可以放在非 view 层（例如 presenter、view model、interactor、service），并且能够跨平台，也能轻易地通过配置切换跳转方式。</p>
<p>如果是普通的模块，就用<code>ZIKServiceRouter</code>，而如果是界面模块，例如 <code>UIViewController</code> 和 <code>UIView</code>，就可以用<code>ZIKViewRouter</code>，在其中封装了界面跳转功能。</p>
<p>封装界面跳转后，使用方式如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//直接跳转到 editor 界面</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showEditor</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="type">Router</span>.perform(to: <span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;(), path: .push(from: <span class="keyword">self</span>))</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">//跳转到 editor 界面，跳转前用 protocol 配置界面</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">prepareAndShowEditor</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="type">Router</span>.perform(</div><div class="line">            to: <span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;(),</div><div class="line">            path: .push(from: <span class="keyword">self</span>),</div><div class="line">            preparation: &#123; destination <span class="keyword">in</span></div><div class="line">                <span class="comment">// 跳转前进行配置</span></div><div class="line">                <span class="comment">// destination 自动推断为 EditorViewProtocol</span></div><div class="line">            &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)showEditor &#123;</div><div class="line">    <span class="comment">//直接跳转到 editor 界面</span></div><div class="line">    [ZIKRouterToView(EditorViewProtocol) performPath:ZIKViewRoutePath.pushFrom(<span class="keyword">self</span>)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)prepareAndShowEditor &#123;</div><div class="line">    <span class="comment">//跳转到 editor 界面，跳转前用 protocol 配置界面</span></div><div class="line">    [ZIKRouterToView(EditorViewProtocol) </div><div class="line">        performPath:ZIKViewRoutePath.pushFrom(<span class="keyword">self</span>)</div><div class="line">        preparation:^(<span class="keyword">id</span>&lt;EditorViewProtocol&gt; destination) &#123;</div><div class="line">            <span class="comment">// 跳转前进行配置</span></div><div class="line">            <span class="comment">// destination 自动推断为 EditorViewProtocol</span></div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>可以用 <code>ViewRoutePath</code> 一键切换不同的跳转方式:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ViewRoutePath</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> push(from: <span class="type">UIViewController</span>)</div><div class="line">    <span class="keyword">case</span> presentModally(from: <span class="type">UIViewController</span>)</div><div class="line">    <span class="keyword">case</span> presentAsPopover(from: <span class="type">UIViewController</span>, configure: <span class="type">ZIKViewRoutePopoverConfigure</span>)</div><div class="line">    <span class="keyword">case</span> performSegue(from: <span class="type">UIViewController</span>, identifier: <span class="type">String</span>, sender: <span class="type">Any</span>?)</div><div class="line">    <span class="keyword">case</span> show(from: <span class="type">UIViewController</span>)</div><div class="line">    <span class="keyword">case</span> showDetail(from: <span class="type">UIViewController</span>)</div><div class="line">    <span class="keyword">case</span> addAsChildViewController(from: <span class="type">UIViewController</span>, addingChildViewHandler: (<span class="type">UIViewController</span>, @escaping () -&gt; <span class="type">Void</span>) -&gt; <span class="type">Void</span>)</div><div class="line">    <span class="keyword">case</span> addAsSubview(from: <span class="type">UIView</span>)</div><div class="line">    <span class="keyword">case</span> custom(from: <span class="type">ZIKViewRouteSource</span>?)</div><div class="line">    <span class="keyword">case</span> makeDestination</div><div class="line">    <span class="keyword">case</span> extensible(path: <span class="type">ZIKViewRoutePath</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而且在界面跳转后，还可以根据跳转时的跳转方式，一键回退界面，无需再手动区分 dismiss、pop 等各种情况：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> router: <span class="type">DestinationViewRouter</span>&lt;<span class="type">EditorViewProtocol</span>&gt;?</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showEditor</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// 持有 router</span></div><div class="line">        router = <span class="type">Router</span>.perform(to: <span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;(), path: .push(from: <span class="keyword">self</span>))</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Router 会对 editor view controller 执行 pop 操作，移除界面</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeEditor</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> router = router, router.canRemove <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        router.removeRoute()</div><div class="line">        router = <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestViewController</span>()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) ZIKDestinationViewRouter(<span class="keyword">id</span>&lt;EditorViewProtocol&gt;) *router;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)showEditor &#123;</div><div class="line">    <span class="comment">// 持有 router</span></div><div class="line">    <span class="keyword">self</span>.router = [ZIKRouterToView(EditorViewProtocol) performPath:ZIKViewRoutePath.pushFrom(<span class="keyword">self</span>)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Router 会对 editor view controller 执行 pop 操作，移除界面</span></div><div class="line">- (<span class="keyword">void</span>)removeEditor &#123;</div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.router canRemove]) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.router removeRoute];</div><div class="line">    <span class="keyword">self</span>.router = <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="自定义跳转"><a href="#自定义跳转" class="headerlink" title="自定义跳转"></a>自定义跳转</h3><p>有些界面的跳转方式很特殊，例如 tabbar 上的界面，需要通过切换 tabbar item 来进行。也有的界面有自定义的跳转动画，此时可以在 router 子类中重写对应方法，进行自定义跳转。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewController</span>, <span class="title">ViewRouteConfig</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">Any</span>? &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">EditorViewController</span>()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">canPerformCustomRoute</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">performCustomRoute</span><span class="params">(onDestination destination: EditorViewController, fromSource source: Any?, configuration: ViewRouteConfig)</span></span> &#123;</div><div class="line">        beginPerformRoute()</div><div class="line">        <span class="comment">// 自定义跳转</span></div><div class="line">        <span class="type">CustomAnimator</span>.transition(from: source, to: destination) &#123;</div><div class="line">            <span class="keyword">self</span>.endPerformRouteWithSuccess()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">canRemoveCustomRoute</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">removeCustomRoute</span><span class="params">(onDestination destination: EditorViewController, fromSource source: Any?, removeConfiguration: ViewRemoveConfig, configuration: ViewRouteConfig)</span></span> &#123;</div><div class="line">        beginRemoveRoute(fromSource: source)</div><div class="line">        <span class="comment">// 移除自定义跳转</span></div><div class="line">        <span class="type">CustomAnimator</span>.dismiss(destination) &#123;</div><div class="line">            <span class="keyword">self</span>.endRemoveRouteWithSuccess(onDestination: destination, fromSource: source)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">supportedRouteTypes</span>() -&gt; <span class="title">ZIKViewRouteTypeMask</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> [.custom, .viewControllerDefault]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewRouter</span> : <span class="title">ZIKViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewRouter</span></span></div><div class="line"></div><div class="line">- (EditorViewController *)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">return</span> [[EditorViewController alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)canPerformCustomRoute &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)performCustomRouteOnDestination:(<span class="keyword">id</span>)destination fromSource:(<span class="built_in">UIViewController</span> *)source configuration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    [<span class="keyword">self</span> beginPerformRoute];</div><div class="line">    <span class="comment">// 自定义跳转</span></div><div class="line">    [CustomAnimator transitionFrom:source to:destination completion:^&#123;</div><div class="line">        [<span class="keyword">self</span> endPerformRouteWithSuccess];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)canRemoveCustomRoute &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeCustomRouteOnDestination:(<span class="keyword">id</span>)destination fromSource:(<span class="built_in">UIViewController</span> *)source removeConfiguration:(ZIKViewRemoveConfiguration *)removeConfiguration configuration:(__kindof ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    [<span class="keyword">self</span> beginRemoveRouteFromSource:source];</div><div class="line">    <span class="comment">// 移除自定义跳转</span></div><div class="line">    [CustomAnimator dismiss:destination completion:^&#123;</div><div class="line">        [<span class="keyword">self</span> endRemoveRouteWithSuccessOnDestination:destination fromSource:source];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (ZIKViewRouteTypeMask)supportedRouteTypes &#123;</div><div class="line">    <span class="keyword">return</span> ZIKViewRouteTypeMaskCustom|ZIKViewRouteTypeMaskViewControllerDefault;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="支持-storyboard"><a href="#支持-storyboard" class="headerlink" title="支持 storyboard"></a>支持 storyboard</h3><p>很多项目使用了 storyboard，在进行模块化时，肯定不能要求所有使用 storyboard 的模块都改为使用代码。因此我们可以 hook 一些 storyboard 相关的方法，例如<code>-prepareSegue:sender:</code>，在其中调用<code>prepareDestination:configuring:</code>即可。</p>
<h3 id="URL-路由-1"><a href="#URL-路由-1" class="headerlink" title="URL 路由"></a>URL 路由</h3><p>虽然之前列出了 URL 路由的许多缺点，但是如果你的模块需要从 h5 界面调用，例如电商 app 需要实现跨平台的动态路由规则，那么 URL 路由就是最佳的方案。</p>
<p>但是我们并不想为了实现 URL 路由，使用另一套框架再重新封装一次模块。只需要在 router 上扩展 URL 路由的功能，即可同时用接口和 URL 管理模块。</p>
<p>你可以给 router 注册 url：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewProtocol</span>, <span class="title">ViewRouteConfig</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">registerRoutableDestination</span>() </span>&#123;</div><div class="line">        <span class="comment">// 注册 url</span></div><div class="line">        registerURLPattern(<span class="string">"app://editor/:title"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewRouter</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)registerRoutableDestination &#123;</div><div class="line">    <span class="comment">// 注册 url</span></div><div class="line">    [<span class="keyword">self</span> registerURLPattern:<span class="string">@"app://editor/:title"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>之后就可以用相应的 url 获取 router:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">ZIKAnyViewRouter</span>.performURL(<span class="string">"app://editor/test_note"</span>, path: .push(from: <span class="keyword">self</span>))</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ZIKAnyViewRouter performURL:<span class="string">@"app://editor/test_note"</span> path:ZIKViewRoutePath.pushFrom(<span class="keyword">self</span>)];</div></pre></td></tr></table></figure><br><br></details>

<p>以及处理 URL Scheme:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:])</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">let</span> urlString = url.absoluteString</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = <span class="type">ZIKAnyViewRouter</span>.performURL(urlString, fromSource: <span class="keyword">self</span>.rootViewController) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = <span class="type">ZIKAnyServiceRouter</span>.performURL(urlString) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)app openURL:(<span class="built_in">NSURL</span> *)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">UIApplicationOpenURLOptionsKey</span>,<span class="keyword">id</span>&gt; *)options &#123;</div><div class="line">    <span class="keyword">if</span> ([ZIKAnyViewRouter performURL:urlString fromSource:<span class="keyword">self</span>.rootViewController]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([ZIKAnyServiceRouter performURL:urlString]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br></details>

<p>每个 router 子类还能各自对 url 进行进一步处理，例如处理 url 中的参数、通过 url 执行对应方法、执行路由后发送返回值给调用者等。</p>
<p>每个项目对 URL 路由的需求都不一样，基于 ZIKRouter 强大的可扩展性，你也可以按照项目需求实现自己的 URL 路由规则。</p>
<h3 id="用-router-对象代替-router-子类"><a href="#用-router-对象代替-router-子类" class="headerlink" title="用 router 对象代替 router 子类"></a>用 router 对象代替 router 子类</h3><p>除了创建 router 子类，也可以使用通用的 router 实例对象，在每个对象的 block 属性中提供和 router 子类一样的功能，因此不必担心类过多的问题。原理就和用泛型 configuration 代替 configuration 子类一样。</p>
<p> ZIKViewRoute 对象通过 block 属性实现子类重写的效果，代码可以用链式调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="type">ZIKViewRoute</span>&lt;<span class="type">EditorViewController</span>, <span class="type">ViewRouteConfig</span>&gt;</div><div class="line">.make(withDestination: <span class="type">EditorViewController</span>.<span class="keyword">self</span>, makeDestination: (&#123; (config, router) -&gt; <span class="type">EditorViewController</span>? <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> <span class="type">EditorViewController</span>()</div><div class="line">&#125;))</div><div class="line">.prepareDestination(&#123; (destination, config, router) <span class="keyword">in</span></div><div class="line"></div><div class="line">&#125;).didFinishPrepareDestination(&#123; (destination, config, router) <span class="keyword">in</span></div><div class="line"></div><div class="line">&#125;)</div><div class="line">.register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;())</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[ZIKDestinationViewRoute(<span class="keyword">id</span>&lt;EditorViewProtocol&gt;) </div><div class="line"> makeRouteWithDestination:[ZIKInfoViewController <span class="keyword">class</span>] </div><div class="line"> makeDestination:^<span class="keyword">id</span>&lt;EditorViewProtocol&gt; _Nullable(ZIKViewRouteConfig *config, ZIKRouter *router) &#123;</div><div class="line">    <span class="keyword">return</span> [[EditorViewController alloc] init];</div><div class="line">&#125;]</div><div class="line">.prepareDestination(^(<span class="keyword">id</span>&lt;EditorViewProtocol&gt; destination, ZIKViewRouteConfig *config, ZIKViewRouter *router) &#123;</div><div class="line"></div><div class="line">&#125;)</div><div class="line">.didFinishPrepareDestination(^(<span class="keyword">id</span>&lt;EditorViewProtocol&gt; destination, ZIKViewRouteConfig *config, ZIKViewRouter *router) &#123;</div><div class="line"></div><div class="line">&#125;)</div><div class="line">.registerDestinationProtocol(ZIKRoutable(EditorViewProtocol));</div></pre></td></tr></table></figure><br><br></details>

<h3 id="简化-router-实现"><a href="#简化-router-实现" class="headerlink" title="简化 router 实现"></a>简化 router 实现</h3><p>基于 ZIKViewRoute 对象实现的 router，可以进一步简化 router 的实现代码。</p>
<p>如果你的类很简单，并不需要用到 router 子类，直接一行代码注册类即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">ZIKAnyViewRouter</span>.register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;(), forMakingView: <span class="type">EditorViewController</span>.<span class="keyword">self</span>)</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ZIKViewRouter registerViewProtocol:ZIKRoutable(EditorViewProtocol) forMakingView:[EditorViewController <span class="keyword">class</span>]];</div></pre></td></tr></table></figure><br><br></details>

<p>或者用 block 自定义创建对象的方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">ZIKAnyViewRouter</span>.register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;(), </div><div class="line">                 forMakingView: <span class="type">EditorViewController</span>.<span class="keyword">self</span>) &#123; (config, router) -&gt; <span class="type">EditorViewProtocol</span>? <span class="keyword">in</span></div><div class="line">                     <span class="keyword">return</span> <span class="type">EditorViewController</span>()</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[ZIKViewRouter</div><div class="line">    registerViewProtocol:ZIKRoutable(EditorViewProtocol)</div><div class="line">    forMakingView:[EditorViewController <span class="keyword">class</span>]</div><div class="line">    making:^<span class="keyword">id</span> _Nullable(ZIKViewRouteConfiguration *config, ZIKViewRouter *router) &#123;</div><div class="line">        <span class="keyword">return</span> [[EditorViewController alloc] init];</div><div class="line"> &#125;];</div></pre></td></tr></table></figure><br><br></details>

<p>或者指定用 C 函数创建对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function makeEditorViewController(config: <span class="type">ViewRouteConfig</span>) -&gt; <span class="type">EditorViewController</span>? &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">EditorViewController</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">ZIKAnyViewRouter</span>.register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;(), </div><div class="line">                 forMakingView: <span class="type">EditorViewController</span>.<span class="keyword">self</span>, making: makeEditorViewController)</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span>&lt;EditorViewController&gt; makeEditorViewController(ZIKViewRouteConfiguration *config) &#123;</div><div class="line">    <span class="keyword">return</span> [[EditorViewController alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">[ZIKViewRouter</div><div class="line">    registerViewProtocol:ZIKRoutable(EditorViewProtocol)</div><div class="line">    forMakingView:[EditorViewController <span class="keyword">class</span>]</div><div class="line">    factory:makeEditorViewController];</div></pre></td></tr></table></figure><br><br></details>

<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>有时候模块需要处理一些系统事件或者 app 的自定义事件，此时可以让 router 子类实现，再进行遍历分发。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeServiceRouter</span>: <span class="title">ZIKServiceRouter</span> </span>&#123;</div><div class="line">    <span class="meta">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">applicationDidEnterBackground</span>(<span class="title">_</span> <span class="title">application</span>: <span class="title">UIApplication</span>) </span>&#123;</div><div class="line">        <span class="comment">// handle applicationDidEnterBackground event</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">NSObject</span>, <span class="title">NSApplicationDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">applicationDidEnterBackground</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="type">Router</span>.enumerateAllViewRouters &#123; (routerType) <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> routerType.responds(to: #selector(applicationDidEnterBackground(<span class="number">_</span>:))) &#123;</div><div class="line">                routerType.perform(#selector(applicationDidEnterBackground(<span class="number">_</span>:)), with: application)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="type">Router</span>.enumerateAllServiceRouters &#123; (routerType) <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> routerType.responds(to: #selector(applicationDidEnterBackground(<span class="number">_</span>:))) &#123;</div><div class="line">                routerType.perform(#selector(applicationDidEnterBackground(<span class="number">_</span>:)), with: application)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SomeServiceRouter</span> : <span class="title">ZIKServiceRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SomeServiceRouter</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</div><div class="line">    <span class="comment">// handle applicationDidEnterBackground event</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</div><div class="line">    </div><div class="line">    [ZIKAnyViewRouter enumerateAllViewRouters:^(Class routerClass) &#123;</div><div class="line">        <span class="keyword">if</span> ([routerClass respondsToSelector:<span class="keyword">@selector</span>(applicationDidEnterBackground:)]) &#123;</div><div class="line">            [routerClass applicationDidEnterBackground:application];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    [ZIKAnyServiceRouter enumerateAllServiceRouters:^(Class routerClass) &#123;</div><div class="line">        <span class="keyword">if</span> ([routerClass respondsToSelector:<span class="keyword">@selector</span>(applicationDidEnterBackground:)]) &#123;</div><div class="line">            [routerClass applicationDidEnterBackground:application];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>借助于使用接口管理依赖的方案，我们在对模块进行单元测试时，可以自由配置 mock 依赖，而且无需 hook 模块内部的代码。</p>
<p>例如这样一个依赖于网络模块的登陆模块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 登录模块</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(account: String, password: String, completion: <span class="params">(Result&lt;LoginError&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        <span class="comment">// 内部使用 RequiredNetServiceInput 进行网络访问</span></div><div class="line">        <span class="keyword">let</span> netService = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableService</span>&lt;<span class="type">RequiredNetServiceInput</span></div><div class="line">        &gt;())</div><div class="line">        <span class="keyword">let</span> request = makeLoginRequest(account: account, password: password)</div><div class="line">        netService?.<span class="type">POST</span>(request: request, completion: completion)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 声明依赖</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RoutableService</span> <span class="title">where</span> <span class="title">Protocol</span> == <span class="title">RequiredNetServiceInput</span> </span>&#123;</div><div class="line">    <span class="keyword">init</span>() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 登录模块</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LoginService</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LoginService</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)loginWithAccount:(<span class="built_in">NSString</span> *)account password:(<span class="built_in">NSString</span> *)password  completion:(<span class="keyword">void</span>(^)(Result *result))completion &#123;</div><div class="line">    <span class="comment">// 内部使用 RequiredNetServiceInput 进行网络访问</span></div><div class="line">    <span class="keyword">id</span>&lt;RequiredNetServiceInput&gt; netService = [ZIKRouterToService(RequiredNetServiceInput) makeDestination];</div><div class="line">    Request *request = makeLoginRequest(account, password);</div><div class="line">    [netService POSTRequest:request completion: completion];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="comment">// 声明依赖</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RequiredNetServiceInput</span> &lt;<span class="title">ZIKServiceRoutable</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)POSTRequest:(Request *)request completion:(<span class="keyword">void</span>(^)(Result *result))completion;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>在编写单元测试时，不需要引入真实的网络模块，可以提供一个自定义的 mock 网络模块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockNetService</span>: <span class="title">RequiredNetServiceInput</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">POST</span><span class="params">(request: Request, completion: <span class="params">(Result&lt;NetError&gt;)</span></span></span> &#123;</div><div class="line">        completion(.success)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册 mock 依赖</span></div><div class="line"><span class="type">ZIKAnyServiceRouter</span>.register(<span class="type">RoutableService</span>&lt;<span class="type">RequiredNetServiceInput</span>&gt;(), </div><div class="line">                 forMakingService: <span class="type">MockNetService</span>.<span class="keyword">self</span>) &#123; (config, router) -&gt; <span class="type">EditorViewProtocol</span>? <span class="keyword">in</span></div><div class="line">                     <span class="keyword">return</span> <span class="type">MockNetService</span>()</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MockNetService</span> : <span class="title">NSObject</span> &lt;<span class="title">RequiredNetServiceInput</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MockNetService</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)POSTRequest:(Request *)request completion:(<span class="keyword">void</span>(^)(Result *result))completion &#123;</div><div class="line">    completion([Result success]);</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册 mock 依赖</span></div><div class="line">[ZIKServiceRouter registerServiceProtocol:ZIKRoutable(EditorViewInput) forMakingService:[MockNetService <span class="keyword">class</span>]];</div></pre></td></tr></table></figure><br><br></details>

<p>对于那些没有接口交互的外部依赖，例如只是简单的跳转到对应界面，则只需注册一个空白的 proxy。</p>
<p>单元测试代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginServiceTests</span>: <span class="title">XCTestCase</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testLoginSuccess</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> expectation = expectation(description: <span class="string">"end login"</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> loginService = <span class="type">LoginService</span>()</div><div class="line">        loginService.login(account: <span class="string">"account"</span>, password: <span class="string">"pwd"</span>) &#123; result <span class="keyword">in</span></div><div class="line">            expectation.fulfill()</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        waitForExpectations(timeout: <span class="number">5</span>, handler: &#123; <span class="keyword">if</span> <span class="keyword">let</span> error = $<span class="number">0</span> &#123;<span class="built_in">print</span>(error)&#125;&#125;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LoginServiceTests</span> : <span class="title">XCTestCase</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LoginServiceTests</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)testLoginSuccess &#123;</div><div class="line">    <span class="built_in">XCTestExpectation</span> *expectation = [<span class="keyword">self</span> expectationWithDescription:<span class="string">@"end login"</span>];</div><div class="line">    </div><div class="line">    [[LoginService new] loginWithAccount:<span class="string">@""</span> password:<span class="string">@""</span> completion:^(Result *result) &#123;</div><div class="line">        [expectation fulfill];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> waitForExpectationsWithTimeout:<span class="number">5</span> handler:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">        !error? : <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>使用接口管理依赖，可以更容易 mock，剥除外部依赖对测试的影响，让单元测试更稳定。</p>
<h2 id="接口版本管理"><a href="#接口版本管理" class="headerlink" title="接口版本管理"></a>接口版本管理</h2><p>使用接口管理模块时，还有一个问题需要注意。接口是会随着模块更新而变化的，这个接口已经被很多外部使用了，要如何减少接口变化产生的影响？</p>
<p>此时需要区分新接口和旧接口，区分版本，推出新接口的同时，保留旧接口，并将旧接口标记为废弃。这样使用者就可以暂时使用旧接口，渐进式地修改代码。</p>
<p>这部分可以参考 Swift 和 OC 中的版本管理宏。</p>
<p>接口废弃，可以暂时使用，建议尽快使用新接口代替：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift</span></div><div class="line"><span class="meta">@available</span>(iOS, deprecated: <span class="number">8.0</span>, message: <span class="string">"Use new interface instead"</span>)</div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Objective-C</span></div><div class="line">API_DEPRECATED_WITH_REPLACEMENT(<span class="string">"performPath:configuring:"</span>, ios(<span class="number">7.0</span>, <span class="number">7.0</span>));</div></pre></td></tr></table></figure>
<p>接口已经无效：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift</span></div><div class="line"><span class="meta">@available</span>(iOS, unavailable)</div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Objective-C</span></div><div class="line"><span class="built_in">NS_UNAVAILABLE</span></div></pre></td></tr></table></figure>
<h2 id="最终形态"><a href="#最终形态" class="headerlink" title="最终形态"></a>最终形态</h2><p>最后，一个 router 的最终形态就是下面这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewController</span>, <span class="title">ViewRouteConfig</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">registerRoutableDestination</span>() </span>&#123;</div><div class="line">        registerView(<span class="type">EditorViewController</span>.<span class="keyword">self</span>)</div><div class="line">        register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;())</div><div class="line">        registerURLPattern(<span class="string">"app://editor/:title"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">processUserInfo</span><span class="params">(<span class="number">_</span> userInfo: [AnyHashable : Any] = [:], from url: URL)</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> title = userInfo[<span class="string">"title"</span>]</div><div class="line">        <span class="comment">// 处理 url 中的参数</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 子类重写，创建模块</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">Any</span>? &#123;</div><div class="line">        <span class="keyword">let</span> destination = <span class="type">EditorViewController</span>()</div><div class="line">        <span class="keyword">return</span> destination</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 配置模块，注入静态依赖</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareDestination</span><span class="params">(<span class="number">_</span> destination: EditorViewController, configuration: ViewRouteConfig)</span></span> &#123;</div><div class="line">        <span class="comment">// 注入 service 依赖</span></div><div class="line">        destination.storageService = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableService</span>&lt;<span class="type">EditorStorageServiceInput</span>&gt;())</div><div class="line">        <span class="comment">// 其他配置</span></div><div class="line">        <span class="comment">// 处理来自 url 的参数</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> title = configuration.userInfo[<span class="string">"title"</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</div><div class="line">            destination.title = title</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            destination.title = <span class="string">"默认标题"</span></div><div class="line">        &#125;        </div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 事件处理</span></div><div class="line">    <span class="meta">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">applicationDidEnterBackground</span>(<span class="title">_</span> <span class="title">application</span>: <span class="title">UIApplication</span>) </span>&#123;</div><div class="line">        <span class="comment">// handle applicationDidEnterBackground event</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewRouter</span> : <span class="title">ZIKViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewRouter</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)registerRoutableDestination &#123;</div><div class="line">    [<span class="keyword">self</span> registerView:[EditorViewController <span class="keyword">class</span>]];</div><div class="line">    [<span class="keyword">self</span> registerViewProtocol:ZIKRoutable(EditorViewProtocol)];</div><div class="line">    [<span class="keyword">self</span> registerURLPattern:<span class="string">@"app://editor/:title"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)processUserInfo:(<span class="built_in">NSDictionary</span> *)userInfo fromURL:(<span class="built_in">NSURL</span> *)url &#123;</div><div class="line">    <span class="built_in">NSString</span> *title = userInfo[<span class="string">@"title"</span>];</div><div class="line">    <span class="comment">// 处理 url 中的参数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 子类重写，创建模块</span></div><div class="line">- (EditorViewController *)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    EditorViewController *destination = [[EditorViewController alloc] init];</div><div class="line">    <span class="keyword">return</span> destination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 配置模块，注入静态依赖</span></div><div class="line">- (<span class="keyword">void</span>)prepareDestination:(EditorViewController *)destination configuration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="comment">// 注入 service 依赖</span></div><div class="line">    destination.storageService = [ZIKRouterToService(EditorStorageServiceInput) makeDestination];</div><div class="line">    <span class="comment">// 其他配置</span></div><div class="line">    <span class="comment">// 处理来自 url 的参数</span></div><div class="line">    <span class="built_in">NSString</span> *title = configuration.userInfo[<span class="string">@"title"</span>];</div><div class="line">    <span class="keyword">if</span> (title) &#123;</div><div class="line">        destination.title = title;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        destination.title = <span class="string">@"默认标题"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 事件处理</span></div><div class="line">+ (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</div><div class="line">    <span class="comment">// handle applicationDidEnterBackground event</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h2 id="基于接口进行解耦的优势"><a href="#基于接口进行解耦的优势" class="headerlink" title="基于接口进行解耦的优势"></a>基于接口进行解耦的优势</h2><p>我们可以看到基于接口管理模块的优势：</p>
<ul>
<li>依赖编译检查，实现严格的类型安全</li>
<li>依赖编译检查，减少重构时的成本</li>
<li>通过接口明确声明模块所需的依赖，允许外部进行依赖注入</li>
<li>保持动态特性的同时，进行路由检查，避免使用不存在的路由模块</li>
<li>利用接口，区分 required protocol 和 provided protocol，进行明确的模块适配，实现彻底解耦</li>
</ul>
<p>回过头看之前的 8 个解耦指标，ZIKRouter 已经完全满足。而 router 提供的多种模块管理方式（makeDestination、prepareDestination、依赖注入、页面跳转、storyboard 支持），能够覆盖大多数现有的场景，从而实现渐进式的模块化，减轻重构现有代码的成本。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag">#iOS</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/10/iOS_reverse_engineering_guide-dynamic_analyzing/" rel="next" title="iOS逆向指南：动态分析">
                <i class="fa fa-chevron-left"></i> iOS逆向指南：动态分析
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

          
  <div class="comments" id="comments">
    
      <div id="gitalk-container"></div>
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="zuik" />
          <p class="site-author-name" itemprop="name">zuik</p>
          <p class="site-description motion-element" itemprop="description">自强不息 厚德载物 zuikxyo@gmail.com https://github.com/Zuikyo</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">15</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是组件化"><span class="nav-number">1.</span> <span class="nav-text">什么是组件化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么需要组件化"><span class="nav-number">2.</span> <span class="nav-text">为什么需要组件化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你的项目是否需要组件化"><span class="nav-number">3.</span> <span class="nav-text">你的项目是否需要组件化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件化方案的8条指标"><span class="nav-number">4.</span> <span class="nav-text">组件化方案的8条指标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方案对比"><span class="nav-number">5.</span> <span class="nav-text">方案对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#URL-路由"><span class="nav-number">5.1.</span> <span class="nav-text">URL 路由</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串解耦的问题"><span class="nav-number">5.1.1.</span> <span class="nav-text">字符串解耦的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代表框架"><span class="nav-number">5.1.2.</span> <span class="nav-text">代表框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#改进：避免字符串管理"><span class="nav-number">5.1.3.</span> <span class="nav-text">改进：避免字符串管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Target-Action-方案"><span class="nav-number">5.2.</span> <span class="nav-text">Target-Action 方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字典传参的问题"><span class="nav-number">5.2.1.</span> <span class="nav-text">字典传参的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代表框架-1"><span class="nav-number">5.2.2.</span> <span class="nav-text">代表框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#改进：避免字典传参"><span class="nav-number">5.2.3.</span> <span class="nav-text">改进：避免字典传参</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于-protocol-匹配的方案"><span class="nav-number">5.3.</span> <span class="nav-text">基于 protocol 匹配的方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代表框架-2"><span class="nav-number">5.3.1.</span> <span class="nav-text">代表框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#改进：离散式管理"><span class="nav-number">5.3.2.</span> <span class="nav-text">改进：离散式管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Protocol-Router-匹配方案"><span class="nav-number">6.</span> <span class="nav-text">Protocol-Router 匹配方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态化的风险"><span class="nav-number">7.</span> <span class="nav-text">动态化的风险</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态路由检查"><span class="nav-number">8.</span> <span class="nav-text">静态路由检查</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#路由声明"><span class="nav-number">8.1.</span> <span class="nav-text">路由声明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Objective-C：protocol-继承链"><span class="nav-number">8.1.1.</span> <span class="nav-text">Objective-C：protocol 继承链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Swift：条件扩展"><span class="nav-number">8.1.2.</span> <span class="nav-text">Swift：条件扩展</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由检查"><span class="nav-number">8.2.</span> <span class="nav-text">路由检查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Objective-C-protocol-遍历"><span class="nav-number">8.2.1.</span> <span class="nav-text">Objective-C: protocol 遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Swift-符号遍历"><span class="nav-number">8.2.2.</span> <span class="nav-text">Swift: 符号遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Swift-Runtime-和-ABI"><span class="nav-number">8.2.2.1.</span> <span class="nav-text">Swift Runtime 和 ABI</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动推断返回值类型"><span class="nav-number">8.3.</span> <span class="nav-text">自动推断返回值类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块解耦"><span class="nav-number">9.</span> <span class="nav-text">模块解耦</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模块分类"><span class="nav-number">9.1.</span> <span class="nav-text">模块分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是解耦"><span class="nav-number">9.2.</span> <span class="nav-text">什么是解耦</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一层：抽象接口，提取依赖关系"><span class="nav-number">9.2.1.</span> <span class="nav-text">第一层：抽象接口，提取依赖关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二层：模块重用，管理模块间通信"><span class="nav-number">9.2.2.</span> <span class="nav-text">第二层：模块重用，管理模块间通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三层：去除隐式约定"><span class="nav-number">9.2.3.</span> <span class="nav-text">第三层：去除隐式约定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块重用"><span class="nav-number">9.3.</span> <span class="nav-text">模块重用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#依赖管理"><span class="nav-number">10.</span> <span class="nav-text">依赖管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖注入"><span class="nav-number">10.1.</span> <span class="nav-text">依赖注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分离模块创建和配置"><span class="nav-number">10.2.</span> <span class="nav-text">分离模块创建和配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Prepare-Destination"><span class="nav-number">10.2.1.</span> <span class="nav-text">Prepare Destination</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可选依赖：属性注入和方法注入"><span class="nav-number">10.3.</span> <span class="nav-text">可选依赖：属性注入和方法注入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模块间参数传递"><span class="nav-number">10.3.1.</span> <span class="nav-text">模块间参数传递</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#必需依赖：工厂方法"><span class="nav-number">10.4.</span> <span class="nav-text">必需依赖：工厂方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用泛型代替-configuration-子类"><span class="nav-number">10.4.1.</span> <span class="nav-text">用泛型代替 configuration 子类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#避免接口污染"><span class="nav-number">10.5.</span> <span class="nav-text">避免接口污染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖查找"><span class="nav-number">10.6.</span> <span class="nav-text">依赖查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环依赖"><span class="nav-number">10.7.</span> <span class="nav-text">循环依赖</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块适配器"><span class="nav-number">11.</span> <span class="nav-text">模块适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#required-protocol-和-provided-protocol"><span class="nav-number">11.1.</span> <span class="nav-text">required protocol 和 provided protocol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为provided模块添加required-protocol"><span class="nav-number">11.2.</span> <span class="nav-text">为provided模块添加required protocol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口适配"><span class="nav-number">11.3.</span> <span class="nav-text">接口适配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用中介者转发接口"><span class="nav-number">11.4.</span> <span class="nav-text">用中介者转发接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明式依赖"><span class="nav-number">11.5.</span> <span class="nav-text">声明式依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块提供默认的依赖配置"><span class="nav-number">11.6.</span> <span class="nav-text">模块提供默认的依赖配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块化"><span class="nav-number">11.7.</span> <span class="nav-text">模块化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-adapter-的规范"><span class="nav-number">11.8.</span> <span class="nav-text">使用 adapter 的规范</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块间通信"><span class="nav-number">12.</span> <span class="nav-text">模块间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#控制流-input-和-output"><span class="nav-number">12.1.</span> <span class="nav-text">控制流 input 和 output</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置-input-和-output"><span class="nav-number">12.2.</span> <span class="nav-text">设置 input 和 output</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子模块"><span class="nav-number">12.3.</span> <span class="nav-text">子模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#子模块的来源"><span class="nav-number">12.3.1.</span> <span class="nav-text">子模块的来源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通信方式"><span class="nav-number">12.3.2.</span> <span class="nav-text">通信方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Output-的适配"><span class="nav-number">12.4.</span> <span class="nav-text">Output 的适配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#功能扩展"><span class="nav-number">13.</span> <span class="nav-text">功能扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自动注册"><span class="nav-number">13.1.</span> <span class="nav-text">自动注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装界面跳转"><span class="nav-number">13.2.</span> <span class="nav-text">封装界面跳转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义跳转"><span class="nav-number">13.3.</span> <span class="nav-text">自定义跳转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#支持-storyboard"><span class="nav-number">13.4.</span> <span class="nav-text">支持 storyboard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URL-路由-1"><span class="nav-number">13.5.</span> <span class="nav-text">URL 路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-router-对象代替-router-子类"><span class="nav-number">13.6.</span> <span class="nav-text">用 router 对象代替 router 子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简化-router-实现"><span class="nav-number">13.7.</span> <span class="nav-text">简化 router 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件处理"><span class="nav-number">13.8.</span> <span class="nav-text">事件处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单元测试"><span class="nav-number">14.</span> <span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口版本管理"><span class="nav-number">15.</span> <span class="nav-text">接口版本管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最终形态"><span class="nav-number">16.</span> <span class="nav-text">最终形态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于接口进行解耦的优势"><span class="nav-number">17.</span> <span class="nav-text">基于接口进行解耦的优势</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zuik</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script>
(function(){
var bp = document.createElement('script');
bp.src = '//zz.bdstatic.com/linksubmit/push.js';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(bp, s);
})();
</script>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.min.js"></script>

  
  <script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
    
      <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
      <script type="text/javascript">
        const gitalk = new Gitalk({
          clientID: '348b65b1168d7aa48b08',
          clientSecret: '6a87660b699abe603eac61c471ab5781fd27fc03',
          repo: 'Zuikyo.github.io',
          owner: 'Zuikyo',
          admin: 'Zuikyo'.split(','),
          id: '1563125580000',
          pagerDirection: 'first',
          // facebook-like distraction free mode
          distractionFreeMode: false
        })
        gitalk.render('gitalk-container')
      </script>
    
  

  
  

  

  

  

</body>
</html>
