<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/libs/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/libs/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS," />





  <link rel="alternate" href="/atom.xml" title="黑超熊猫zuik's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="第一篇文章对VIPER进行了简单的介绍，这篇文章将从VIPER的源头开始，比较现有的几种VIPER实现，对VIPER进行进一步的职责剖析，并对各种细节实现问题进行挖掘和探讨。最后给出两个完整的VIPER实现，并且提供快速生成VIPER代码的模板。
Demo和轮子的github地址是：ZIKViper，路由工具：ZIKRouter。有用请点个star~
两个实现展示了以下问题的解决方案：

如何彻底">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS VIPER架构实践(二)：VIPER详解与实现">
<meta property="og:url" content="http://yoursite.com/2017/08/11/iOS VIPER架构实践(二)：VIPER详解与实现/index.html">
<meta property="og:site_name" content="黑超熊猫zuik's blog">
<meta property="og:description" content="第一篇文章对VIPER进行了简单的介绍，这篇文章将从VIPER的源头开始，比较现有的几种VIPER实现，对VIPER进行进一步的职责剖析，并对各种细节实现问题进行挖掘和探讨。最后给出两个完整的VIPER实现，并且提供快速生成VIPER代码的模板。
Demo和轮子的github地址是：ZIKViper，路由工具：ZIKRouter。有用请点个star~
两个实现展示了以下问题的解决方案：

如何彻底">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1865432-13daad61ed8db39c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1865432-dda97ce26c973609.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1865432-76a4f532c58da061.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1865432-9f35c09e9c9b0f12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1865432-ad4602f11ed62094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1865432-bdb29d6717472b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1865432-e71eed65c555ddc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1865432-a204e884cdb08f63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1865432-2a5e4eaf6275caba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-01-24T01:45:41.320Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS VIPER架构实践(二)：VIPER详解与实现">
<meta name="twitter:description" content="第一篇文章对VIPER进行了简单的介绍，这篇文章将从VIPER的源头开始，比较现有的几种VIPER实现，对VIPER进行进一步的职责剖析，并对各种细节实现问题进行挖掘和探讨。最后给出两个完整的VIPER实现，并且提供快速生成VIPER代码的模板。
Demo和轮子的github地址是：ZIKViper，路由工具：ZIKRouter。有用请点个star~
两个实现展示了以下问题的解决方案：

如何彻底">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1865432-13daad61ed8db39c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2017/08/11/iOS VIPER架构实践(二)：VIPER详解与实现/"/>

  <title> iOS VIPER架构实践(二)：VIPER详解与实现 | 黑超熊猫zuik's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">黑超熊猫zuik's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">写点别人没写过的</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                iOS VIPER架构实践(二)：VIPER详解与实现
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-08-11T16:55:29+08:00" content="2017-08-11">
              2017-08-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/代码架构/" itemprop="url" rel="index">
                    <span itemprop="name">代码架构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>第一篇文章对VIPER进行了简单的介绍，这篇文章将从VIPER的源头开始，比较现有的几种VIPER实现，对VIPER进行进一步的职责剖析，并对各种细节实现问题进行挖掘和探讨。最后给出两个完整的VIPER实现，并且提供快速生成VIPER代码的模板。</p>
<p>Demo和轮子的github地址是：<a href="https://github.com/Zuikyo/ZIKViper" target="_blank" rel="external">ZIKViper</a>，路由工具：<a href="https://github.com/Zuikyo/ZIKRouter" target="_blank" rel="external">ZIKRouter</a>。有用请点个star~</p>
<p>两个实现展示了以下问题的解决方案：</p>
<ul>
<li>如何彻底地解决不同模块之间的耦合</li>
<li>如何在一个模块里引入子模块</li>
<li>子模块和父模块之间如何通信</li>
<li>如何对模块进行依赖注入</li>
<li>面向接口的路由工具</li>
</ul>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>VIPER架构，最初是2013年在MutualMobile的技术博客上，由Jeff Gilbert 和 Conrad Stoll 提出的。他们的博客网站有过一次迁移，原文地址已经失效，这是迁移后的博文：<a href="https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework" target="_blank" rel="external">MEET VIPER: MUTUAL MOBILE’S APPLICATION OF CLEAN ARCHITECTURE FOR IOS APPS</a>。</p>
<p>这是文章中提出的架构示意图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-13daad61ed8db39c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="viper_mutualmobile"></p>
<p>Wireframe可以看作是Router的另一种表达。可以看到，VIPER之间的关系已经很明确了。之后，作者在2014年在objc.io上发表了另一篇更详细的介绍文章：<a href="https://www.objc.io/issues/13-architecture/viper/" target="_blank" rel="external">Architecting iOS Apps with VIPER</a>。</p>
<p>在作者的第一篇文章里，阐述了VIPER是在接触到了Uncle Bob的<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">Clean Architecture</a>后，对Clean Architecture的一次实践。因此，VIPER真正的源头应该是Clean Architecture。</p>
<h2 id="Clean-Architecture"><a href="#Clean-Architecture" class="headerlink" title="Clean Architecture"></a>Clean Architecture</h2><p>由Uncle Bob在2011年提出的<code>Clean Architecture</code>，是一个平台无关的抽象架构。想要详细学习的，可以阅读作者的原文：<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">Clean Architecture</a>，翻译：<a href="http://www.jdon.com/artichect/the-clean-architecture.html" target="_blank" rel="external">干净的架构The Clean Architecture</a>。</p>
<p>它通过梳理软件中不同层之间的依赖关系，提出了一个自外向内，单向依赖的架构，如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-dda97ce26c973609.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Clean Architecture"></p>
<p>越靠近内层，越变得抽象，越接近设计的核心。越靠近外层，越和具体的平台和实现技术相关。内层的部分完全不知道外层的存在和实现方式，代码只能从外层向内层引用，目的是为了实现层与层之间的隔离。将不同抽象程度的层进行隔离，做到了把业务规则和具体实现分离开。你可以把外层看作是内层的delegate，外层只能通过内层提供的delegate接口来使用内层。</p>
<h3 id="Enterprise-Business-Rules"><a href="#Enterprise-Business-Rules" class="headerlink" title="Enterprise Business Rules"></a>Enterprise Business Rules</h3><p>代表了这个软件项目的业务规则。由数据实体体现，是一些可以在不同的程序应用之间共享的数据结构。</p>
<h3 id="Application-Business-Rules"><a href="#Application-Business-Rules" class="headerlink" title="Application Business Rules"></a>Application Business Rules</h3><p>代表了本应用所使用的一些业务规则。封装和实现了用到的业务功能，会将各种实体的数据结构转为在用例中传递的实体类，但是和具体的数据库技术或者UI无关。</p>
<h3 id="Interface-Adapters"><a href="#Interface-Adapters" class="headerlink" title="Interface Adapters"></a>Interface Adapters</h3><p>接口适配层。将用例的规则和具体的实现技术进行抽象地对接，将用例中用到的实体类转为供数据库存储的格式或者供View展示的格式。类似于MVVM中把Model的数据传递给ViewModel供View显示。</p>
<p>右下角表示了接口适配层中不同模块间的通信方式。不同的模块在业务用例中产生关联和数据传递。Input、Output就是Use Case提供给外层的数据流动接口。</p>
<h3 id="Frameworks-amp-Drivers"><a href="#Frameworks-amp-Drivers" class="headerlink" title="Frameworks &amp; Drivers"></a>Frameworks &amp; Drivers</h3><p>库和驱动层，代表了选用的各种具体的实现技术，例如持久层使用SQLite还是Core Data，网络层使用NSURLSession、NSURLConnection还是AFNetworking等。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到，Clean Architecture里已经出现了Use Case、Interactor、Presenter等概念，它为VIPER的工程实现提供了设计思想，VIPER将它的设计转化成了具体的实现。VIPER里的各部分正是存在着由外向内的依赖，从外向内表现为：<code>View -&gt; Presenter -&gt; Interactor -&gt; Entity</code>，<code>Wireframe</code>严格来说也是一类特殊的Use Case，用于不同模块之间通信，连接了不同的<code>Presenter</code>。</p>
<p>必须要记住的是，<strong>VIPER架构是根据由外向内的依赖关系来设计的</strong>。这句话是指导我们进行进一步设计和优化的关键。</p>
<h2 id="现有的各种VIPER实现"><a href="#现有的各种VIPER实现" class="headerlink" title="现有的各种VIPER实现"></a>现有的各种VIPER实现</h2><p>MutualMobile的那两篇文章虽然已经明确了VIPER各部分之间的职责，并且给出了简单的Demo，但是对Wireframe部分的实现有些争议，解耦做得不够彻底，并且对各层之间如何交互还处在最简单的实现上。之后出现了挺多文章来将VIPER进一步细化，不过某些细节的实现上有些差别，在给出我自己的VIPER之前，我将先对这些实现进行一次综合的比较分析，看看他们都使用了哪些技术，遇到了哪些争议点。不同实现之间已经公认的地方我就不再单独列出了。</p>
<h3 id="Brigade团队的实现"><a href="#Brigade团队的实现" class="headerlink" title="Brigade团队的实现"></a>Brigade团队的实现</h3><p>原文地址：<a href="https://brigade.engineering/brigades-experience-using-an-mvc-alternative-36ef1601a41f" target="_blank" rel="external">Brigade’s Experience Using an MVC Alternative: VIPER architecture for iOS applications</a>。</p>
<p>文章把VIPER的优点总结了一下，提出了这样的架构图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-76a4f532c58da061.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Brigade’s VIPER"></p>
<p>他们对VIPER的各部分都没有异议，只是对Interactor的实现进行了进一步细化。用一个Data Manager提供给各个Use Case管理Entity，比如获取、存储功能。在Service中调用网络层去获取服务端的数据。</p>
<p>文章中还认为应该由Wireframe负责初始化整个VIPER，生成各部分的类，并设置依赖关系，并且引用另一个模块的Wireframe，负责跳转到另一个界面。</p>
<p>和这个实现类似的还有：</p>
<ul>
<li><a href="https://swifting.io/blog/2016/03/07/8-viper-to-be-or-not-to-be/" target="_blank" rel="external">VIPER to be or not to be?</a>。这篇文章里给出了一个Unit Test的例子，还探讨了应该在什么情况下开始应用VIPER。</li>
<li><a href="https://cheesecakelabs.com/blog/best-practices-viper-architecture/" target="_blank" rel="external">VIPER architecture: Our best practices to build an app like a boss</a>。Demo地址：<a href="https://github.com/CheesecakeLabs/Boilerplate_iOS_VIPER" target="_blank" rel="external">Boilerplate_iOS_VIPER</a>。</li>
</ul>
<p>针对VIPER需要编写太多初始化代码的麻烦，可以使用Xcode自带的Template解决。而很多作者都提到了一个代码生成工具：<a href="https://github.com/rambler-digital-solutions/Generamba" target="_blank" rel="external">Generamba</a>。</p>
<h4 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h4><p>文章并没有对VIPER进行修改，只是进一步细化了。这应该是一个最简单的实现。如果你要实施VIPER，参照这篇文章来没有什么大问题。但是它没有探讨的问题是：</p>
<ul>
<li>如何解决不同Wrieframe之间的耦合？</li>
<li>Wrieframe如何知道其他模块需要的初始化参数？</li>
<li>在模块间通信时，Interactor的数据如何传递给另一个模块？</li>
<li>父模块和子模块之间是怎样的关系？</li>
</ul>
<h3 id="Rambler-amp-Co团队的实现"><a href="#Rambler-amp-Co团队的实现" class="headerlink" title="Rambler&amp;Co团队的实现"></a>Rambler&amp;Co团队的实现</h3><p>一个对VIPER十分感兴趣的俄国团队，编写了一本关于VIPER的书：<a href="https://github.com/strongself/The-Book-of-VIPER" target="_blank" rel="external">The-Book-of-VIPER</a>。并且给出了一个目前网络上实现完成度最高的开源Demo：<a href="https://github.com/rambler-digital-solutions/rambler-it-ios" target="_blank" rel="external">rambler-it-ios</a>，以及他们用于实施VIPER的库：<a href="https://github.com/rambler-digital-solutions/ViperMcFlurry" target="_blank" rel="external">ViperMcFlurry</a>。</p>
<p>他们整理的VIPER架构图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-9f35c09e9c9b0f12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Rambler&amp;Co&#39;s VIPER"></p>
<p>和其他实现不同的是，他们把VIPER的初始化和装配工作单独放到了一个Assembly里，Router只做界面跳转的工作。并且把VIPER内不同部分之间的通信统一用Input和Output来表示。Input表示外部主动调用模块提供的接口，Output表示模块通过外部实现所要求的接口，将事件传递到外部。</p>
<p>之所以将模块初始化单独放到Assembly里，是因为Router如果负责初始化本模块，会违背单一职责原则。</p>
<h4 id="争议-1"><a href="#争议-1" class="headerlink" title="争议"></a>争议</h4><p>这个实现的愿景很好，只是在转变为具体实现的时候不够完美，有很多问题尚待解决。具体可以参见Demo。</p>
<ul>
<li>Assembly使用了<a href="https://github.com/appsquickly/Typhoon" target="_blank" rel="external">Typhoon</a>这个依赖注入工具，通过Method Swizzling自动初始化VIPER的各个部分</li>
</ul>
<p>我对Typhoon这个依赖注入工具不是特别感冒，它使用了十分复杂的run time技术，想要追踪一个对象的注入过程时，会看得晕头转向。而且它无法实现运行时由调用方动态注入，只能实现预定义好的静态注入。也就是不能动态传参。</p>
<ul>
<li>使用storyboard进行路由</li>
</ul>
<p>在Demo中实现了在执行segue时用block来使用<code>-prepareForSegue:sender:</code>，实现向目的界面传参，实现了动态注入。但是这样就把路由限定在了storyboard的segue技术上，那么对于那些没有使用storyboard的项目应该怎么办呢？Demo并没有给出答案。而且<code>-prepareForSegue:sender:</code>只能向View传参，但是有一些参数是View不应该接触到的，而是应该直接传给Presenter或者Interactor的。</p>
<ul>
<li>有时候模块需要从Output中获取数据，例如Presenter主动获取View中的文字，传递给Interactor，此时<code>Output</code>并不能完整描述它的职责，还可以再进一步划分</li>
</ul>
<p>也就是说，他们的方案在设计上是不错的，但在技术上还有很多改进空间。</p>
<h3 id="Uber团队的实现"><a href="#Uber团队的实现" class="headerlink" title="Uber团队的实现"></a>Uber团队的实现</h3><p>Uber由于业务越来越复杂，旧项目的架构已经无法满足当前的需求，因此在2016年完全重构了他们的 rider app。他们借鉴VIPER，并且设计出了一个VIPER的变种架构：Riblets。文章地址：<a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="external">ENGINEERING THE ARCHITECTURE BEHIND UBER’S NEW RIDER APP</a>。</p>
<p>架构图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-ad4602f11ed62094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="riblets"></p>
<p>数据流向图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-bdb29d6717472b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="riblets_数据流向"></p>
<p>父模块和子模块之间通信：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-e71eed65c555ddc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="riblet_父子模块间通信"></p>
<h4 id="各部分职责"><a href="#各部分职责" class="headerlink" title="各部分职责"></a>各部分职责</h4><p>这里只列出一些和VIPER有差异的地方：</p>
<ul>
<li>Builder负责初始化Riblets模块内的各个部分，定义了模块的依赖参数</li>
<li>Component负责获取和初始化那些不是Riblets模块内的部分，例如services，并注入到Interactor中</li>
<li>Router负责管理子模块，持有子模块的Router，并把子模块的View添加到视图树上</li>
<li>Interactor通过调用Service管理Model，而不是在Interactor中直接管理</li>
<li>Interactor和子模块的Interactor通过监听者模式和delegate互相通信</li>
</ul>
<h4 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h4><p>最大的改变是将Router从Presenter移到了Interactor，改变了模块的主从关系，整个模块的生命周期现在由Interactor来管理。而之前的VIPER模块是依赖于View的生命周期的。这样一来，整个架构就从View驱动变成了业务驱动，或者数据驱动。</p>
<p>关于这个改变，Uber给出了两个原因：</p>
<ul>
<li>想要统一iOS和Andorid的软件架构，以及更好地互相借鉴开发经验和教训，因而需要改变iOS中视图驱动的设计</li>
<li>想要创建一个没有View，只有业务逻辑的模块，因此生命周期需要由Interactor管理</li>
</ul>
<h4 id="争议-2"><a href="#争议-2" class="headerlink" title="争议"></a>争议</h4><p>Uber团队的确很有想法。在对他们的这个方案进行深入实践之前，我无法评论这个方案是好是坏，我只在这里提出一些实践中可能会遇到的问题。</p>
<p>关于Uber给出的第一个原因，这是Uber团队基于协调两个开发团队的情况而做出的选择，如果我们没有他们这样统一开发的需求，并没有必要借鉴。iOS的UIKit是一个视图驱动的框架，很难做到100%数据驱动，在实践中将会遇到许多需要解决的问题，除非有足够的开发时间，否则不要草率地投入其中。是否要使用数据驱动的设计，还是应该由项目的业务设计来决定。当数据变化大部分是由后端的Service和网络数据引起时，再去考虑数据驱动吧。例如Uber的地图路线由定位模块不断计算，自动更新，就比较适合使用数据驱动。</p>
<p>关于第二个原因，一个没有View和Presenter的VIPER，就只剩下Router、Interactor、Model，这时这个模块可以看做是一个可以通过Router调用的Service或者Manager，这个Service有自己的状态和生命周期，Service也可以在View销毁后继续完成剩余的业务工作，只要业务需要，可以进行自持有，自释放。而且这个Service最终还是会表现在某个View上。这么看来，Router的层级已经升高了，成为了整个app内的模块间通信工具，可以连接任意模块，不仅仅是VIPER，因此Router由谁持有，就完全由模块内部自由管理了。</p>
<p>只是，在iOS中的VIPER里，实际的路由API都是存在于UIViewController上的，Router会直接和View产生引用，把Router放到和View隔离的Interactor里会破坏隔离。而且从Clean架构的分层来看，层级升高后的Router应该是处在Interface Adapter层和Framework &amp; Driver层之间，而Interactor则是在Application Business Rules层，由Interactor来管理其他角色，会破坏了Clean Architecture里的依赖关系。</p>
<p>比如一个没有View的、用于管理语音通话数据的Interactor，收到了通话异常中断的事件，在处理事件时，它不应该通过Router将自己移除，或者结束整个语音通话业务，或者自动调用重新拨号的业务，这样很容易会让不同的Use Case之间产生耦合，这些都应该由更上层的Service去选择执行，如果有页面跳转的设计，则应该把事件转发给一个存在Presenter层的Parent VIPER模块，由parent来决定是退出通话界面还是弹窗提示。当一个Interactor没有Presenter和View时，它一定是另一个VIPER的子模块。这么看来，在没有View时，或许让Service来持有Router才是正确的。</p>
<p>因此，如果真的有把VIPER变成数据驱动的需求，主要还是源于Uber给出的第一个基于团队统一的理由。</p>
<h4 id="其他设计"><a href="#其他设计" class="headerlink" title="其他设计"></a>其他设计</h4><p>文章里还给出了一些很有参考价值的内容，比如：</p>
<ul>
<li>对Interactor进行注入的Component</li>
<li>视图树变成了Router树</li>
<li>Interactor不直接维护Model，而是通过对应的Service来维护Model</li>
<li>父模块和子模块之间通过Interactor来通信</li>
</ul>
<p>Uber的这个方案讲了很多其他方案没有提到的方面，比如依赖注入、如何引入子模块等问题。不过这个方案并没有开源。</p>
<h2 id="方案一：最完整的VIPER"><a href="#方案一：最完整的VIPER" class="headerlink" title="方案一：最完整的VIPER"></a>方案一：最完整的VIPER</h2><p>各种实现方案都分析了一遍，接下来就开始进行一个总结。首先总结出一个绝对标准的VIPER，各部分遵循隔离关系，同时考虑到依赖注入、子模块通信、模块间解耦等问题，将VIPER的各部分的职责变得更加明确，也新增了几个角色。示例图如下，各角色的颜色和Clean Architecture图中各层的颜色对应：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-a204e884cdb08f63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="thorough_viper"></p>
<p>示例代码将用一个笔记应用作为演示。</p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View可以是一个UIView + UIViewController，也可以只是一个custom UIView，也可以是一个自定义的用于管理UIView的Manager，只要它实现了View的接口就可以。</p>
<p>View层的职责：</p>
<ul>
<li>展示界面，组合各种UIView，并在UIViewController内管理各种控件的布局、更新</li>
<li>View对外暴露各种用于更新UI的接口，而自己不主动更新UI</li>
<li>View持有一个由外部注入的eventHandler对象，将View层的事件发送给eventHandler</li>
<li>View持有一个由外部注入的viewDataSource对象，在View的渲染过程中，会从viewDataSource获取一些用于展示的数据，viewDataSource的接口命名应该尽量和具体业务无关</li>
<li>View向Presenter提供routeSource，也就是用于界面跳转的源界面</li>
</ul>
<p>View层会引入各种自定义控件，这些控件有许多delegate，都在View层实现，统一包装后，再交给Presenter层实现。因为Presenter层并不知道View的实现细节，因此也就不知道这些控件的接口，Presenter层只知道View层统一暴露出来的接口。而且这些控件的接口在定义时可能会将数据获取、事件回调、控件渲染接口混杂起来，最具代表性的就是<code>UITableViewDataSource</code>里的<code>-tableView:cellForRowAtIndexPath:</code>。这个接口同时涉及到了<code>UITableViewCell</code>和渲染cell所需要的Model，是非常容易产生耦合的地方，因此需要做一次分解。应该在View的dataSource里定义一个从外部获取所需要的简单类型数据的方法，在<code>-tableView:cellForRowAtIndexPath:</code>里用获取到的数据渲染cell。示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@protocol ZIKNoteListViewEventHandler &lt;NSObject&gt;</div><div class="line">- (void)handleDidSelectRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@protocol ZIKNoteListViewDataSource &lt;NSObject&gt;</div><div class="line">- (NSInteger)numberOfRowsInSection:(NSInteger)section;</div><div class="line">- (NSString *)textOfCellForRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class="line">- (NSString *)detailTextOfCellForRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">@interface ZIKNoteListViewController () &lt;UITableViewDelegate,UITableViewDataSource&gt;</div><div class="line">@property (nonatomic, strong) id&lt;ZIKNoteListViewEventHandler&gt; eventHandler;</div><div class="line">@property (nonatomic, strong) id&lt;ZIKNoteListViewDataSource&gt; viewDataSource;</div><div class="line">@property (weak, nonatomic) IBOutlet UITableView *noteListTableView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKNoteListViewController</div><div class="line"></div><div class="line">- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">                                      text:(NSString *)text</div><div class="line">                                detailText:(NSString *)detailText &#123;</div><div class="line">    UITableViewCell *cell = [self.noteListTableView dequeueReusableCellWithIdentifier:@&quot;noteListCell&quot; forIndexPath:indexPath];</div><div class="line">    cell.textLabel.text = text;</div><div class="line">    cell.detailTextLabel.text = detailText;</div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark UITableViewDataSource</div><div class="line"></div><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class="line">    return [self.viewDataSource numberOfRowsInSection:section];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSString *text = [self.viewDataSource textOfCellForRowAtIndexPath:indexPath];</div><div class="line">    NSString *detailText = [self.viewDataSource detailTextOfCellForRowAtIndexPath:indexPath];</div><div class="line">    UITableViewCell *cell = [self cellForRowAtIndexPath:indexPath</div><div class="line">                                                   text:text</div><div class="line">                                             detailText:detailText];</div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark UITableViewDelegate</div><div class="line"></div><div class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</div><div class="line">    </div><div class="line">    [self.eventHandler handleDidSelectRowAtIndexPath:indexPath];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一般来说，viewDataSource和eventHandler都是由Presenter来担任的，Presenter接收到dataSource请求时，从Interactor里获取并返回对应的数据。你也可以选择在View和Presenter之间用ViewModel来进行交互。</p>
<h3 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h3><p>Presenter由View持有，它的职责有：</p>
<ul>
<li>接收并处理来自View的事件</li>
<li>维护和View相关的各种状态和配置，比如界面是否使用夜间模式等</li>
<li>调用Interactor提供的Use Case执行业务逻辑</li>
<li>向Interactor提供View中的数据，让Interactor生成需要的Model</li>
<li>接收并处理来自Interactor的业务事件回调事件</li>
<li>通知View进行更新操作</li>
<li>通过Wireframe跳转到其他View</li>
</ul>
<p>Presenter是View和业务之间的中转站，它不包含业务实现代码，而是负责调用现成的各种Use Case，将具体事件转化为具体业务。Presenter里不应该导入UIKit，否则就有可能入侵View层的渲染工作。Presenter里也不应该出现Model类，当数据从Interactor传递到Presenter里时，应该转变为简单的数据结构。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@interface ZIKNoteListViewPresenter () &lt;ZIKNoteListViewDataSource, ZIKNoteListViewEventHandler&gt;</div><div class="line">@property (nonatomic, strong) id&lt;ZIKNoteListWireframeProtocol&gt; wireframe;</div><div class="line">@property (nonatomic, weak) id&lt;ZIKViperView,ZIKNoteListViewProtocol&gt; view;</div><div class="line">@property (nonatomic, strong) id&lt;ZIKNoteListInteractorInput&gt; interactor;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKNoteListViewPresenter</div><div class="line"></div><div class="line">#pragma mark ZIKNoteListViewDataSource</div><div class="line"></div><div class="line">- (NSInteger)numberOfRowsInSection:(NSInteger)section &#123;</div><div class="line">    return self.interactor.noteCount;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)textOfCellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSString *title = [self.interactor titleForNoteAtIndex:indexPath.row];</div><div class="line">    return title;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)detailTextOfCellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSString *content = [self.interactor contentForNoteAtIndex:indexPath.row];</div><div class="line">    return content;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark ZIKNoteListViewEventHandler</div><div class="line"></div><div class="line">- (void)handleDidSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSString *uuid = [self.interactor noteUUIDAtIndex:indexPath.row];</div><div class="line">    NSString *title = [self.interactor noteTitleAtIndex:indexPath.row];</div><div class="line">    NSString *content = [self.interactor noteContentAtIndex:indexPath.row];</div><div class="line">    </div><div class="line">    [self.wireframe pushEditorViewForEditingNoteWithUUID:uuid title:title content:content delegate:self];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="Interactor"><a href="#Interactor" class="headerlink" title="Interactor"></a>Interactor</h3><p>Ineractor的职责：</p>
<ul>
<li>实现和封装各种业务的Use Case，供外部调用</li>
<li>维护和业务相关的各种状态，比如是否正在编辑笔记</li>
<li>Interactor可以获取各种Manager和Service，用于组合实现业务逻辑，这些Manager和Service应该是由外部注入的依赖，而不是直接引用具体的类</li>
<li>通过DataManager维护Model</li>
<li>监听各种外部的业务事件并处理，必要时将事件发送给eventHandler</li>
<li>Interactor持有一个由外部注入的eventHandler对象，将需要外部处理的业务事件发送给eventHandler，或者通过eventHandler接口对某些数据操作的过程进行回调</li>
<li>Interactor持有一个由外部注入的dataSource对象，用于获取View上的数据，以更新Model</li>
</ul>
<p>Interactor是业务的实现者和维护者，它会调用各种Service来实现业务逻辑，封装成明确的用例。而这些Service在使用时，也都是基于接口的，因为Interactor的实现不和具体的类绑定，而是由Application注入Interactor需要的Service。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@protocol ZIKNoteListInteractorInput &lt;NSObject&gt;</div><div class="line">- (void)loadAllNotes;</div><div class="line">- (NSInteger)noteCount;</div><div class="line">- (NSString *)titleForNoteAtIndex:(NSUInteger)idx;</div><div class="line">- (NSString *)contentForNoteAtIndex:(NSUInteger)idx;</div><div class="line">- (NSString *)noteUUIDAtIndex:(NSUInteger)idx;</div><div class="line">- (NSString *)noteTitleAtIndex:(NSUInteger)idx;</div><div class="line">- (NSString *)noteContentAtIndex:(NSUInteger)idx;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">@interface ZIKNoteListInteractor : NSObject &lt;ZIKNoteListInteractorInput&gt;</div><div class="line">@property (nonatomic, weak) id dataSource;</div><div class="line">@property (nonatomic, weak) id eventHandler;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKNoteListInteractor</div><div class="line"></div><div class="line">- (void)loadAllNotes &#123;</div><div class="line">    [[ZIKNoteDataManager sharedInsatnce] fetchAllNotesWithCompletion:^(NSArray *notes) &#123;</div><div class="line">        [self.eventHandler didFinishLoadAllNotes];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSArray&lt;ZIKNoteModel *&gt; *)noteList &#123;</div><div class="line">    return [ZIKNoteDataManager sharedInsatnce].noteList;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)noteCount &#123;</div><div class="line">    return self.noteList.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)titleForNoteAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] title];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)contentForNoteAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] content];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)noteUUIDAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] uuid];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)noteTitleAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] title];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)noteContentAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] content];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>向Interactor提供各种封装好的服务，例如数据库的访问、存储，调用定位功能等。Service由Application在执行路由时注入到Builder里，再由Buidler注入到Interactor里。也可以只注入一个Service Router，在运行时再通过这个Service Router懒加载需要的Service，相当于注入了一个提供Router功能的Service。</p>
<p>Service可以看作是没有View的VIPER，也有自己的路由和Builder。</p>
<h3 id="Wireframe"><a href="#Wireframe" class="headerlink" title="Wireframe"></a>Wireframe</h3><p>翻译成中文叫线框，用于表达从一个Module到另一个Module的过程。虽然也是扮演者执行路由的角色，但是其实它和Router是有区别的。</p>
<p>Wireframe和storyboard中连接好的一个个segue类似，负责提供一系列具体的路由用例，这个用例里已经配置好了源界面和目的界面的一些依赖，包括转场动画、模块间传参等。Wireframe的接口是提供给模块内部使用的，它通过调用Router来执行真正的路由操作。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface ZIKTNoteListWireframe : NSObject &lt;ZIKTViperWireframe&gt;</div><div class="line">- (void)presentLoginViewWithMessage:(NSString *)message delegate:(id&lt;ZIKTLoginViewDelegate&gt;)delegate completion:(void (^ __nullable)(void))completion;</div><div class="line">- (void)dismissLoginView:(UIViewController *)viewController animated:(BOOL)animated completion:(void (^ __nullable)(void))completion;</div><div class="line">- (void)presentEditorForCreatingNewNoteWithDelegate:(id&lt;ZIKTEditorDelegate&gt;)delegate completion:(void (^ __nullable)(void))completion;</div><div class="line">- (void)pushEditorViewForEditingNoteWithUUID:(NSString *)uuid title:(NSString *)title content:(NSString *)content delegate:(id&lt;ZIKTEditorDelegate&gt;)delegate;</div><div class="line">- (UIViewController *)editorViewForEditingNoteWithUUID:(NSString *)uuid title:(NSString *)title content:(NSString *)content delegate:(id&lt;ZIKTEditorDelegate&gt;)delegate;</div><div class="line">- (void)pushEditorViewController:(UIViewController *)destination fromViewController:(UIViewController *)source animated:(BOOL)animated;</div><div class="line">- (void)quitEditorViewWithAnimated:(BOOL)animated;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>Router则是由Application提供的具体路由技术，可以简单封装UIKit里的那些跳转方法，也可以用URL Router来执行路由。但是一个模块是不需要知道app使用的是什么具体技术的。Router才是真正连接各个模块的地方。它也负责寻找对应的目的模块，并且通过Buidler进行依赖注入。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@interface ZIKTRouter : NSObject &lt;ZIKTViperRouter&gt;</div><div class="line">///封装UIKit的跳转方法</div><div class="line">+ (void)pushViewController:(UIViewController *)destination fromViewController:(UIViewController *)source animated:(BOOL)animated;</div><div class="line">+ (void)popViewController:(UIViewController *)viewController animated:(BOOL)animated;</div><div class="line">+ (void)presentViewController:(UIViewController *)viewControllerToPresent fromViewController:(UIViewController *)source animated:(BOOL)animated completion:(void (^ __nullable)(void))completion;</div><div class="line">+ (void)dismissViewController:(UIViewController *)viewController animated:(BOOL)animated completion:(void (^ __nullable)(void))completion;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKTRouter (ZIKTEditor)</div><div class="line"></div><div class="line">+ (UIViewController *)viewForCreatingNoteWithDelegate:(id&lt;ZIKTEditorDelegate&gt;)delegate &#123;</div><div class="line">    return [ZIKTEditorBuilder viewForCreatingNoteWithDelegate:delegate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (UIViewController *)viewForEditingNoteWithUUID:(NSString *)uuid title:(NSString *)title content:(NSString *)content delegate:(id&lt;ZIKTEditorDelegate&gt;)delegate &#123;</div><div class="line">    return [ZIKTEditorBuilder viewForEditingNoteWithUUID:uuid title:title content:content delegate:delegate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>由Application实现，负责在模块通信时进行一些接口的转换，例如两个模块使用了相同业务功能的某个Service，使用的protocol实现一样，但是protocol名字不一样，就可以在路由时，在Adapter里进行一次转换。甚至只要定义的逻辑一样，依赖参数的名字和数据类型也可以允许不同。这样就能让模块不依赖于某个具体的protocol，而是依赖于protocol实际定义的依赖和接口。</p>
<p>注意这里的Adapter和Clean Architecture里的<code>Interface Adapter</code>是不一样的。这里的Adapter就是字面意义上的接口转换，而Clean Architecture里的<code>Interface Adapter</code>层更加抽象，是Use Case层与具体实现技术之间的转换，囊括了更多的角色。</p>
<h3 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h3><p>负责初始化整个模块，配置VIPER之间的关系，并对外声明模块需要的依赖，让外部执行注入。</p>
<h2 id="模块间解耦"><a href="#模块间解耦" class="headerlink" title="模块间解耦"></a>模块间解耦</h2><p>一个VIPER模块可以看做是一个独立的组件，可以被单独封装成一个库，被app引用。这时候，app就负责将各个模块连接起来，也就是图中灰色的<code>Application Context</code>部分。一个模块，肯定是存在于一个上下文环境中才能运行起来的。</p>
<p><code>Wireframe</code> -&gt; <code>Router</code> -&gt; <code>Adapter</code> -&gt; <code>Builder</code> 实现了一个完整的模块间路由，并且实现了模块间的解耦。</p>
<p>其中Wireframe和Builder是分别由引用者模块和被引用模块提供的，是两个模块的出口和入口，而Router和Adapter则是由模块的使用者——Application实现的。</p>
<p>当两个模块之间存在引用关系时，说明存在业务逻辑上的耦合，这种耦合是业务的一部分，是不可能消除的。我们能做的就是把耦合尽量交给模块调用者，由Application来提供具体的类，注入到各个模块之中，而模块内部只面向protocol即可。这样的话，被引用模块只要实现了相同的接口，就可以随时替换，甚至接口有一些差异时，只要被引用模块提供了相同功能的接口，也可以通过Adapter来做接口兼容转换，让引用者模块无需做任何修改。</p>
<p>Wireframe相当于插头，Builder相当于插座，而Router和Adapter相当于电路和转接头，将不同规格的插座和插头连接起来。把这些连接和适配的工作交给Application层，就能让两个模块实现各自独立。</p>
<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p>大部分方案都没有讨论子模块存在的情况。在VIPER里如何引入另一个VIPER模块？多个模块之间如何交互？子模块由谁初始化、由谁管理？</p>
<p>其他几个实现中，只有Uber较为详细地讨论了子模块的问题。在Uber的Riblets架构里，子模块的Router被添加到父模块的Router，模块之间通过delegate和监听的方式进行通信。这样做会让模块间产生一定的耦合。如果子模块是由于父View使用了一个子View控件而被引入的，那么父Interactor就会在代码里多出一个子Interactor，这样就导致了View的实现方式影响了Interactor的实现。</p>
<h3 id="子模块的来源"><a href="#子模块的来源" class="headerlink" title="子模块的来源"></a>子模块的来源</h3><p>子模块的来源有：</p>
<ul>
<li>View引用了一个封装好的子View控件，连带着引入了子View的整个VIPER</li>
<li>Interactor使用了一个Service</li>
</ul>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><p>子View可能是一个UIView，也可能是一个Child UIViewController。因此子View有可能需要向外部请求数据，也可能独立完成所有任务，不需要依赖父模块。</p>
<p>如果子View可以独立，那在子模块里不会出现和父模块交互的逻辑，只有把一些事件通过Output传递出去的接口。这时只需要把子View的接口封装在父View的接口里即可，父Presenter和父Interactor是不知道父View提供的这几个接口是通过子View实现的。这样父模块就能接收到子模块的事件了，而且能够保持Interactor和Presenter、View之间从低到高的依赖关系。</p>
<p>如果父模块需要调用子模块的某些功能，或者从子模块获取数据，可以选择封装到父View的接口里，不过如果涉及到数据模型，并且不想让数据模型出现在View的接口中，可以把子Interactor作为父Interactor的一个Service，在引入子模块时，通过父Builder注入到父Interactor里，或者根据依赖关系解耦地再彻底一点，注入到父Presenter里，让父Presenter再把接口转发给父Interactor。这样子模块和父模块就能通过Service的形式进行通信了，而这时，父Interactor也不知道这个Service是来自子模块里的。</p>
<p>在这样的设计下，子模块和父模块是不知道彼此的存在的，只是通过接口进行交互。好处是父View如果想要更换为另一个相同功能的子View控件，就只需要在父View里修改，不会影响Presenter和Interactor。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>这个VIPER的设计是通过接口将各个部分组合在一起的，一个类需要设置很多依赖，例如Interactor需要依赖许多Service。这就涉及到了两个问题：</p>
<ul>
<li>在哪里配置依赖</li>
<li>一个类怎么声明自己的依赖</li>
</ul>
<p>在这个方案中，由Builder声明整个模块的依赖，然后在Builder内部为不同的类设置依赖，外部在注入依赖时，就不必知道内部是怎么使用这些依赖参数的。一个类如果有必需的依赖参数，可以直接在init方法里体现，对于那些非必需的依赖，可以通过暴露接口来声明。</p>
<p>如果需要动态注入，而不是在模块初始化时就配置所有的依赖，Builder也可以提供动态注入的接口。</p>
<h2 id="映射到MVC"><a href="#映射到MVC" class="headerlink" title="映射到MVC"></a>映射到MVC</h2><p>如果你需要把一个模块从MVC重构到VIPER，可以先按照这个步骤：</p>
<ul>
<li>整理Controller中的代码，把不同职责的代码用pragma mark分隔好</li>
<li>整理好后，按照各部分的职责，将代码分散到VIPER的各个角色中，此时View、Presenter、Interactor之间可以直接互相引用</li>
<li>把View、Presenter、Interactor进行解耦，抽出接口，互相之间依赖接口进行交互</li>
</ul>
<p>下面就是第一步里在Controller中可以分隔出的职责：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">//------View-------</div><div class="line"></div><div class="line">//View的生命周期</div><div class="line">#pragma mark View life</div><div class="line"></div><div class="line">//View的配置，包括布局设置</div><div class="line">#pragma mark View config</div><div class="line"></div><div class="line">//更新View的接口</div><div class="line">#pragma mark Update view</div><div class="line"></div><div class="line">//View需要从model中获取的数据</div><div class="line">#pragma mark Request view data source</div><div class="line"></div><div class="line">//监控、接收View的事件</div><div class="line">#pragma mark Send view event</div><div class="line"></div><div class="line">//------Presenter-------</div><div class="line"></div><div class="line">//处理View的事件</div><div class="line">#pragma mark Handle view event</div><div class="line"></div><div class="line">//界面跳转</div><div class="line">#pragma mark Wireframe</div><div class="line"></div><div class="line">//向View提供配置用的数据</div><div class="line">#pragma mark Provide view data source</div><div class="line"></div><div class="line">//提供生成model需要的数据</div><div class="line">#pragma mark Provide model data source</div><div class="line"></div><div class="line">//处理业务事件，调用业务用例</div><div class="line">#pragma mark Handle business event</div><div class="line"></div><div class="line">//------Interactor-------</div><div class="line"></div><div class="line">//监控、接收业务事件</div><div class="line">#pragma mark Send business event</div><div class="line"></div><div class="line">//业务用例</div><div class="line">#pragma mark Business use case</div><div class="line"></div><div class="line">//获取生成model需要的数据</div><div class="line">#pragma mark Request data for model</div><div class="line"></div><div class="line">//维护model</div><div class="line">#pragma mark Manage model</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里缺少了View状态管理、业务状态管理等职责，因为这些状态一般都是@property，用pragma mark不能分隔它们，只能在@interface里声明的时候进行隔离。</p>
<h2 id="方案二：允许适当耦合"><a href="#方案二：允许适当耦合" class="headerlink" title="方案二：允许适当耦合"></a>方案二：允许适当耦合</h2><p>上面的方案是以最彻底的解耦为目标设计的，在实践中，如果真的完全按照这个设计，代码量的确不小。其实一些地方的耦合并不会引起多大问题，除非你的模块需要封装成通用组件供多个app使用，否则并不需要按照100%的解耦要求来编写。因此接下来我再总结一个稍微简化的方案，总结一下各部分可以在哪些地方出现耦合，哪些耦合不能出现。</p>
<p>在这个方案里，我使用了一个中介者来减少一部分代码，Router就是一个很适合成为中介者的角色。</p>
<p>架构图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-2a5e4eaf6275caba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="final_viper"></p>
<h3 id="View-1"><a href="#View-1" class="headerlink" title="View"></a>View</h3><ul>
<li>View可以直接通过Router引入另一个子View，不需要通过Presenter的路由来引入</li>
<li>View中的一些delegate如果变化的可能性不大，可以直接让Presenter实现（例如<code>UITableViewDataSource</code>），不用再封装一遍后交给Presenter</li>
<li>View不能出现Model类</li>
</ul>
<h3 id="Presenter-1"><a href="#Presenter-1" class="headerlink" title="Presenter"></a>Presenter</h3><ul>
<li>Presenter可以直接调用Router执行路由，不用再通过Wireframe封装一遍</li>
<li>Presenter的接口参数中可以出现Model类，但是不能导入Model类的头文件并且使用Model类，只能用于参数传递</li>
<li>Presenter中不建议导入UIKit，除非能保证不会使用那些会影响控件渲染的方法</li>
</ul>
<h3 id="Interactor-1"><a href="#Interactor-1" class="headerlink" title="Interactor"></a>Interactor</h3><ul>
<li>一些app中常用的Service可以直接引入，不需要通过外部注入的方式来使用</li>
<li>Interactor可以用一个Service Router来动态获取Service</li>
</ul>
<h3 id="路由和依赖注入"><a href="#路由和依赖注入" class="headerlink" title="路由和依赖注入"></a>路由和依赖注入</h3><p>改变得最多的就是路由部分。View、Presenter和Interactor都可以使用路由来获取一些模块。View可以通过路由获取子View，Presenter可以通过路由获取其他View模块，Interactor可以通过路由获取Service。</p>
<p>在实现时，可以把Wireframe、Router、Builder整合到一起，全都放到Router里，Router由模块实现并提供给外部使用。类似于Brigade团队和Rambler&amp;Co团队的实现。但是他们的实现都是直接在Router里引入其他模块的Router，这样会导致依赖混乱，更好的方式是通过一个中间人统一提供其他模块的接口。</p>
<p>我在这里造了个轮子，通过protocol来寻找需要的模块并执行路由，不用直接导入目的模块中的类，并且提供了Adapter的支持，可以让多个protocol指向同一个模块。这样就能避免模块间的直接依赖。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">///editor模块的依赖声明</div><div class="line">@protocol NoteEditorProtocol &lt;NSObject&gt;</div><div class="line">@property (nonatomic, weak) id&lt;ZIKEditorDelegate&gt; delegate;</div><div class="line">- (void)constructForCreatingNewNote;</div><div class="line">- (void)constructForEditingNote:(ZIKNoteModel *)note;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKNoteListViewPresenter</div><div class="line"></div><div class="line">- (void)handleDidSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSAssert([[self.view routeSource] isKindOfClass:[UIViewController class]], nil);</div><div class="line">    </div><div class="line">    //跳转到编辑器界面；通过protocol获取对应的router类，再通过protocol注入依赖</div><div class="line">    //App可以用Adapter把NoteEditorProtocol和真正的protocol进行匹配和转接</div><div class="line">    [ZIKViewRouterToModule(NoteEditorProtocol)</div><div class="line">true     performWithConfigure:^(ZIKViewRouteConfiguration&lt;NoteEditorProtocol&gt; *config) &#123;</div><div class="line">true         //路由配置</div><div class="line">true         //跳转的源界面</div><div class="line">true         config.source = [self.view routeSource];</div><div class="line">true         //设置跳转方式，支持所有界面跳转类型</div><div class="line">true         config.routeType = ZIKViewRouteTypePush;</div><div class="line">true         //Router内部负责用获取到的参数初始化editor模块</div><div class="line">true         config.delegate = self;</div><div class="line">true         [config constructForEditingNote:[self.interactor noteAtIndex:indexPath.row]];</div><div class="line">true         config.prepareForRoute = ^(id destination) &#123;</div><div class="line">true             //跳转前配置目的界面</div><div class="line">true         &#125;;</div><div class="line">true         config.routeCompletion = ^(id destination) &#123;</div><div class="line">true             //跳转结束处理</div><div class="line">true         &#125;;</div><div class="line">true         config.performerErrorHandler = ^(SEL routeAction, NSError * error) &#123;</div><div class="line">true             //跳转失败处理</div><div class="line">true         &#125;;</div><div class="line">true     &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这个方案依赖于一个统一的中间人，也就是路由工具，在我的实现里就是<a href="https://github.com/Zuikyo/ZIKRouter" target="_blank" rel="external">ZIKRouter</a>。View、Presenter、Interactor都可以使用对应功能的Router获取子模块。而由于ZIKRouter仍然是通过protocol的方式来和子模块进行交互，因此仍然可保持模块间解耦。唯一的耦合就是各部分都引用了ZIKRouter这个工具。如果你想把模块和ZIKRouter的耦合也去除，可以让Router也变成面向接口，由外部注入。</p>
<h2 id="Demo和代码模板"><a href="#Demo和代码模板" class="headerlink" title="Demo和代码模板"></a>Demo和代码模板</h2><p>针对两个方案，同时写了两个相同功能的Demo，可以比较一下代码上的区别。地址在：<a href="https://github.com/Zuikyo/ZIKViper" target="_blank" rel="external">ZIKViper</a></p>
<p>项目里也提供了Xcode File Template用于快速生成VIPER代码模板。把<code>.xctemplate</code>后缀的文件夹拷贝到<code>~/Library/Developer/Xcode/Templates/</code>目录下，就可以在Xcode的<code>New-&gt;File-&gt;Template</code>里选择代码模板快速生成代码。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>VIPER是按照Clean Architecture中由外向内的依赖进行设计的，各部分职责十分明确。并且由于引入了路由部分，更容易支持组件化开发。</p>
<p>下一篇文章将讨论基于接口的路由设计，总结UIKit中的各种视图转场，并讲解ZIKRouter的实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework" target="_blank" rel="external">MEET VIPER: MUTUAL MOBILE’S APPLICATION OF CLEAN ARCHITECTURE FOR IOS APPS</a></li>
<li><a href="https://www.objc.io/issues/13-architecture/viper/" target="_blank" rel="external">Architecting iOS Apps with VIPER</a></li>
<li><a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">Clean Architecture</a></li>
<li><a href="https://brigade.engineering/brigades-experience-using-an-mvc-alternative-36ef1601a41f" target="_blank" rel="external">Brigade’s Experience Using an MVC Alternative: VIPER architecture for iOS applications</a></li>
<li><a href="https://swifting.io/blog/2016/03/07/8-viper-to-be-or-not-to-be/" target="_blank" rel="external">VIPER to be or not to be?</a></li>
<li><a href="https://cheesecakelabs.com/blog/best-practices-viper-architecture/" target="_blank" rel="external">VIPER architecture: Our best practices to build an app like a boss</a></li>
<li><a href="https://github.com/strongself/The-Book-of-VIPER" target="_blank" rel="external">The-Book-of-VIPER</a></li>
<li><a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="external">ENGINEERING THE ARCHITECTURE BEHIND UBER’S NEW RIDER APP</a></li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag">#iOS</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/21/iOS VIPER架构实践(一)：从MVC到MVVM到VIPER/" rel="next" title="iOS VIPER架构实践(一)：从MVC到MVVM到VIPER">
                <i class="fa fa-chevron-left"></i> iOS VIPER架构实践(一)：从MVC到MVVM到VIPER
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/27/iOS VIPER架构实践(三)：基于接口的路由设计/" rel="prev" title="iOS VIPER架构实践(三)：面向接口的路由设计">
                iOS VIPER架构实践(三)：面向接口的路由设计 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

          
  <div class="comments" id="comments">
    
      <div id="gitalk-container"></div>
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="zuik" />
          <p class="site-author-name" itemprop="name">zuik</p>
          <p class="site-description motion-element" itemprop="description">🐼</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#起源"><span class="nav-number">1.</span> <span class="nav-text">起源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Clean-Architecture"><span class="nav-number">2.</span> <span class="nav-text">Clean Architecture</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Enterprise-Business-Rules"><span class="nav-number">2.1.</span> <span class="nav-text">Enterprise Business Rules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Application-Business-Rules"><span class="nav-number">2.2.</span> <span class="nav-text">Application Business Rules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interface-Adapters"><span class="nav-number">2.3.</span> <span class="nav-text">Interface Adapters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Frameworks-amp-Drivers"><span class="nav-number">2.4.</span> <span class="nav-text">Frameworks & Drivers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">2.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#现有的各种VIPER实现"><span class="nav-number">3.</span> <span class="nav-text">现有的各种VIPER实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Brigade团队的实现"><span class="nav-number">3.1.</span> <span class="nav-text">Brigade团队的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#争议"><span class="nav-number">3.1.1.</span> <span class="nav-text">争议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rambler-amp-Co团队的实现"><span class="nav-number">3.2.</span> <span class="nav-text">Rambler&Co团队的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#争议-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">争议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Uber团队的实现"><span class="nav-number">3.3.</span> <span class="nav-text">Uber团队的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#各部分职责"><span class="nav-number">3.3.1.</span> <span class="nav-text">各部分职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据驱动"><span class="nav-number">3.3.2.</span> <span class="nav-text">数据驱动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#争议-2"><span class="nav-number">3.3.3.</span> <span class="nav-text">争议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他设计"><span class="nav-number">3.3.4.</span> <span class="nav-text">其他设计</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方案一：最完整的VIPER"><span class="nav-number">4.</span> <span class="nav-text">方案一：最完整的VIPER</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#View"><span class="nav-number">4.1.</span> <span class="nav-text">View</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Presenter"><span class="nav-number">4.2.</span> <span class="nav-text">Presenter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interactor"><span class="nav-number">4.3.</span> <span class="nav-text">Interactor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Service"><span class="nav-number">4.4.</span> <span class="nav-text">Service</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Wireframe"><span class="nav-number">4.5.</span> <span class="nav-text">Wireframe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Router"><span class="nav-number">4.6.</span> <span class="nav-text">Router</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Adapter"><span class="nav-number">4.7.</span> <span class="nav-text">Adapter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Builder"><span class="nav-number">4.8.</span> <span class="nav-text">Builder</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块间解耦"><span class="nav-number">5.</span> <span class="nav-text">模块间解耦</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子模块"><span class="nav-number">6.</span> <span class="nav-text">子模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#子模块的来源"><span class="nav-number">6.1.</span> <span class="nav-text">子模块的来源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通信方式"><span class="nav-number">6.2.</span> <span class="nav-text">通信方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#依赖注入"><span class="nav-number">7.</span> <span class="nav-text">依赖注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#映射到MVC"><span class="nav-number">8.</span> <span class="nav-text">映射到MVC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方案二：允许适当耦合"><span class="nav-number">9.</span> <span class="nav-text">方案二：允许适当耦合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#View-1"><span class="nav-number">9.1.</span> <span class="nav-text">View</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Presenter-1"><span class="nav-number">9.2.</span> <span class="nav-text">Presenter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interactor-1"><span class="nav-number">9.3.</span> <span class="nav-text">Interactor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由和依赖注入"><span class="nav-number">9.4.</span> <span class="nav-text">路由和依赖注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">9.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Demo和代码模板"><span class="nav-number">10.</span> <span class="nav-text">Demo和代码模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-2"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">12.</span> <span class="nav-text">参考</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zuik</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

<script>
(function(){
var bp = document.createElement('script');
bp.src = '//zz.bdstatic.com/linksubmit/push.js';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(bp, s);
})();
</script>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/libs/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/libs/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/libs/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/libs/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/libs/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/libs/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
    
      <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
      <script type="text/javascript">
        const gitalk = new Gitalk({
          clientID: '348b65b1168d7aa48b08',
          clientSecret: '6a87660b699abe603eac61c471ab5781fd27fc03',
          repo: 'Zuikyo.github.io',
          owner: 'Zuikyo',
          admin: 'Zuikyo'.split(','),
          id: '1502441729000',
          pagerDirection: 'first',
          // facebook-like distraction free mode
          distractionFreeMode: false
        })
        gitalk.render('gitalk-container')
      </script>
    
  

  
  

  

  

  

</body>
</html>
