<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🐼黑超熊猫zuik&#39;s blog</title>
  <subtitle>iOS 开发修行之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zuikyo.github.io/"/>
  <updated>2019-07-14T17:38:41.090Z</updated>
  <id>http://zuikyo.github.io/</id>
  
  <author>
    <name>zuik</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>打造完备的iOS组件化方案：如何面向接口进行模块解耦</title>
    <link href="http://zuikyo.github.io/2019/07/15/iOS_inrerface_orientation_modularization/"/>
    <id>http://zuikyo.github.io/2019/07/15/iOS_inrerface_orientation_modularization/</id>
    <published>2019-07-14T17:33:00.000Z</published>
    <updated>2019-07-14T17:38:41.090Z</updated>
    
    <content type="html"><![CDATA[<p>关于组件化的探讨已经有不少了，在之前的文章”iOS VIPER架构实践(三)：面向接口的路由设计”中，综合比较了各种方案后，我倾向于使用面向接口的方式进行组件化。</p>
<p>这是一篇从代码层面讲解模块解耦的文章，会全方位地展示如何实践面向接口的思想，尽量全面地探讨在模块管理和解耦的过程中，需要考虑到的各种问题，并且给出实际的解决方案，以及对应的模块管理开源工具：<a href="https://github.com/Zuikyo/ZIKRouter" target="_blank" rel="external">ZIKRouter</a>。你也可以根据本文的内容改造自己现有的方案。</p>
<p>文章主要内容：</p>
<ul>
<li>如何衡量模块解耦的程度</li>
<li>对比不同方案的优劣</li>
<li>在编译时进行静态路由检查，避免使用不存在的模块</li>
<li>如何进行模块解耦，包括模块重用、模块适配、模块间通信、子模块交互</li>
<li>模块的接口和依赖管理</li>
<li>管理界面跳转逻辑</li>
</ul>
<h2 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h2><p>将模块单独抽离、分层，并制定模块间通信的方式，从而实现解耦，以及适应团队开发。</p>
<h2 id="为什么需要组件化"><a href="#为什么需要组件化" class="headerlink" title="为什么需要组件化"></a>为什么需要组件化</h2><p>主要有4个原因：</p>
<ul>
<li>模块间解耦</li>
<li>模块重用</li>
<li>提高团队协作开发效率</li>
<li>单元测试</li>
</ul>
<p>当项目越来越大的时候，各个模块之间如果是直接互相引用，就会产生许多耦合，导致接口滥用，当某天需要进行修改时，就会牵一发而动全身，难以维护。</p>
<p>问题主要体现在：</p>
<ul>
<li>修改某个模块的功能时，需要修改许多其他模块的代码，因为这个模块被其他模块引用</li>
<li>模块对外的接口不明确，外部甚至会调用不应暴露的私有接口，修改时会耗费大量时间</li>
<li>修改的模块涉及范围较广，很容易影响其他团队成员的开发，产生代码冲突</li>
<li>当需要抽离模块到其他地方重用时，会发现耦合导致根本无法单独抽离</li>
<li>模块间的耦合导致接口和依赖混乱，难以编写单元测试</li>
</ul>
<p>所以需要减少模块之间的耦合，用更规范的方式进行模块间交互。这就是组件化，也可以叫做模块化。</p>
<h2 id="你的项目是否需要组件化"><a href="#你的项目是否需要组件化" class="headerlink" title="你的项目是否需要组件化"></a>你的项目是否需要组件化</h2><p>组件化也不是必须的，有些情况下并不需要组件化：</p>
<ul>
<li>项目较小，模块间交互简单，耦合少</li>
<li>模块没有被多个外部模块引用，只是一个单独的小模块</li>
<li>模块不需要重用，代码也很少被修改</li>
<li>团队规模很小</li>
<li>不需要编写单元测试</li>
</ul>
<p>组件化也是有一定成本的，你需要花时间设计接口，分离代码，所以并不是所有的模块都需要组件化。</p>
<p>不过，当你发现这几个迹象时，就需要考虑组件化了：</p>
<ul>
<li>模块逻辑复杂，多个模块间频繁互相引用</li>
<li>项目规模逐渐变大，修改代码变得越来越困难</li>
<li>团队人数变多，提交的代码经常和其他成员冲突</li>
<li>项目编译耗时较大</li>
<li>模块的单元测试经常由于其他模块的修改而失败</li>
</ul>
<h2 id="组件化方案的8条指标"><a href="#组件化方案的8条指标" class="headerlink" title="组件化方案的8条指标"></a>组件化方案的8条指标</h2><p>决定了要开始组件化之路后，就需要思考我们的目标了。一个组件化方案需要达到怎样的效果呢？我在这里给出8个理想情况下的指标：</p>
<ol>
<li>模块间没有直接耦合，一个模块内部的修改不会影响到另一个模块</li>
<li>模块可以被单独编译</li>
<li>模块间能够清晰地进行数据传递</li>
<li>模块可以随时被另一个提供了相同功能的模块替换</li>
<li>模块的对外接口容易查找和维护</li>
<li>当模块的接口改变时，使用此模块的外部代码能够被高效地重构</li>
<li>尽量用最少的修改和代码，让现有的项目实现模块化</li>
<li>支持 Objective-C 和 Swift，以及混编</li>
</ol>
<p>前4条用于衡量一个模块是否真正解耦，后4条用于衡量在项目实践中的易用程度。最后一条必须支持 Swift，是因为 Swift 是一个必然的趋势，如果你的方案不支持 Swift，说明这个方案在将来的某个时刻必定要改进改变，而到时候所有基于这个方案实现的模块都会受到影响。</p>
<p>基于这8个指标，我们就能在一定程度上对我们的方案做出衡量了。</p>
<h2 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h2><p>现在主要有3种组件化方案：URL 路由、target-action、protocol 匹配。</p>
<p>接下来我们就比较一下这几种组件化方案，看看它们各有什么优缺点。这部分在之前的文章中已经探讨过，这里再重新比较一次，补充一些细节。必须要先说明的是，没有一个完美的方案能满足所有场景下的需求，需要根据每个项目的需求选择最适合的方案。</p>
<h3 id="URL-路由"><a href="#URL-路由" class="headerlink" title="URL 路由"></a>URL 路由</h3><p>目前 iOS 上绝大部分的路由工具都是基于 URL 匹配的，或者是根据命名约定，用 runtime 方法进行动态调用。</p>
<p>这些动态化的方案的优点是实现简单，缺点是需要维护字符串表，或者依赖于命名约定，无法在编译时暴露出所有问题，需要在运行时才能发现错误。</p>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 注册某个URL</div><div class="line">[URLRouter registerURL:@&quot;app://editor&quot; handler:^(NSDictionary *userInfo) &#123;</div><div class="line">    UIViewController *editorViewController = [[EditorViewController alloc] initWithParam:userInfo];</div><div class="line">    return editorViewController;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 调用路由</div><div class="line">[URLRouter openURL:@&quot;app://editor/?debug=true&quot; completion:^(NSDictionary *info) &#123;</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>URL router 的优点：</p>
<ul>
<li>极高的动态性，适合经常开展运营活动的 app，例如电商</li>
<li>方便地统一管理多平台的路由规则</li>
<li>易于适配 URL Scheme</li>
</ul>
<p>URL router 的缺点：</p>
<ul>
<li>传参方式有限，并且无法利用编译器进行参数类型检查，因此所有的参数都只能从字符串中转换而来</li>
<li>只适用于界面模块，不适用于通用模块</li>
<li>不能使用 designated initializer 声明必需参数</li>
<li>要让 view controller 支持 url，需要为其新增初始化方法，因此需要对模块做出修改</li>
<li>不支持 storyboard</li>
<li>无法明确声明模块提供的接口，只能依赖于接口文档，重构时无法确保修改正确</li>
<li>依赖于字符串硬编码，难以管理</li>
<li>无法保证所使用的模块一定存在</li>
<li>解耦能力有限，url 的”注册”、”实现”、”使用”必须用相同的字符规则，一旦任何一方做出修改都会导致其他方的代码失效，并且重构难度大</li>
</ul>
<h4 id="字符串解耦的问题"><a href="#字符串解耦的问题" class="headerlink" title="字符串解耦的问题"></a>字符串解耦的问题</h4><p>如果用上面的8个指标来衡量，URL 路由只能满足”支持模块单独编译”、”支持 OC 和 Swift”两条。它的解耦程度非常一般。</p>
<p>所有基于字符串的解耦方案其实都可以说是伪解耦，它们只是放弃了编译依赖，但是当代码变化之后，即便能够编译运行，逻辑仍然是错误的。</p>
<p>例如修改了模块定义时的 URL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 注册某个URL</div><div class="line">[URLRouter registerURL:@&quot;app://editorView&quot; handler:^(NSDictionary *userInfo) &#123;</div><div class="line">    ...</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>那么调用者的 URL 也必须修改，代码仍然是有耦合的，只不过此时编译器无法检查而已。这会导致维护更加困难，一旦 URL 中的参数有了增减，或者决定替换为另一个模块，参数命名有了变化，几乎没有高效的方式来重构代码。可以使用宏定义来管理字符串，不过这要求所有模块都使用同一个头文件，并且也无法解决参数类型和数量变化的问题。</p>
<p>URL 路由适合用来做远程模块的网络协议交互，而在管理本地模块时，最大的甚至是唯一的优势，就是适合经常跨多端运营活动的 app，因为可以由运营人员统一管理多平台的路由规则。</p>
<h4 id="代表框架"><a href="#代表框架" class="headerlink" title="代表框架"></a>代表框架</h4><ul>
<li><a href="https://github.com/clayallsopp/routable-ios" target="_blank" rel="external">routable-ios</a></li>
<li><a href="https://github.com/joeldev/JLRoutes" target="_blank" rel="external">JLRoutes</a></li>
<li><a href="https://github.com/meili/MGJRouter" target="_blank" rel="external">MGJRouter</a></li>
<li><a href="https://github.com/lightory/HHRouter" target="_blank" rel="external">HHRouter</a></li>
</ul>
<h4 id="改进：避免字符串管理"><a href="#改进：避免字符串管理" class="headerlink" title="改进：避免字符串管理"></a>改进：避免字符串管理</h4><p>改进 URL 路由的方式，就是避免使用字符串，通过接口管理模块。</p>
<p>参数可以通过 protocol 直接传递，能够利用编译器检查参数类型，并且在 ZIKRouter 中，能通过路由声明和编译检查，保证所使用的模块一定存在。在为模块创建路由时，也无需修改模块的代码。</p>
<p>但是必须要承认的是，尽管 URL 路由缺点多多，但它在跨平台路由管理上的确是最适合的方案。因此 ZIKRouter 也对 URL 路由做出了支持，在用 protocol 管理的同时，可以通过字符串匹配 router，也能和其他 URL router 框架对接。</p>
<h3 id="Target-Action-方案"><a href="#Target-Action-方案" class="headerlink" title="Target-Action 方案"></a>Target-Action 方案</h3><p>有一些模块管理工具基于 Objective-C 的 runtime、category 特性动态获取模块。例如通过<code>NSClassFromString</code>获取类并创建实例，通过<code>performSelector:</code> <code>NSInvocation</code>动态调用方法。</p>
<p>例如基于 target-action 模式的设计，大致是利用 category 为路由工具添加新接口，在接口中通过字符串获取对应的类，再用 runtime 创建实例，动态调用实例的方法。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 模块管理者，提供了动态调用 target-action 的基本功能</div><div class="line">@interface Mediator : NSObject</div><div class="line"></div><div class="line">+ (instancetype)sharedInstance;</div><div class="line"></div><div class="line">- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 在 category 中定义新接口</div><div class="line">@interface Mediator (ModuleActions)</div><div class="line">- (UIViewController *)Mediator_editorViewController;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Mediator (ModuleActions)</div><div class="line"></div><div class="line">- (UIViewController *)Mediator_editorViewController &#123;</div><div class="line">    // 使用字符串硬编码，通过 runtime 动态创建 Target_Editor，并调用 Action_viewController:</div><div class="line">    UIViewController *viewController = [self performTarget:@&quot;Editor&quot; action:@&quot;viewController&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;];</div><div class="line">    return viewController;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line">  </div><div class="line">// 调用者通过 Mediator 的接口调用模块</div><div class="line">UIViewController *editor = [[Mediator sharedInstance] Mediator_editorViewController];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 模块提供者提供 target-action 的调用方式</div><div class="line">@interface Target_Editor : NSObject</div><div class="line">- (UIViewController *)Action_viewController:(NSDictionary *)params;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Target_Editor</div><div class="line"></div><div class="line">- (UIViewController *)Action_viewController:(NSDictionary *)params &#123;</div><div class="line">    // 参数通过字典传递，无法保证类型安全</div><div class="line">    EditorViewController *viewController = [[EditorViewController alloc] init];</div><div class="line">    viewController.valueLabel.text = params[@&quot;key&quot;];</div><div class="line">    return viewController;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>利用 category 可以明确声明接口，进行编译检查</li>
<li>实现方式轻量</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要在 mediator 和 target 中重新添加每一个接口，模块化时代码较为繁琐</li>
<li>在 category 中仍然引入了字符串硬编码，内部使用字典传参，一定程度上也存在和 URL 路由相同的问题</li>
<li>无法保证所使用的模块一定存在，target 模块在修改后，使用者只有在运行时才能发现错误</li>
<li>过于依赖 runtime 特性，无法应用到纯 Swift 上。在 Swift 中扩展 mediator 时，无法使用纯 Swift 类型的参数</li>
<li>可能会创建过多的 target 类</li>
<li>使用 runtime 相关的接口调用任意类的任意方法，需要注意别被苹果的审核误伤。参考：<a href="https://stackoverflow.com/questions/42662028/are-performselector-and-respondstoselector-banned-by-app-store" target="_blank" rel="external">Are performSelector and respondsToSelector banned by App Store?</a></li>
</ul>
<h4 id="字典传参的问题"><a href="#字典传参的问题" class="headerlink" title="字典传参的问题"></a>字典传参的问题</h4><p>字典传参时无法保证参数的数量和类型，只能依赖调用约定，就和字符串传参一样，一旦某一方做出修改，另一方也必须修改。</p>
<p>相比于 URL 路由，target-action 通过 category 的接口把字符串管理的问题缩小到了 mediator 内部，不过并没有完全消除，而且在其他方面仍然有很多改进空间。上面的8个指标中其实只能满足第2个”支持模块单独编译”，另外在和接口相关的第3、5、6点上，比 URL 路由要有改善。</p>
<h4 id="代表框架-1"><a href="#代表框架-1" class="headerlink" title="代表框架"></a>代表框架</h4><p><a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">CTMediator</a></p>
<h4 id="改进：避免字典传参"><a href="#改进：避免字典传参" class="headerlink" title="改进：避免字典传参"></a>改进：避免字典传参</h4><p>Target-Action 方案最大的优点就是整个方案实现轻量，并且也一定程度上明确了模块的接口。只是这些接口都需要通过 Target-Action 封装一次，并且每个模块都要创建一个 target 类，既然如此，直接用 protocol 进行接口管理会更加简单。</p>
<p>ZIKRouter 避免使用 runtime 获取和调用模块，因此可以适配 OC 和 swift。同时，基于 protocol 匹配的方式，避免引入字符串硬编码，能够更好地管理模块，也避免了字典传参。</p>
<h3 id="基于-protocol-匹配的方案"><a href="#基于-protocol-匹配的方案" class="headerlink" title="基于 protocol 匹配的方案"></a>基于 protocol 匹配的方案</h3><p>有一些模块管理工具或者依赖注入工具，也实现了基于接口的管理方式。实现思路是将 protocol 和对应的类进行字典匹配，之后就可以用 protocol 获取 class，再动态创建实例。</p>
<p>BeeHive 示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 注册模块 (protocol-class 匹配)</div><div class="line">[[BeeHive shareInstance] registerService:@protocol(EditorViewProtocol) service:[EditorViewController class]];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 获取模块 (用 runtime 创建 EditorViewController 实例)</div><div class="line">id&lt;EditorViewProtocol&gt; editor = [[BeeHive shareInstance] createService:@protocol(EditorViewProtocol)];</div></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>利用接口调用，实现了参数传递时的类型安全</li>
<li>直接使用模块的 protocol 接口，无需再重复封装</li>
</ul>
<p>缺点：</p>
<ul>
<li>由框架来创建所有对象，创建方式有限，例如不支持外部传入参数，再调用自定义初始化方法</li>
<li>用 OC runtime 创建对象，不支持 Swift</li>
<li>只做了 protocol 和 class 的匹配，不支持更复杂的创建方式和依赖注入</li>
<li>无法保证所使用的 protocol 一定存在对应的模块，也无法直接判断某个 protocol 是否能用于获取模块</li>
</ul>
<p>相比直接 protocol-class 匹配的方式，protocol-block 的方式更加易用。例如 Swinject。</p>
<p>Swinject 示例代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> container = <span class="type">Container</span>()</div><div class="line"></div><div class="line"><span class="comment">// 注册模块</span></div><div class="line">container.register(<span class="type">EditorViewProtocol</span>.<span class="keyword">self</span>) &#123; <span class="number">_</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> <span class="type">EditorViewController</span>()</div><div class="line">&#125;</div><div class="line"><span class="comment">// 获取模块</span></div><div class="line"><span class="keyword">let</span> editor = container.resolve(<span class="type">EditorViewProtocol</span>.<span class="keyword">self</span>)!</div></pre></td></tr></table></figure>
<h4 id="代表框架-2"><a href="#代表框架-2" class="headerlink" title="代表框架"></a>代表框架</h4><p><a href="https://github.com/alibaba/BeeHive" target="_blank" rel="external">BeeHive</a></p>
<p><a href="https://github.com/Swinject/Swinject" target="_blank" rel="external">Swinject</a></p>
<h4 id="改进：离散式管理"><a href="#改进：离散式管理" class="headerlink" title="改进：离散式管理"></a>改进：离散式管理</h4><p>BeeHive 这种方式和 ZIKRouter 的思路类似，但是所有的模块在注册后，都是由 BeeHive 单例来创建，使用场景十分有限，例如不支持纯 Swift 类型，不支持使用自定义初始化方法以及额外的依赖注入。 </p>
<p>ZIKRouter 进行了进一步的改进，并不是直接对 protocol 和 class 进行匹配，而是将 protocol 和 router 子类或者 router 对象进行匹配，在 router 子类中再提供创建模块的实例的方式。这时，模块的创建职责就从 BeeHive 单例上转到了每个单独的 router 上，从集约型变成了离散型，扩展性进一步提升。</p>
<h2 id="Protocol-Router-匹配方案"><a href="#Protocol-Router-匹配方案" class="headerlink" title="Protocol-Router 匹配方案"></a>Protocol-Router 匹配方案</h2><p>变成 protocol-router 匹配后，代码将会变成这样：</p>
<p>一个 router 父类提供基础的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZIKViewRouter</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 获取模块</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">makeDestination</span> -&gt; <span class="title">Any</span>? </span>&#123;</div><div class="line">        <span class="keyword">let</span> router = <span class="keyword">self</span>.<span class="keyword">init</span>(with: <span class="type">ViewRouteConfig</span>())</div><div class="line">        <span class="keyword">return</span> router.destination(with: router.configuration) </div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 让子类重写</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">Any</span>? &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZIKViewRouter</span>: <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZIKViewRouter</span></span></div><div class="line">  </div><div class="line">...</div><div class="line"><span class="comment">// 获取模块</span></div><div class="line">+ (<span class="keyword">id</span>)makeDestination &#123;</div><div class="line">    ZIKViewRouter *router = [<span class="keyword">self</span> alloc] initWithConfiguration:[ZIKViewRouteConfiguration new]];</div><div class="line">    <span class="keyword">return</span> [router destinationWithConfiguration:router.configuration];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 让子类重写</span></div><div class="line">- (<span class="keyword">id</span>)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>每个模块各自编写自己的 router 子类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span> </span>&#123;</div><div class="line">    <span class="comment">// 子类重写，创建模块</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">Any</span>? &#123;</div><div class="line">        <span class="keyword">let</span> destination = <span class="type">EditorViewController</span>()</div><div class="line">        <span class="keyword">return</span> destination</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewRouter</span> : <span class="title">ZIKViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewRouter</span></span></div><div class="line"></div><div class="line"><span class="comment">// 子类重写，创建模块</span></div><div class="line">- (EditorViewController *)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    EditorViewController *destination = [[EditorViewController alloc] init];</div><div class="line">    <span class="keyword">return</span> destination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>把 protocol 和 router 类进行注册绑定：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">EditorViewRouter</span>.register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;())</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册 protocol 和 router</span></div><div class="line">[EditorViewRouter registerViewProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">EditorViewProtocol</span>)];</span></div></pre></td></tr></table></figure><br><br></details>

<p>然后就可以用 protocol 获取 router 类，再进一步获取模块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取模块的 router 类</span></div><div class="line"><span class="keyword">let</span> routerClass = <span class="type">Router</span>.to(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;())</div><div class="line"><span class="comment">// 获取 EditorViewProtocol 模块</span></div><div class="line"><span class="keyword">let</span> destination = routerClass?.makeDestination()</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取模块的 router 类</span></div><div class="line">Class routerClass = ZIKViewRouter.toView(<span class="class"><span class="keyword">@protocol</span>(<span class="title">EditorViewProtocol</span>));</span></div><div class="line"><span class="comment">// 获取 EditorViewProtocol 模块</span></div><div class="line"><span class="keyword">id</span>&lt;EditorViewProtocol&gt; destination = [routerClass makeDestination];</div></pre></td></tr></table></figure><br><br></details>

<p>加了一层 router 中间层之后，解耦能力一下子就增强了：</p>
<ul>
<li>可以在 router 上添加许多通用的扩展接口，例如创建模块、依赖注入、界面跳转、界面移除，甚至增加 URL 路由支持</li>
<li>在每个 router 子类中可以进行更详细的依赖注入和自定义操作</li>
<li>可以自定义创建对象的方式，例如自定义初始化方法、工厂方法，在重构时可以直接搬运现有的创建代码，无需在原来的类上增加或修改接口，减少模块化过程中的工作量</li>
<li>可以让多个 protocol 和同一个模块进行匹配</li>
<li>可以让模块进行接口适配，允许外部做完适配后，为 router 添加新的 protocol，解决编译依赖的问题</li>
<li>返回的对象只需符合 protocol，不再和某个单一的类绑定。因此可以根据条件，返回不同的对象，例如适配不同系统版本时，返回不同的控件，让外部只关注接口</li>
</ul>
<h2 id="动态化的风险"><a href="#动态化的风险" class="headerlink" title="动态化的风险"></a>动态化的风险</h2><p>大部分组件化方案都会带来一个问题，就是减弱甚至抛弃编译检查，因为模块已经变得高度动态化了。</p>
<p>当调用一个模块时，怎么能保证这个模块一定存在？直接引用类时，如果类不存在，编译器会给出引用错误，但是动态组件就无法在静态时检查了。</p>
<p>例如 URL 地址变化了，但是代码中的某些 URL 没有及时更新；使用 protocol 获取模块时，protocol 并没有注册对应的模块。这些问题都只能在运行时才能发现。</p>
<p> 那么有没有一种方式，可以让模块既高度解耦，又能在编译时保证调用的模块一定存在呢？</p>
<p>答案是 YES。</p>
<h2 id="静态路由检查"><a href="#静态路由检查" class="headerlink" title="静态路由检查"></a>静态路由检查</h2><p>ZIKRouter 最特别的功能，就是能够保证所使用的 protocol 一定存在，在编译阶段就能防止使用不存在的模块。这个功能可以让你更安全、更简单地管理所使用的路由接口，不必再用其他复杂的方式进行检查和维护。</p>
<p>当使用了错误的 protocol 时，会产生编译错误。</p>
<p>Swift 中使用未声明的 protocol：</p>
<p><img src="/Users/zhangweike/Documents/code/ZIKRouter/Documentation/Resources/Unroutable-error-Swift.png" alt="Unroutable-error-Swift"></p>
<p>Objective-C 中使用未声明的 protocol：</p>
<p><img src="/Users/zhangweike/Documents/code/ZIKRouter/Documentation/Resources/Unroutable-error-OC.png" alt="Unroutable-error-OC"></p>
<p>这个特性通过两个机制来实现：</p>
<ul>
<li>只有被声明为可路由的 protocol 才能用于路由，否则会产生编译错误</li>
<li>可路由的 protocol 必定有一个对应的模块存在</li>
</ul>
<p>下面就一步步讲解，怎么在保持动态解耦特性的同时，实现一套完备的静态类型检查的机制。</p>
<h3 id="路由声明"><a href="#路由声明" class="headerlink" title="路由声明"></a>路由声明</h3><p>怎么才能声明一个 protocol 是可以用于路由的呢？</p>
<p>要实现第一个机制，关键就是要为 protocol 添加特殊的属性或者类型，使用时，如果 protocol 不符合特定类型，就产生编译错误。</p>
<p>原生 Xcode 并不支持这样的静态检查，这时候就要考验我们的创造力了。</p>
<h4 id="Objective-C：protocol-继承链"><a href="#Objective-C：protocol-继承链" class="headerlink" title="Objective-C：protocol 继承链"></a>Objective-C：protocol 继承链</h4><p>在 Objective-C 中，可以要求 protocol 必须继承自某个特定的父 protocol，并且通过宏定义 + protocol 限定，对 protocol 的父 protocol 继承链进行静态检查。</p>
<p>例如 ZIKRouter 中获取 router 类的方法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@protocol ZIKViewRoutable</div><div class="line">@end</div><div class="line"></div><div class="line">@interface ZIKViewRouter()</div><div class="line">@property (nonatomic, class, readonly) ZIKViewRouterType *(^toView)(Protocol&lt;ZIKViewRoutable&gt; *viewProtocol);</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>toView</code>用类属性的方式提供，以方便链式调用，这个 block 接收一个<code>Protocol&lt;ZIKViewRoutable&gt; *</code>类型的 protocol，返回对应的 router 类。</p>
<p><code>Protocol&lt;ZIKViewRoutable&gt; *</code>表示这个 protocol 必须继承自<code>ZIKViewRoutable</code>。普通 protocol 的类型是<code>Protocol *</code>，所以如果传入<code>@protocol(EditorViewProtocol)</code>就会产生编译警告。</p>
<p>而如果用宏定义再给 protocol 变量加上一个 protocol 限定，进行一次类型转换，就可以利用编译器检查 protocol 的继承链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 声明时继承自 ZIKViewRoutable</div><div class="line">@protocol EditorViewProtocol &lt;ZIKViewRoutable&gt;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 宏定义，为 protocol 变量添加 protocol 限定</div><div class="line">#define ZIKRoutable(RoutableProtocol) (Protocol&lt;RoutableProtocol&gt;*)@protocol(RoutableProtocol)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 用 protocol 获取 router</div><div class="line">ZIKViewRouter.toView(ZIKRoutable(EditorViewProtocol))</div></pre></td></tr></table></figure>
<p><code>ZIKRoutable(EditorViewProtocol)</code>展开后是<code>(Protocol&lt;EditorViewProtocol&gt; *)@protocol(EditorViewProtocol)</code>，类型为<code>Protocol&lt;EditorViewProtocol&gt; *</code>。在 Objective-C 中<code>Protocol&lt;EditorViewProtocol&gt; *</code>是<code>Protocol&lt;ZIKViewRoutable&gt; *</code>的子类型，编译器将不会有警告。</p>
<p>但是当传入的 protocol 没有继承自<code>ZIKViewRoutable</code>时，例如<code>ZIKRoutable(UndeclaredProtocol)</code>的类型是<code>Protocol&lt;UndeclaredProtocol&gt; *</code>，编译器在检查 protocol 的继承链时，由于<code>UndeclaredProtocol</code>没有继承自<code>ZIKViewRoutable</code>，因此<code>Protocol&lt;UndeclaredProtocol&gt; *</code>不是<code>Protocol&lt;ZIKViewRoutable&gt; *</code>的子类型，编译器会给出类型错误的警告。在<code>Build Settings</code>中可以把<code>incompatible pointer types</code>警告变成编译错误。</p>
<p>最后，把<code>ZIKViewRouter.toView(ZIKRoutable(EditorViewProtocol))</code>用宏定义简化一下，变成<code>ZIKViewRouterToView(EditorViewProtocol)</code>，就能在获取 router 的时候方便地静态检查 protocol 的类型了。</p>
<h4 id="Swift：条件扩展"><a href="#Swift：条件扩展" class="headerlink" title="Swift：条件扩展"></a>Swift：条件扩展</h4><p>Swift 中不支持宏定义，也不能随意进行类型转换，因此需要换一种方式来进行编译检查。</p>
<p>可以用 struct 的泛型传递 protocol，然后用条件扩展为特定泛型的 struct 添加初始化方法，从而让没有声明过的泛型类型不能直接创建 struct。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用 RoutableView 的泛型来传递 protocol</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RoutableView</span>&lt;<span class="title">Protocol</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 禁止默认的初始化方法</span></div><div class="line">    <span class="meta">@available</span>(*, unavailable, message: <span class="string">"Protocol is not declared as routable"</span>)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 泛型为 EditorViewProtocol 的扩展</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RoutableView</span> <span class="title">where</span> <span class="title">Protocol</span> == <span class="title">EditorViewProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// 允许初始化</span></div><div class="line">    <span class="keyword">init</span>() &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 泛型为 EditorViewProtocol 时可以初始化</span></div><div class="line"><span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;()</div><div class="line"></div><div class="line"><span class="comment">// 没有声明过的泛型无法初始化，会产生编译错误</span></div><div class="line"><span class="type">RoutableView</span>&lt;<span class="type">UndeclaredProtocol</span>&gt;()</div></pre></td></tr></table></figure>
<p>此时 Xcode 还可以给出自动补全，列出所有声明过的 protocol：</p>
<p><img src="route-auto-completion.png" alt=""></p>
<h3 id="路由检查"><a href="#路由检查" class="headerlink" title="路由检查"></a>路由检查</h3><p>通过路由声明，我们做到了在编译时对所使用的 protocol 做出限制。下一步就是保证声明过的 protocol 必定有对应的模块，类似于程序在 link 阶段，会检查头文件中声明过的类必定有对应的实现。</p>
<p>这一步是无法直接在编译阶段实现的，不过可以参考 iOS 在启动时检查动态库的方式，我们可以在启动阶段实现这个功能。</p>
<h4 id="Objective-C-protocol-遍历"><a href="#Objective-C-protocol-遍历" class="headerlink" title="Objective-C: protocol 遍历"></a>Objective-C: protocol 遍历</h4><p>在 app 以 DEBUG 模式启动时，我们可以遍历所有继承自 ZIKViewRoutable 的 protocol，在注册表中检查是否有对应的 router，如果没有，就给出断言错误。</p>
<p>另外，还可以让 router 同时注册创建模块时用到类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">EditorViewRouter</span>.registerView(<span class="type">EditorViewController</span>.<span class="keyword">self</span>)</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册 protocol 和 router</span></div><div class="line">[EditorViewRouter registerView:[EditorViewController <span class="keyword">class</span>]];</div></pre></td></tr></table></figure><br><br></details>

<p>从而进一步检查 router 中的 class 是否遵守对应的 protocol。这时整个类型检查过程就完整了。</p>
<h4 id="Swift-符号遍历"><a href="#Swift-符号遍历" class="headerlink" title="Swift: 符号遍历"></a>Swift: 符号遍历</h4><p>但是 Swift 中的 protocol 是静态类型，并不能通过 OC runtime 直接遍历。是不是就无法动态检查了呢？其实只要发挥创造力，一样能做到。</p>
<p>Swift 的泛型名会在符号名中体现出来。例如上面声明的 init 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MyApp 中，泛型为 EditorViewProtocol 的扩展</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RoutableView</span> <span class="title">where</span> <span class="title">Protocol</span> == <span class="title">EditorViewProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// 允许初始化</span></div><div class="line">    <span class="keyword">init</span>() &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在还原符号后就是<code>(extension in MyApp):ZRouter.RoutableView&lt;A where A == MyApp.EditorViewProtocol&gt;.init() -&gt; ZRouter.RoutableView&lt;MyApp.EditorViewProtocol&gt;</code>。</p>
<p>此时我们可以遍历 app 的符号表，来查找 RoutableView 的所有扩展，从而提取出所有声明过的 protocol 类型，再去检查是否有对应的 router。</p>
<h5 id="Swift-Runtime-和-ABI"><a href="#Swift-Runtime-和-ABI" class="headerlink" title="Swift Runtime 和 ABI"></a>Swift Runtime 和 ABI</h5><p>但是如果要进一步检查 router 中的 class 是否遵守 router 中的 protocol，就会遇到问题了。在 Swift 中怎么检查某个任意的 class 遵守某个 Swift protocol ？</p>
<p>Swift 中没有直接提供<code>class_conformsToProtocol</code>这样的函数，不过我们可以通过 Swift Runtime 提供的标准函数和 Swift ABI 中定义的内存结构，完成同样的功能。</p>
<p>这部分的实现可以参考代码：<a href="https://github.com/Zuikyo/ZIKRouter/blob/acb923bcdd09c65672977b5a20f7c527e459ead5/ZIKRouter/Utilities/ZIKRouterRuntimeDebug.h#L41" target="_blank" rel="external">_swift_typeIsTargetType</a>。之后我会写几篇文章详细讲解 Swift ABI 的底层内容。</p>
<p>路由检查这部分只在 DEBUG 模式下进行，因此可以放开折腾。</p>
<h3 id="自动推断返回值类型"><a href="#自动推断返回值类型" class="headerlink" title="自动推断返回值类型"></a>自动推断返回值类型</h3><p>还有最后一个问题，在 BeeHive 中使用<code>[[BeeHive shareInstance] createService:@protocol(EditorViewProtocol)]</code>获取模块时，返回值是一个<code>id</code>类型，使用者需要手动指定返回变量的类型，在 Swift 中更是需要手动类型转换，而这一步是可能出错的，并且编译器无法检查。要实现最完备的类型检查，就不能忽视这个问题。</p>
<p>有没有一种方式能让返回值的类型和 protocol 的类型对应呢？OC 中的泛型在这时候就发挥作用了。</p>
<p>可以在 router 上声明模块的泛型：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZIKViewRouter</span>&lt;<span class="title">__covariant</span> <span class="title">Destination</span>, <span class="title">__covariant</span> <span class="title">RouteConfig</span>: <span class="title">ZIKViewRouteConfiguration</span> *&gt; : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这里使用了两个泛型参数 <code>Destination</code> 和 <code>RouteConfig</code>，分别表示此 router 所管理的模块类型和路由 config 的类型。<code>__covariant</code>则表示这个泛型支持协变，也就是子类型可以和父类型一样使用。</p>
<p>声明了泛型参数后，我们可以在方法中的参数声明中使用泛型：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZIKViewRouter</span>&lt;<span class="title">__covariant</span> <span class="title">Destination</span>, <span class="title">__covariant</span> <span class="title">RouteConfig</span>: <span class="title">ZIKViewRouteConfiguration</span> *&gt; : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> Destination)makeDestination;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> Destination)destinationWithConfiguration:(RouteConfig)configuration;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>此时在获取 router 时，就可以把 protocol 的类型作为 router 的泛型参数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define ZIKRouterToView(ViewProtocol) [ZIKViewRouter<span class="meta-string">&lt;id&lt;ViewProtocol&gt;</span>,ZIKViewRouteConfiguration *&gt; toView](ZIKRoutable(ViewProtocol))</span></div></pre></td></tr></table></figure>
<p>使用<code>ZIKRouterToView(EditorViewProtocol)</code>获取的 router 类型就是<code>ZIKViewRouter&lt;id&lt;EditorViewProtocol&gt;,ZIKViewRouteConfiguration *&gt;</code>。在这个 router 上调用<code>makeDestination</code>时，返回值的类型就是<code>id&lt;EditorViewProtocol&gt;</code>，从而实现了完整的类型传递。</p>
<p>而在 Swift 中，直接用函数泛型就能实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">to</span>&lt;Protocol&gt;<span class="params">(<span class="number">_</span> routableView: RoutableView&lt;<span class="keyword">Protocol</span>&gt;)</span></span> -&gt; <span class="type">ViewRouter</span>&lt;<span class="type">Protocol</span>, <span class="type">ViewRouteConfig</span>&gt;?</div><div class="line">    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>使用<code>Router.to(RoutableView&lt;EditorViewProtocol&gt;())</code>时，获得的 router 类型就是<code>ViewRouter&lt;EditorViewProtocol, ViewRouteConfig&gt;?</code>，在调用<code>makeDestination</code>时，返回值类型就是<code>EditorViewProtocol</code>，无需手动类型转换。</p>
<p>如果你使用协议组合，还能同时指明多个类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typealias</span> <span class="type">EditorViewProtocol</span> = <span class="type">UIViewController</span> &amp; <span class="type">EditorViewInput</span></div></pre></td></tr></table></figure>
<p>并且在 router 子类中重写对应方法时，也能用泛型进一步确保类型正确：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewProtocol</span>, <span class="title">ZIKViewRouteConfiguration</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ZIKViewRouteConfiguration)</span></span> -&gt; <span class="type">EditorViewProtocol</span>? &#123;</div><div class="line">        <span class="comment">// 函数重写时，参数类型会和泛型一致，实现时能确保返回值的类型是正确的</span></div><div class="line">        <span class="keyword">return</span> <span class="type">EditorViewController</span>()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们完成了一套完备的类型检查机制，而且这套检查同时支持 OC 和 Swift。</p>
<p>至此，一个基于接口的、类型安全的模块管理工具就完成了。使用 <code>makeDestination</code> 创建模块只是最基本的功能，我们可以在父类 router 中进行许多有用的功能扩展，例如依赖注入、界面跳转、接口适配，来更好地进行面向接口的开发。</p>
<h2 id="模块解耦"><a href="#模块解耦" class="headerlink" title="模块解耦"></a>模块解耦</h2><p>那么在面向接口编程时，我们还需要哪些功能呢？在扩展之前，我们先来讨论一下如何使用接口进行模块解耦，首先从理论层面梳理，再把理论转化为工具。</p>
<h3 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h3><p><img src="Modules.png" alt=""></p>
<p>不同模块对解耦的要求是不同的。模块从层级上可以从低到高分类：</p>
<ul>
<li>底层功能模块，功能单一，有一定通用性，例如各种功能组件(日志、数据库)。底层模块的主要目的是复用</li>
<li>中间层的通用业务模块，可以在不同项目中通用。会引用各种底层模块，以及和其他业务模块通信</li>
<li>中间层的特殊功能模块，提供了独特的功能，没有通用性，可能会引用一些底层模块，例如性能监控模块。这种模块可以被其他模块直接引用，不用太多考虑模块间解耦的问题</li>
<li>上层的专有业务模块，属于某个项目中独有的业务。会引用各种底层模块，以及和其他业务模块通信，和中间层的差别就是上层的解耦要求没有中间层那么高</li>
</ul>
<h3 id="什么是解耦"><a href="#什么是解耦" class="headerlink" title="什么是解耦"></a>什么是解耦</h3><p>首先明确一下什么才是解耦，梳理这个问题能够帮助我们明确目标。</p>
<p>解耦的目的基本上就是两个：提高代码的可维护性、模块重用。指导思想就是面向对象的设计原则。</p>
<p>解耦也有不同的程度，从低到高，差不多可以分为3层：</p>
<ol>
<li>模块间使用抽象接口交互，没有直接类型耦合，一个模块内部的修改不会影响到另一个模块 (单一职责、依赖倒置)</li>
<li>模块可重用，可以被单独编译 (接口隔离、依赖倒置、控制反转)</li>
<li>模块可以随时被另一个提供了相同功能的模块替换 (开闭原则、依赖倒置、控制反转)</li>
</ol>
<h4 id="第一层：抽象接口，提取依赖关系"><a href="#第一层：抽象接口，提取依赖关系" class="headerlink" title="第一层：抽象接口，提取依赖关系"></a>第一层：抽象接口，提取依赖关系</h4><p>第一层解耦，是为了减少不同代码间的依赖关系，让代码更容易维护。例如把类替换为 protocol，隔绝模块的私有接口，把依赖关系最小化。</p>
<p>解耦的整个过程，就是梳理和管理依赖的过程。因此模块的内聚性越高越好，外部依赖越少越好，这样维护起来才更简单。</p>
<p>如果模块不需要重用，那在这一层基本上就够了。</p>
<h4 id="第二层：模块重用，管理模块间通信"><a href="#第二层：模块重用，管理模块间通信" class="headerlink" title="第二层：模块重用，管理模块间通信"></a>第二层：模块重用，管理模块间通信</h4><p>第二层解耦，是把代码单独抽离，做到了模块重用，可以交给不同的成员维护，对模块间通信提出了更高的要求。模块需要在接口中声明外部依赖，去除对特定类型的耦合。</p>
<p>此时影响最大的地方就是模块间通信的方式，有时候即便是能够单独编译了，也不意味着解耦。例如 URL 路由，只是放弃了编译检查，耦合关系还是存在于 URL 字符串中，一方的 URL 改变，其他方的代码逻辑就会出错，所以逻辑上仍然是耦合的。因此所有基于某种隐式调用约定的方案（例如字符串匹配），都只是解除编译检查，而不是真正的解耦。</p>
<p>有人说使用 protocol 进行模块间通信，会导致模块和 protocol 耦合。这个观点是错误的。 protocol 恰恰是把模块的依赖明确地提取出来，是一种更高效的方法。否则完全用隐式约定来进行通信，没有编译器的辅助，一旦模块的接口名、参数类型、参数数量需要更新，将会非常难以维护。</p>
<p>而且，通过设计模式，是可以解除对特定 protocol 的依赖的，下文将会对此进行讲解。</p>
<h4 id="第三层：去除隐式约定"><a href="#第三层：去除隐式约定" class="headerlink" title="第三层：去除隐式约定"></a>第三层：去除隐式约定</h4><p>第三层解耦，模块间做到了真正的解耦，只要两个模块提供了相同的功能，就可以无缝替换，并且调用方无需任何修改。被替换的模块只需要提供相同功能的接口，通过适配器对接即可，没有其他任何限制，不存在任何其他的隐式调用约定。</p>
<p>一般有这种解耦要求的，都是那些跨项目的通用模块，而项目内专有的业务模块则没有这么高的要求。不过那些跨多端的模块和远程模块无法做到这样的解耦，因为跨多端时没有统一的定义接口的方式，因此只能通过隐式约定或者网络协议定义接口，例如 URL 路由。</p>
<p><strong>总的来说，解耦的过程就是职责分离、依赖管理（依赖声明和注入）、模块通信 这三大部分。</strong></p>
<h3 id="模块重用"><a href="#模块重用" class="headerlink" title="模块重用"></a>模块重用</h3><p>要做到模块重用，模块需要尽量减少外部依赖，并且把依赖提取出来，体现到模块的接口上，让调用者主动注入。同时，把模块的各种事件也提取出来，让调用者进行处理。</p>
<p>这样一来，模块就只需要负责自身的逻辑，不需要关心调用者如何使用模块。那些每个应用各自专有的应用层逻辑也就从模块中分离出来了。</p>
<p><strong>因此，要想做好模块解耦，管理好依赖是非常重要的。而 protocol 接口就是管理依赖的最高效的方式。</strong></p>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>依赖，就是模块中用到的外部数据和外部模块。接下来讨论如何使用 protocol 管理依赖，并且演示如何用 router 实现。</p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>先来复习一下依赖注入的概念。依赖注入和依赖查找是实现控制反转思想的具体方式。</p>
<p>控制反转是将对象依赖的获取从主动变为被动，从对象内部直接引用并获取依赖，变为由外部向对象提供对象所要求的依赖，把不属于自己的职责移交出去，从而让对象和其依赖解耦。此时控制流的主动权从内部转移到了外部，因此称为控制反转。</p>
<p>依赖注入就是指外部向对象传入依赖。</p>
<p>一个类 A 在接口中体现出内部需要用到的一些依赖(例如内部需要用到类B的实例)，从而让使用者从外部注入这些依赖，而不是在类内部直接引用依赖并创建类 B。依赖可以用 protocol 的方式声明，这样就可以使类 A 和所使用的依赖类 B 进行解耦。</p>
<h3 id="分离模块创建和配置"><a href="#分离模块创建和配置" class="headerlink" title="分离模块创建和配置"></a>分离模块创建和配置</h3><p>那么如何用 router 进行依赖注入呢？</p>
<p>模块创建了实例后，经常还需要进行一些配置。模块管理工具应该从设计上提供配置功能。</p>
<p>最简单的方式，就是在<code>destinationWithConfiguration:</code>中创建 destination 时进行配置。但是我们还可以更进一步，把 destination 的创建和配置分离开。分离之后，router 就可以单独提供配置功能，去配置那些不是由 router 创建的 destination，例如 storyboard 中创建的 view、各种接口回调中返回的实例对象。这样就可以覆盖更多现存的使用场景，减少代码修改。</p>
<h4 id="Prepare-Destination"><a href="#Prepare-Destination" class="headerlink" title="Prepare Destination"></a>Prepare Destination</h4><p>可以在 router 子类中的<code>prepareDestination:configuration:</code>中进行模块配置，也就是依赖注入，而模块的调用者无需关心这部分依赖是如何配置的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewController</span>, <span class="title">ViewRouteConfig</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">EditorViewController</span>? &#123;</div><div class="line">        <span class="keyword">let</span> destination = <span class="type">EditorViewController</span>()</div><div class="line">        <span class="keyword">return</span> destination</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 配置模块，注入静态依赖</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareDestination</span><span class="params">(<span class="number">_</span> destination: EditorViewController, configuration: ViewRouteConfig)</span></span> &#123;</div><div class="line">        <span class="comment">// 注入 service 依赖</span></div><div class="line">        destination.storageService = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableService</span>&lt;<span class="type">EditorStorageServiceInput</span>&gt;())</div><div class="line">        <span class="comment">// 其他配置</span></div><div class="line">        destination.title = <span class="string">"默认标题"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewRouter</span> : <span class="title">ZIKViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewRouter</span></span></div><div class="line"></div><div class="line">- (EditorViewController *)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    EditorViewController *destination = [[EditorViewController alloc] init];</div><div class="line">    <span class="keyword">return</span> destination;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 配置模块，注入静态依赖</span></div><div class="line">- (<span class="keyword">void</span>)prepareDestination:(EditorViewController *)destination configuration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="comment">// 注入 service 依赖</span></div><div class="line">    destination.storageService = [ZIKRouterToService(EditorStorageServiceInput) makeDestination];</div><div class="line">    <span class="comment">// 其他配置</span></div><div class="line">    destination.title = <span class="string">@"默认标题"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>此时调用者中如果有某些对象不是创建自 router的，就可以直接用对应的 router 进行配置，执行依赖注入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> destination: <span class="type">EditorViewProtocol</span> = ...</div><div class="line"><span class="type">Router</span>.to(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;())?.prepare(destination: destination, configuring: &#123; (config, <span class="number">_</span>) <span class="keyword">in</span></div><div class="line">    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span>&lt;EditorViewProtocol&gt; destination = ...</div><div class="line">[ZIKRouterToView(EditorViewProtocol) prepareDestination:destination configuring:^(ZIKViewRouteConfiguration *config) &#123;</div><div class="line">    </div><div class="line">&#125;];</div></pre></td></tr></table></figure><br><br></details>

<p>独立的配置功能在某些场景下是非常有用的，尤其是在重构现有代码的时候。有一些系统接口的设计就是在接口中返回对象，但是这些对象是由系统自动创建的，而不是通过 router 创建的，因此需要通过 router 对其进行配置，例如 storyboard 中创建的 view controller。此时将 view controller 模块化后，依然可以保持现有代码，只需要调用一句<code>prepareDestination:configuration:</code>配置即可，模块化的过程中就能让代码的修改最小化。</p>
<h3 id="可选依赖：属性注入和方法注入"><a href="#可选依赖：属性注入和方法注入" class="headerlink" title="可选依赖：属性注入和方法注入"></a>可选依赖：属性注入和方法注入</h3><p>当依赖是可选的，并不是创建对象所必需的，可以用属性注入和方法注入。</p>
<p>属性注入是指外部设置对象的属性。方法注入是指外部调用对象的方法，从而传入依赖。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PersonType</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> wife: <span class="type">Person</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">// 可选的属性依赖</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addChild</span><span class="params">(<span class="number">_</span> child: Person)</span></span> -&gt; <span class="type">Void</span> <span class="comment">// 可选的方法注入</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Child</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> parent: <span class="type">Person</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">PersonType</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> wife: <span class="type">Person</span>? = <span class="literal">nil</span></div><div class="line">    <span class="keyword">var</span> childs: <span class="type">Set</span>&lt;<span class="type">Child</span>&gt; = []</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addChild</span><span class="params">(<span class="number">_</span> child: Child)</span></span> &#123;</div><div class="line">        childs.insert(child)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">PersonType</span>: <span class="title">ZIKServiceRoutable</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) Person *wife; <span class="comment">// 可选的属性依赖</span></div><div class="line">- (<span class="keyword">void</span>)addChild:(Person *)child; <span class="comment">// 可选的方法注入</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Child</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *parent;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>: <span class="title">NSObject</span> &lt;<span class="title">PersonType</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) Person *wife;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSSet</span>&lt;<span class="keyword">id</span>&lt;Child&gt;&gt; childs;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>在 router 里，可以注入一些默认的依赖：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">Person</span>, <span class="title">PerformRouteConfig</span>&gt; </span>&#123;</div><div class="line">    ...    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: PerformRouteConfig)</span></span> -&gt; <span class="type">Person</span>? &#123;</div><div class="line">        <span class="keyword">let</span> person = <span class="type">Person</span>()</div><div class="line">        <span class="keyword">return</span> person</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 配置模块，注入静态依赖</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareDestination</span><span class="params">(<span class="number">_</span> destination: Person, configuration: PerformRouteConfig)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> destination.wife != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//设置默认值</span></div><div class="line">        <span class="keyword">let</span> wife: <span class="type">Person</span> = ...</div><div class="line">        person.wife = wife</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PersonRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">Person</span> *, <span class="title">ZIKPerformRouteConfiguration</span> *&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonRouter</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> Person *)destinationWithConfiguration:(ZIKPerformRouteConfiguration *)configuration &#123;</div><div class="line">    Person *person = [Person new];</div><div class="line">    <span class="keyword">return</span> person;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 配置模块，注入静态依赖</span></div><div class="line">- (<span class="keyword">void</span>)prepareDestination:(Person *)destination configuration:(ZIKPerformRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">if</span> (destination.wife != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    Person *wife = ...</div><div class="line">    destination.wife = wife;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h4 id="模块间参数传递"><a href="#模块间参数传递" class="headerlink" title="模块间参数传递"></a>模块间参数传递</h4><p>在执行路由操作的同时，调用者也可以用<code>PersonType</code>动态地注入依赖，也就是向模块传参。</p>
<p>configuration 就是用来进行各种功能扩展的。Router 可以在 configuration 上提供<code>prepareDestination</code>，让调用者设置，就能让调用者配置 destination。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> wife: <span class="type">Person</span> = ...</div><div class="line"><span class="keyword">let</span> child: <span class="type">Child</span> = ...</div><div class="line"><span class="keyword">let</span> person = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableService</span>&lt;<span class="type">PersonType</span>&gt;(), configuring: &#123; (config, <span class="number">_</span>) <span class="keyword">in</span></div><div class="line">    <span class="comment">// 获取模块的同时进行配置</span></div><div class="line">    config.prepareDestination = &#123; destination <span class="keyword">in</span></div><div class="line">        destination.wife = wife</div><div class="line">        destination.addChild(child)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Person *wife = ...</div><div class="line">Child *child = ...</div><div class="line">Person *person = [ZIKRouterToService(PersonType) </div><div class="line">         makeDestinationWithConfiguring:^(ZIKPerformRouteConfiguration *config) &#123;</div><div class="line">    <span class="comment">// 获取模块的同时进行配置</span></div><div class="line">    config.prepareDestination = ^(<span class="keyword">id</span>&lt;PersonType&gt; destination) &#123;</div><div class="line">        destination.wife = wife;</div><div class="line">        [destination addChild:child];</div><div class="line">    &#125;;</div><div class="line">&#125;];</div></pre></td></tr></table></figure><br><br></details>

<p>封装一下就能变成更简单的接口：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> wife: <span class="type">Person</span> = ...</div><div class="line"><span class="keyword">let</span> child: <span class="type">Child</span> = ...</div><div class="line"><span class="keyword">let</span> person = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableService</span>&lt;<span class="type">PersonType</span>&gt;(), preparation: &#123; destination <span class="keyword">in</span></div><div class="line">            destination.wife = wife</div><div class="line">            destination.addChild(child)</div><div class="line">        &#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Person *wife = ...</div><div class="line">Child *child = ...</div><div class="line">Person *person = [ZIKRouterToService(PersonType) </div><div class="line">         makeDestinationWithPreparation:^(<span class="keyword">id</span>&lt;PersonType&gt; destination) &#123;</div><div class="line">            destination.wife = wife;</div><div class="line">            [destination addChild:child];</div><div class="line">        &#125;];</div></pre></td></tr></table></figure><br><br></details>

<h3 id="必需依赖：工厂方法"><a href="#必需依赖：工厂方法" class="headerlink" title="必需依赖：工厂方法"></a>必需依赖：工厂方法</h3><p>有一些参数是在 destination 类创建前就需要传入的必需参数，例如初始化方法中的参数，就是必需依赖。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">PersonType</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="comment">// 初始化方法，需要必需参数</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>: <span class="title">NSObject</span> &lt;<span class="title">PersonType</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="comment">// 初始化方法，需要必需参数</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>这些必需参数有时候是由调用者提供的。在 URL 路由中，这种”必需”特性就无法体现出来，而用接口的方式就能简单地实现。</p>
<p>传递必需依赖需要用工厂模式，在工厂方法上声明必需参数和模块接口。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PersonTypeFactory</span> </span>&#123;</div><div class="line">  <span class="comment">// 工厂方法，声明了必需参数 name，返回 PersonType 类型的 destination</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeDestinationWith</span><span class="params">(<span class="number">_</span> name: String)</span></span> -&gt; <span class="type">PersonType</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">PersonTypeFactory</span>: <span class="title">ZIKServiceModuleRoutable</span></span></div><div class="line"><span class="comment">// 工厂方法，声明了必需参数 name，返回 PersonType 类型的 destination</span></div><div class="line">- (<span class="keyword">id</span>&lt;PersonType&gt;)makeDestinationWith:(<span class="built_in">NSString</span> *)name;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>那么如何用 router 传递必需参数呢？</p>
<p>Router 的 configuration 可以用来进行自定义参数扩展。可以把必需参数保存到 configuration 上，或者更直接点，由 configuration 来提供工厂方法，然后使用工厂方法的 protocol 来获取模块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通用 configuration，可以提供自定义工厂方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonModuleConfiguration</span>: <span class="title">PerformRouteConfig</span>, <span class="title">PersonTypeFactory</span> </span>&#123;</div><div class="line">    <span class="comment">// 工厂方法</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeDestinationWith</span><span class="params">(<span class="number">_</span> name: String)</span></span> -&gt; <span class="type">PersonType</span>? &#123;</div><div class="line">        <span class="keyword">self</span>.makedDestination = <span class="type">Person</span>(name: name)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.makedDestination</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 由工厂方法创建的 destination，提供给 router</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> makedDestination: <span class="type">Destination</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通用 configuration，可以提供自定义工厂方法</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PersonModuleConfiguration</span>: <span class="title">ZIKPerformRouteConfiguration</span>&lt;<span class="title">PersonTypeFactory</span>&gt;</span></div><div class="line"><span class="comment">// 由工厂方法创建的 destination，提供给 router</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span>&lt;PersonTypeFactory&gt; makedDestination;</div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonModuleConfiguration</span></span></div><div class="line"><span class="comment">// 工厂方法</span></div><div class="line">-(<span class="keyword">id</span>&lt;PersonTypeFactory&gt;)makeDestinationWith:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="keyword">self</span>.makedDestination = [[Person alloc] initWithName:name];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.makedDestination;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>在 router 中使用自定义 configuration：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">Person</span>, <span class="title">PersonModuleConfiguration</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 重写 defaultRouteConfiguration，使用自定义 configuration</span></div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultRouteConfiguration</span>() -&gt; <span class="title">PersonModuleConfiguration</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">PersonModuleConfiguration</span>()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: PersonModuleConfiguration)</span></span> -&gt; <span class="type">Person</span>? &#123;</div><div class="line">        <span class="comment">// 使用工厂方法创建的 destination</span></div><div class="line">        <span class="keyword">return</span> config.makedDestination</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PersonRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">id</span>&lt;<span class="title">PersonType</span>&gt;, <span class="title">PersonModuleConfiguration</span> *&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonRouter</span></span></div><div class="line">  </div><div class="line"><span class="comment">// 重写 defaultRouteConfiguration，使用自定义 configuration</span></div><div class="line">+ (PersonModuleConfiguration *)defaultRouteConfiguration &#123;</div><div class="line">    <span class="keyword">return</span> [PersonModuleConfiguration new];</div><div class="line">&#125;</div><div class="line">  </div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;PersonType&gt;)destinationWithConfiguration:(PersonModuleConfiguration *)configuration &#123;</div><div class="line">    <span class="comment">// 使用工厂方法创建的 destination</span></div><div class="line">    <span class="keyword">return</span> configuration.makedDestination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>然后把<code>PersonTypeFactory</code>协议和 router 进行注册：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">PersonRouter</span>.register(<span class="type">RoutableServiceModule</span>&lt;<span class="type">PersonTypeFactory</span>&gt;())</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[PersonRouter registerModuleProtocol:ZIKRoutable(PersonTypeFactory)];</div></pre></td></tr></table></figure><br><br></details>

<p>就可以用<code>PersonTypeFactory</code>获取模块了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name: <span class="type">String</span> = ...</div><div class="line"><span class="type">Router</span>.makeDestination(to: <span class="type">RoutableServiceModule</span>&lt;<span class="type">PersonTypeFactory</span>&gt;(), configuring: &#123; (config, <span class="number">_</span>) <span class="keyword">in</span></div><div class="line">    <span class="comment">// config 遵守 PersonTypeFactory</span></div><div class="line">    config.makeDestinationWith(name)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *name = ...</div><div class="line">ZIKRouterToServiceModule(PersonTypeFactory) makeDestinationWithConfiguring:^(ZIKPerformRouteConfiguration&lt;PersonTypeFactory&gt; *config) &#123;</div><div class="line">    <span class="comment">// config 遵守 PersonTypeFactory</span></div><div class="line">    [config makeDestinationWith:name];</div><div class="line">&#125;]</div></pre></td></tr></table></figure><br><br></details>

<h4 id="用泛型代替-configuration-子类"><a href="#用泛型代替-configuration-子类" class="headerlink" title="用泛型代替 configuration 子类"></a>用泛型代替 configuration 子类</h4><p>如果你不需要在 configuration 上保存其他自定义参数，也不想创建过多的 configuration 子类，可以用一个通用的泛型类来实现子类重写的效果。</p>
<p>泛型可以自定义参数类型，此时可以直接把工厂方法用 block 保存在 configuration 的属性上。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通用 configuration，可以提供自定义工厂方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceMakeableConfiguration</span>&lt;<span class="title">Destination</span>, <span class="title">Constructor</span>&gt;: <span class="title">PerformRouteConfig</span> </span>&#123;    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> makeDestinationWith: <span class="type">Constructor</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> makedDestination: <span class="type">Destination</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZIKServiceMakeableConfiguration</span>&lt;<span class="title">__covariant</span> <span class="title">Destination</span>&gt;: <span class="title">ZIKPerformRouteConfiguration</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) Destination(^makeDestinationWith)();</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) Destination makedDestination;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>在 router 中使用自定义 configuration：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">Person</span>, <span class="title">PerformRouteConfig</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 重写 defaultRouteConfiguration，使用自定义 configuration</span></div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultRouteConfiguration</span>() -&gt; <span class="title">PerformRouteConfig</span> </span>&#123;</div><div class="line">        <span class="keyword">let</span> config = <span class="type">ServiceMakeableConfiguration</span>&lt;<span class="type">PersonType</span>, (<span class="type">String</span>) -&gt; <span class="type">PersonType</span>&gt;(&#123; <span class="number">_</span> <span class="keyword">in</span>&#125;)</div><div class="line">        <span class="comment">// 设置工厂方法，让调用者使用</span></div><div class="line">        config.makeDestinationWith = &#123; [<span class="keyword">unowned</span> config] name <span class="keyword">in</span></div><div class="line">            config.makedDestination = <span class="type">Person</span>(name: name)</div><div class="line">            <span class="keyword">return</span> config.makedDestination</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> config</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: PerformRouteConfig)</span></span> -&gt; <span class="type">Person</span>? &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> config = configuration <span class="keyword">as</span>? <span class="type">ServiceMakeableConfiguration</span>&lt;<span class="type">PersonType</span>, (<span class="type">String</span>) -&gt; <span class="type">PersonType</span>&gt; &#123;</div><div class="line">            <span class="comment">// 使用工厂方法创建的 destination</span></div><div class="line">            <span class="keyword">return</span> config.makedDestination</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 让对应泛型的 configuration 遵守 PersonTypeFactory</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServiceMakeableConfiguration</span>: <span class="title">PersonTypeFactory</span> <span class="title">where</span> <span class="title">Destination</span> == <span class="title">PersonType</span>, <span class="title">Constructor</span> == (<span class="title">String</span>) -&gt; <span class="title">PersonType</span> </span>&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PersonRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">id</span>&lt;<span class="title">PersonType</span>&gt;, <span class="title">ZIKServiceMakeableConfiguration</span> *&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonRouter</span></span></div><div class="line"></div><div class="line"><span class="comment">// 重写 defaultRouteConfiguration，使用自定义 configuration</span></div><div class="line">+ (ZIKServiceMakeableConfiguration *)defaultRouteConfiguration &#123;</div><div class="line">    ZIKServiceMakeableConfiguration *config = [ZIKServiceMakeableConfiguration new];</div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(config) weakConfig = config;</div><div class="line">    <span class="comment">// 设置工厂方法，让调用者使用</span></div><div class="line">    config.makeDestinationWith = <span class="keyword">id</span> ^(<span class="built_in">NSString</span> *name) &#123;</div><div class="line">        weakConfig.makedDestination = [[Person alloc] initWithName:name];</div><div class="line">        <span class="keyword">return</span> weakConfig.makedDestination;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> config;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;PersonType&gt;)destinationWithConfiguration:(ZIKServiceMakeableConfiguration *)configuration &#123;</div><div class="line">    <span class="comment">// 使用工厂方法创建的 destination</span></div><div class="line">    <span class="keyword">return</span> configuration.makedDestination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="避免接口污染"><a href="#避免接口污染" class="headerlink" title="避免接口污染"></a>避免接口污染</h3><p>除了必需依赖，还有一些参数是不属于 destination 类的，而是属于模块内其他组件的，也不能通过 destination 的接口来传递。例如 MVVM 和 VIPER 架构中，model 参数不能传给 view，而是应该交给 view model 或者 interactor。此时可以使用相同的模式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">EditorViewModuleInput</span> </span>&#123;</div><div class="line">  <span class="comment">// 工厂方法，声明了参数 note，返回 EditorViewInput 类型的 destination</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeDestinationWith</span><span class="params">(<span class="number">_</span> note: Note)</span></span> -&gt; <span class="type">EditorViewInput</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">EditorViewModuleInput</span>: <span class="title">ZIKViewModuleRoutable</span></span></div><div class="line"><span class="comment">// 工厂方法，声明了参数 note，返回 EditorViewInput 类型的 destination</span></div><div class="line">- (<span class="keyword">id</span>&lt;EditorViewInput&gt;)makeDestinationWith:(Note *)note;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewInput</span>, <span class="title">ViewRouteConfig</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 重写 defaultRouteConfiguration，使用自定义 configuration</span></div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultRouteConfiguration</span>() -&gt; <span class="title">ViewRouteConfig</span> </span>&#123;</div><div class="line">        <span class="keyword">let</span> config = <span class="type">ViewMakeableConfiguration</span>&lt;<span class="type">EditorViewInput</span>, (<span class="type">Note</span>) -&gt; <span class="type">EditorViewInput</span>&gt;(&#123; <span class="number">_</span> <span class="keyword">in</span>&#125;)</div><div class="line">        <span class="comment">// 设置工厂方法，让调用者使用</span></div><div class="line">        config.makeDestinationWith = &#123; [<span class="keyword">unowned</span> config] note <span class="keyword">in</span>            </div><div class="line">            config.makedDestination = <span class="keyword">self</span>.makeDestinationWith(note: note)</div><div class="line">            <span class="keyword">return</span> config.makedDestination</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> config</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">makeDestinationWith</span>(<span class="title">note</span>: <span class="title">Note</span>) -&gt; <span class="title">EditorViewInput</span> </span>&#123;</div><div class="line">        <span class="keyword">let</span> view = <span class="type">EditorViewController</span>()</div><div class="line">        <span class="keyword">let</span> presenter = <span class="type">EditorViewPresenter</span>(view)</div><div class="line">        <span class="keyword">let</span> interactor = <span class="type">EditorInteractor</span>(<span class="type">Presenter</span>)</div><div class="line">        <span class="comment">// 把 model 传递给数据管理者，view 不接触 model</span></div><div class="line">        interactor.note = note</div><div class="line">        <span class="keyword">return</span> view</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">EditorViewInput</span>? &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> config = configuration <span class="keyword">as</span>? <span class="type">ViewMakeableConfiguration</span>&lt;<span class="type">EditorViewInput</span>, (<span class="type">Note</span>) -&gt; <span class="type">EditorViewInput</span>&gt; &#123;</div><div class="line">            <span class="comment">// 使用工厂方法创建的 destination</span></div><div class="line">            <span class="keyword">return</span> config.makedDestination</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">id</span>&lt;<span class="title">EditorViewInput</span>&gt;, <span class="title">ZIKViewMakeableConfiguration</span> *&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonRouter</span></span></div><div class="line"></div><div class="line"><span class="comment">// 重写 defaultRouteConfiguration，使用自定义 configuration</span></div><div class="line">+ (ZIKViewMakeableConfiguration *)defaultRouteConfiguration &#123;</div><div class="line">    ZIKViewMakeableConfiguration *config = [ZIKViewMakeableConfiguration new];</div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(config) weakConfig = config;</div><div class="line">    <span class="comment">// 设置工厂方法，让调用者使用</span></div><div class="line">    config.makeDestinationWith = <span class="keyword">id</span> ^(Note *note) &#123;</div><div class="line">        weakConfig.makedDestination = [<span class="keyword">self</span> makeDestinationWith:note];</div><div class="line">        <span class="keyword">return</span> weakConfig.makedDestination;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> config;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>&lt;EditorViewInput&gt;)makeDestinationWith:(Note *)note &#123;</div><div class="line">    EditorViewController *view = [[EditorViewController alloc] init];</div><div class="line">    EditorViewPresenter *presenter = [[EditorViewPresenter alloc] initWithView:view];</div><div class="line">    EditorInteractor *interactor = [[EditorInteractor alloc] initWithPresenter:presenter];</div><div class="line">    <span class="comment">// 把 model 传递给数据管理者，view 不接触 model</span></div><div class="line">    interactor.note = note;</div><div class="line">    <span class="keyword">return</span> view;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;EditorViewInput&gt;)destinationWithConfiguration:(ZIKViewMakeableConfiguration *)configuration &#123;</div><div class="line">    <span class="comment">// 使用工厂方法创建的 destination</span></div><div class="line">    <span class="keyword">return</span> configuration.makedDestination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>就可以用<code>EditorViewModuleInput</code>获取模块了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> note: <span class="type">Note</span> = ...</div><div class="line"><span class="type">Router</span>.makeDestination(to: <span class="type">RoutableViewModule</span>&lt;<span class="type">EditorViewModuleInput</span>&gt;(), configuring: &#123; (config, <span class="number">_</span>) <span class="keyword">in</span></div><div class="line">    <span class="comment">// config 遵守 EditorViewModuleInput</span></div><div class="line">    config.makeDestinationWith(note)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Note *note = ...</div><div class="line">ZIKRouterToViewModule(EditorViewModuleInput) makeDestinationWithConfiguring:^(ZIKViewRouteConfiguration&lt;EditorViewModuleInput&gt; *config) &#123;</div><div class="line">    <span class="comment">// config 遵守 EditorViewModuleInput</span></div><div class="line">    config.makeDestinationWith(note);</div><div class="line">&#125;]</div></pre></td></tr></table></figure><br><br></details>

<h3 id="依赖查找"><a href="#依赖查找" class="headerlink" title="依赖查找"></a>依赖查找</h3><p>当模块的必需依赖很多时，如果把依赖都放在初始化接口中，就会出现一个非常长的方法。</p>
<p>除了让模块把依赖声明在接口中，模块内部也可以用模块管理工具动态查找依赖，例如用 router 查找 protocol 对应的模块。如果要使用这种模式，那么所有模块都需要统一使用相同的模块管理工具。</p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> storageService: <span class="type">EditorStorageServiceInput</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableService</span>&lt;<span class="type">EditorStorageServiceInput</span>&gt;())!</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewController</span> : <span class="title">UIViewController</span>()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;EditorStorageServiceInput&gt; storageService;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewController</span></span></div><div class="line">  </div><div class="line">- (<span class="keyword">id</span>&lt;EditorStorageServiceInput&gt;)storageService &#123;</div><div class="line">    <span class="keyword">if</span> (!_storageService) &#123;</div><div class="line">        _storageService = [ZIKRouterToService(EditorStorageServiceInput) makeDestination];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _storageService;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>使用依赖注入时，有些特殊情况需要处理，例如循环依赖的无限递归问题。</p>
<p>循环依赖是指两个对象互相依赖。</p>
<p>在 router 内部动态注入依赖时，如果注入的依赖同时依赖于被注入的对象，则必须在 protocol 中声明。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="comment">// Parent 依赖 Child</span></div><div class="line">    <span class="keyword">var</span> child: <span class="type">Child</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Child</span> </span>&#123;</div><div class="line">    <span class="comment">// Child 依赖 Parent</span></div><div class="line">    <span class="keyword">var</span> parent: <span class="type">Parent</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentObject</span>: <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> child: <span class="type">Child</span>!</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildObject</span>: <span class="title">Child</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> parent: <span class="type">Parent</span>!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Parent</span> &lt;<span class="title">ZIKServiceRoutable</span>&gt;</span></div><div class="line"><span class="comment">// Parent 依赖 Child</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;Child&gt; child;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Child</span> &lt;<span class="title">ZIKServiceRoutable</span>&gt;</span></div><div class="line"><span class="comment">// Child 依赖 Parent</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;Parent&gt; parent;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ParentObject</span>: <span class="title">NSObject</span>&lt;<span class="title">Parent</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ParentObject</span>: <span class="title">NSObject</span>&lt;<span class="title">Child</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">ParentObject</span>, <span class="title">PerformRouteConfig</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: PerformRouteConfig)</span></span> -&gt; <span class="type">ParentObject</span>? &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">ParentObject</span>()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareDestination</span><span class="params">(<span class="number">_</span> destination: ParentObject, configuration: PerformRouteConfig)</span></span> &#123;</div><div class="line">        <span class="keyword">guard</span> destination.child == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 只有在外部没有设置 child 时，才去主动寻找依赖</span></div><div class="line">        <span class="keyword">let</span> child = <span class="type">Router</span>.makeDestination(to <span class="type">RoutableService</span>&lt;<span class="type">Child</span>&gt;(), preparation &#123; child <span class="keyword">in</span></div><div class="line">            <span class="comment">// 设置 child 的依赖，防止 child 内部再去寻找 parent 依赖，导致循环</span></div><div class="line">            child.parent = destination</div><div class="line">        &#125;)</div><div class="line">        destination.child = child</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">ChildObject</span>, <span class="title">PerformRouteConfig</span>&gt; </span>&#123;</div><div class="line">      </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: PerformRouteConfig)</span></span> -&gt; <span class="type">ChildObject</span>? &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">ChildObject</span>()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareDestination</span><span class="params">(<span class="number">_</span> destination: ChildObject, configuration: PerformRouteConfig)</span></span> &#123;</div><div class="line">        <span class="keyword">guard</span> destination.parent == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 只有在外部没有设置 parent 时，才去主动寻找依赖</span></div><div class="line">        <span class="keyword">let</span> parent = <span class="type">Router</span>.makeDestination(to <span class="type">RoutableService</span>&lt;<span class="type">Parent</span>&gt;(), preparation &#123; parent <span class="keyword">in</span></div><div class="line">            <span class="comment">// 设置 parent 的依赖，防止 parent 内部再去寻找 child 依赖，导致循环</span></div><div class="line">            parent.child = destination</div><div class="line">        &#125;)</div><div class="line">        destination.parent = parent</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ParentRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">ParentObject</span> *, <span class="title">ZIKPerformRouteConfiguration</span> *&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ParentRouter</span></span></div><div class="line"></div><div class="line">- (ParentObject *)destinationWithConfiguration:(ZIKPerformRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">return</span> [ParentObject new];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)prepareDestination:(ParentObject *)destination configuration:(ZIKPerformRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">if</span> (destination.child) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 只有在外部没有设置 child 时，才去主动寻找依赖</span></div><div class="line">    destination.child = [ZIKRouterToService(Child) makeDestinationWithPreparation:^(<span class="keyword">id</span>&lt;Child&gt; child) &#123;</div><div class="line">        <span class="comment">// 设置 child 的依赖，防止 child 内部再去寻找 parent 依赖，导致循环</span></div><div class="line">        child.parent = destination;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ChildRouter</span>: <span class="title">ZIKServiceRouter</span>&lt;<span class="title">ChildObject</span> *, <span class="title">ZIKPerformRouteConfiguration</span> *&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ChildRouter</span></span></div><div class="line"></div><div class="line">- (ChildObject *)destinationWithConfiguration:(ZIKPerformRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">return</span> [ChildObject new];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)prepareDestination:(ChildObject *)destination configuration:(ZIKPerformRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">if</span> (destination.parent) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 只有在外部没有设置 parent 时，才去主动寻找依赖</span></div><div class="line">    destination.parent = [ZIKRouterToService(Parent) makeDestinationWithPreparation:^(<span class="keyword">id</span>&lt;Parent&gt; parent) &#123;</div><div class="line">        <span class="comment">// 设置 parent 的依赖，防止 parent 内部再去寻找 child 依赖，导致循环</span></div><div class="line">        parent.child = destination;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>这样就能避免循环依赖导致的无限递归问题。</p>
<h2 id="模块适配器"><a href="#模块适配器" class="headerlink" title="模块适配器"></a>模块适配器</h2><p>当使用 protocol 管理模块时，protocol 必定会出现在多个模块中。那么此时如何让每个模块单独编译呢？</p>
<p>使用适配器模式，可以让不同模块使用各自不同的 protocol 和同一个模块交互。</p>
<h3 id="required-protocol-和-provided-protocol"><a href="#required-protocol-和-provided-protocol" class="headerlink" title="required protocol 和 provided protocol"></a>required protocol 和 provided protocol</h3><p>你可以为同一个 router 注册多个 protocol。</p>
<p>根据依赖关系，接口可以分为<code>required protocol</code>和<code>provided protocol</code>。模块本身提供的接口是<code>provided protocol</code>，模块的调用者需要使用的接口是<code>required protocol</code>。</p>
<p><code>required protocol</code>是<code>provided protocol</code>的子集，调用者只需要声明自己用到的那些接口，不必引入整个<code>provided protocol</code>，这样可以让模块间的耦合进一步减少。</p>
<p>在 UML 的<a href="http://www.uml-diagrams.org/component-diagrams.html" target="_blank" rel="external">组件图</a>中，就很明确地表现出了这两者的概念。下图中的半圆就是<code>Required Interface</code>，框外的圆圈就是<code>Provided Interface</code>：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5879294-6309bffe07ebf178.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="组件图"></p>
<p>那么如何实施<code>Required Interface</code>和<code>Provided Interface</code>？从架构分层上看，所有的模块都是依附于一个更上层的宿主 app 环境存在的，应该由使用这些模块的宿主 app 在一个 adapter 里进行接口适配，从而使得调用者可以继续在内部使用<code>required protocol</code>，adapter 负责把<code>required protocol</code>和修改后的<code>provided protocol</code>进行适配。整个过程模块都无感知。</p>
<p>这时候，调用者中定义的<code>required protocol</code>就相当于是在声明自己所依赖的外部模块。</p>
<h3 id="为provided模块添加required-protocol"><a href="#为provided模块添加required-protocol" class="headerlink" title="为provided模块添加required protocol"></a>为<code>provided</code>模块添加<code>required protocol</code></h3><p>模块适配的工作全部由模块的使用和装配者 App Context 完成，最少时只需要两行代码。</p>
<p>例如，某个模块需要展示一个登陆界面，而且这个登陆界面可以显示一段自定义的提示语。</p>
<p>调用者模块示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用者中声明的依赖接口，表明自身依赖一个登陆界面</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RequiredLoginViewInput</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> message: <span class="type">String</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">//显示在登陆界面上的自定义提示语</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用者中调用 login 模块</span></div><div class="line"><span class="type">Router</span>.makeDestination(to: <span class="type">RoutableView</span>&lt;<span class="type">RequiredLoginViewInput</span>&gt;(), preparation: &#123;</div><div class="line">    destination.message = <span class="string">"请登录"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用者中声明的依赖接口，表明自身依赖一个登陆界面</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RequiredLoginViewInput</span> &lt;<span class="title">ZIKViewRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *message;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 调用者中调用 login 模块</span></div><div class="line">[ZIKRouterToView(RequiredLoginViewInput) makeDestinationWithPraparation:^(<span class="keyword">id</span>&lt;RequiredLoginViewInput&gt; destination) &#123;</div><div class="line">    destination.message = <span class="string">@"请登录"</span>;</div><div class="line">&#125;];</div></pre></td></tr></table></figure><br><br></details>

<p>实际登陆界面提供的接口则是<code>ProvidedLoginViewInput</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实际登陆界面提供的接口</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProvidedLoginViewInput</span> </span>&#123;</div><div class="line">   <span class="keyword">var</span> message: <span class="type">String</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实际登陆界面提供的接口</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProvidedLoginViewInput</span> &lt;<span class="title">ZIKViewRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *message;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>适配的代码由宿主 app 实现，让登陆界面支持 <code>RequiredLoginViewInput</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 让模块支持 required protocol，只需要添加一个 protocol 扩展即可</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LoginViewController</span>: <span class="title">RequiredLoginViewInput</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 让模块支持 required protocol，只需要添加一个 protocol 扩展即可</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LoginViewController</span> (<span class="title">ModuleAAdapter</span>) &lt;<span class="title">RequiredLoginViewInput</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LoginViewController</span> (<span class="title">ModuleAAdapter</span>)</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>并且让登陆界面的 router 也支持 <code>RequiredLoginViewInput</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果可以获取到 router 类，可以直接为 router 添加 RequiredLoginViewInput</span></div><div class="line"><span class="type">LoginViewRouter</span>.register(<span class="type">RoutableView</span>&lt;<span class="type">RequiredLoginViewInput</span>&gt;())</div><div class="line"><span class="comment">// 如果不能得到对应模块的 router，可以用 adapter 进行转发</span></div><div class="line"><span class="type">ZIKViewRouteAdapter</span>.register(adapter: <span class="type">RoutableView</span>&lt;<span class="type">RequiredLoginViewInput</span>&gt;(), forAdaptee: <span class="type">RoutableView</span>&lt;<span class="type">ProvidedLoginViewInput</span>&gt;())</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果可以获取到 router 类，可以直接为 router 添加 RequiredLoginViewInput</span></div><div class="line">[LoginViewRouter registerViewProtocol:ZIKRoutable(RequiredLoginViewInput)];</div><div class="line"><span class="comment">//如果不能得到对应模块的 router，可以注册 adapter</span></div><div class="line">[<span class="keyword">self</span> registerDestinationAdapter:ZIKRoutable(RequiredLoginViewInput) forAdaptee:ZIKRoutable(ProvidedLoginViewInput)];</div></pre></td></tr></table></figure><br><br></details>

<p>适配之后，<code>RequiredLoginViewInput</code>就能和<code>ProvidedLoginViewInput</code>一样使用，获取到同一个模块了：</p>
<p>调用者模块示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="type">Router</span>.makeDestination(to: <span class="type">RoutableView</span>&lt;<span class="type">RequiredLoginViewInput</span>&gt;(), preparation: &#123;</div><div class="line">    destination.message = <span class="string">"请登录"</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// ProvidedLoginViewInput 和 RequiredLoginViewInput 能获取到同一个 router</span></div><div class="line"><span class="type">Router</span>.makeDestination(to: <span class="type">RoutableView</span>&lt;<span class="type">ProvidedLoginViewInput</span>&gt;(), preparation: &#123;</div><div class="line">    destination.message = <span class="string">"请登录"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[ZIKRouterToView(RequiredLoginViewInput) makeDestinationWithPraparation:^(<span class="keyword">id</span>&lt;RequiredLoginViewInput&gt; destination) &#123;</div><div class="line">    destination.message = <span class="string">@"请登录"</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// ProvidedLoginViewInput 和 RequiredLoginViewInput 能获取到同一个 router</span></div><div class="line">[ZIKRouterToView(RequiredLoginViewInput) makeDestinationWithPraparation:^(<span class="keyword">id</span>&lt;ProvidedLoginViewInput&gt; destination) &#123;</div><div class="line">    destination.message = <span class="string">@"请登录"</span>;</div><div class="line">&#125;];</div></pre></td></tr></table></figure><br><br></details>

<h3 id="接口适配"><a href="#接口适配" class="headerlink" title="接口适配"></a>接口适配</h3><p>有时候<code>ProvidedLoginViewInput</code>和<code>RequiredLoginViewInput</code>的接口名可能会稍有不同，此时需要用 category、extension、子类、proxy 类等方式进行接口适配。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProvidedLoginViewInput</span> </span>&#123;</div><div class="line">   <span class="keyword">var</span> notifyString: <span class="type">String</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">// 接口名不同</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProvidedLoginViewInput</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *notifyString; <span class="comment">// 接口名不同</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>适配时需要进行接口转发，让登陆界面支持 <code>RequiredLoginViewInput</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LoginViewController</span>: <span class="title">RequiredLoginViewInput</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> message: <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> notifyString</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            notifyString = newValue</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LoginViewController</span> (<span class="title">ModuleAAdapter</span>) &lt;<span class="title">RequiredLoginViewInput</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *message;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LoginViewController</span> (<span class="title">ModuleAAdapter</span>)</span></div><div class="line">- (<span class="keyword">void</span>)setMessage:(<span class="built_in">NSString</span> *)message &#123;</div><div class="line">true<span class="keyword">self</span>.notifyString = message;</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSString</span> *)message &#123;</div><div class="line">true<span class="keyword">return</span> <span class="keyword">self</span>.notifyString;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="用中介者转发接口"><a href="#用中介者转发接口" class="headerlink" title="用中介者转发接口"></a>用中介者转发接口</h3><p>如果不能直接为模块添加<code>required protocol</code>，比如 protocol 里的一些 delegate 需要兼容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RequiredLoginViewDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didFinishLogin</span><span class="params">()</span></span> -&gt; <span class="type">Void</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RequiredLoginViewInput</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> message: <span class="type">String</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">  <span class="keyword">var</span> delegate: <span class="type">RequiredLoginViewDelegate</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RequiredLoginViewDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)didFinishLogin;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RequiredLoginViewInput</span> &lt;<span class="title">ZIKViewRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *message;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;RequiredLoginViewDelegate&gt; delegate;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>而模块里的 delegate 接口不一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProvidedLoginViewDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didLogin</span><span class="params">()</span></span> -&gt; <span class="type">Void</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProvidedLoginViewInput</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> notifyString: <span class="type">String</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">  <span class="keyword">var</span> delegate: <span class="type">ProvidedLoginViewDelegate</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProvidedLoginViewDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)didLogin;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProvidedLoginViewInput</span> &lt;<span class="title">ZIKViewRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *notifyString;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;ProvidedLoginViewDelegate&gt; delegate;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>相同方法有不同参数类型时，可以用一个新的 router 代替真正的 router，在新的 router 里插入一个中介者，负责转发接口：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReqiredLoginViewRouter</span>: <span class="title">ProvidedLoginViewRouter</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ZIKViewRouteConfiguration)</span></span> -&gt; <span class="type">RequiredLoginViewInput</span>? &#123;</div><div class="line">       <span class="keyword">let</span> realDestination: <span class="type">ProvidedLoginViewInput</span> = <span class="keyword">super</span>.destination(with configuration)</div><div class="line">       <span class="comment">// proxy 负责把 RequiredLoginViewInput 转发为 ProvidedLoginViewInput</span></div><div class="line">       <span class="keyword">let</span> proxy: <span class="type">RequiredLoginViewInput</span> = <span class="type">ProxyForDestination</span>(realDestination)</div><div class="line">       <span class="keyword">return</span> proxy</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ReqiredLoginViewRouter</span> : <span class="title">ProvidedLoginViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RequiredLoginViewRouter</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">   <span class="keyword">id</span>&lt;ProvidedLoginViewInput&gt; realDestination = [<span class="keyword">super</span> destinationWithConfiguration:configuration];</div><div class="line">    <span class="comment">// proxy 负责把 RequiredLoginViewInput 转发为 ProvidedLoginViewInput</span></div><div class="line">    <span class="keyword">id</span>&lt;RequiredLoginViewInput&gt; proxy = ProxyForDestination(realDestination);</div><div class="line">    <span class="keyword">return</span> mediator;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>对于普通OC类，proxy 可以用 NSProxy 来实现。对于 UIKit 中的那些复杂的 UI 类，或者 Swift 类，可以用子类，然后在子类中重写方法，进行模块适配。</p>
<h3 id="声明式依赖"><a href="#声明式依赖" class="headerlink" title="声明式依赖"></a>声明式依赖</h3><p>利用之前的静态路由检查机制，模块只需要声明 required 接口，就能保证对应的模块必定存在。</p>
<p>模块无需在自己的接口里声明依赖，如果模块需要新增依赖，只需要创建新的 required 接口即可，无需修改接口本身。这样也能避免依赖变动导致的接口变化，减少接口维护的成本。</p>
<h3 id="模块提供默认的依赖配置"><a href="#模块提供默认的依赖配置" class="headerlink" title="模块提供默认的依赖配置"></a>模块提供默认的依赖配置</h3><p>每次引入模块，宿主 app 都需要写一份适配代码，虽然大多数情况下只有两行，但是我们想尽量减少宿主 app 的维护职责。</p>
<p>此时，可以让模块提供一份默认的依赖，用宏定义包裹，绕过编译检查。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#<span class="keyword">if</span> <span class="type">USE_DEFAULT_DEPENDENCY</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> ProvidedLoginModule</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">registerDefaultDependency</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="type">ZIKViewRouteAdapter</span>.register(adapter: <span class="type">RoutableView</span>&lt;<span class="type">RequiredLoginViewInput</span>&gt;(), forAdaptee: <span class="type">RoutableView</span>&lt;<span class="type">ProvidedLoginViewInput</span>&gt;())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProvidedLoginViewController</span>: <span class="title">RequiredLoginViewInput</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if USE_DEFAULT_DEPENDENCY</span></div><div class="line"></div><div class="line"><span class="keyword">@import</span> ProvidedLoginModule;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> registerDefaultDependency() &#123;</div><div class="line">    [ZIKViewRouteAdapter registerDestinationAdapter:ZIKRoutable(RequiredLoginViewInput) forAdaptee:ZIKRoutable(ProvidedLoginViewInput)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 宏定义，默认的适配代码</span></div><div class="line"><span class="meta">#define ADAPT_DEFAULT_DEPENDENCY    \</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ProvidedLoginViewController</span> (<span class="title">Adapter</span>) &lt;<span class="title">RequiredLoginViewInput</span>&gt;    \</span></div><div class="line"><span class="keyword">@end</span>    \</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ProvidedLoginViewController</span> (<span class="title">Adapter</span>) \</span></div><div class="line"><span class="keyword">@end</span>    \</div><div class="line"></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure><br><br></details>

<p>如果宿主 app 要使用默认依赖，就在<code>.xcconfig</code>里设置<code>Preprocessor Macros</code>，开启宏定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GCC_PREPROCESSOR_DEFINITIONS = $(inherited) USE_DEFAULT_DEPENDENCY=1</div></pre></td></tr></table></figure>
<p>如果是 Swift 模块，需要在模块的 target 里设置<code>Active Compilation Conditions</code>，添加编译宏<code>USE_DEFAULT_DEPENDENCY</code>。</p>
<p>宿主 app 直接调用默认的适配代码即可，不用再负责维护：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">registerAdapters</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 注册默认的依赖</span></div><div class="line">    registerDefaultDependency()</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C示例</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> registerAdapters() &#123;</div><div class="line">    <span class="comment">// 注册默认的依赖</span></div><div class="line">    registerDefaultDependency();</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用默认的适配代码</span></div><div class="line">ADAPT_DEFAULT_DEPENDENCY</div></pre></td></tr></table></figure><br><br></details>

<p>如果宿主 app 需要替换使用另一个 provided 模块，可以关闭宏定义，再写一份另外的适配代码，即可替换依赖。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p><img src="Required-Provided.png" alt=""></p>
<p>区分了<code>required protocol</code>和<code>provided protocol</code>后，就可以实现真正的模块化。在调用者声明了所需要的<code>required protocol</code>后，被调用模块就可以随时被替换成另一个相同功能的模块。</p>
<p>参考 demo 中的<code>ZIKLoginModule</code>示例模块，登录模块依赖于一个弹窗模块，而这个弹窗模块在<code>ZIKRouterDemo</code>和<code>ZIKRouterDemo-macOS</code>中是不同的，而在切换弹窗模块时，登录模块中的代码不需要做任何改变。</p>
<h3 id="使用-adapter-的规范"><a href="#使用-adapter-的规范" class="headerlink" title="使用 adapter 的规范"></a>使用 adapter 的规范</h3><p>一般来说，并不需要立即把所有的 protocol 都分离为<code>required protocol</code>和<code>provided protocol</code>。调用模块和目的模块可以暂时共用 protocol，或者只是简单地改个名字，让<code>required protocol</code>作为<code>provided protocol</code>的子集，在第一次需要替换模块的时候再用 category、extension、proxy、subclass 等技术进行接口适配。</p>
<p>接口适配也不能滥用，因为成本比较高，而且并非所有的接口都能适配，例如同步接口和异步接口就难以适配。</p>
<p>对于模块间耦合的处理，有这么几条建议：</p>
<ul>
<li>如果依赖的是提供特定功能的模块，没有通用性，直接引用类即可</li>
<li>如果是依赖某些简单的通用模块（例如日志模块），可以在模块的接口上把依赖交给外部来设置，例如 block 的形式</li>
<li>大部分需要解耦的模块都是需要重用的业务模块，如果你的模块不需要重用，并且也不需要分工开发，直接引用对应类即可</li>
<li>大部分情况下建议共用 protocol，或者让<code>required protocol</code>作为<code>provided protocol</code>的子集，接口名保持一致</li>
<li>只有在你的业务模块的确允许使用者使用不同的依赖模块时，才进行多个接口间的适配。例如需要跨平台的模块，例如登录界面模块允许不同的 app 使用不同的登陆 service 模块</li>
</ul>
<p>通过<code>required protocol</code>和<code>provided protocol</code>，我们就实现了模块间的完全解耦。</p>
<h2 id="模块间通信"><a href="#模块间通信" class="headerlink" title="模块间通信"></a>模块间通信</h2><p>模块间通信有多种方式，解耦程度也各有不同。这里只讨论接口交互的方式。</p>
<h3 id="控制流-input-和-output"><a href="#控制流-input-和-output" class="headerlink" title="控制流 input 和 output"></a>控制流 input 和 output</h3><p>模块的对外接口可以分为 input 和 output。两者的区别主要是控制流的主动权归属不同。</p>
<p>Input 是由外部主动调用的接口，控制流的发起者在外部，例如外部调用 view 的 UI 修改接口。</p>
<p>Output 是模块内部主动调用外部实现的接口，控制流的发起者在内部，需要外部实现 output 所要求的方法。例如输出 UI 事件、事件回调、获取外部的 dataSource。iOS 中常用的 delegate 模式，也是一种 output。</p>
<h3 id="设置-input-和-output"><a href="#设置-input-和-output" class="headerlink" title="设置 input 和 output"></a>设置 input 和 output</h3><p>模块设计好 input 和 output，然后在模块创建的时候，设置好模块之间的 input 和 output 关系，即可配置好模块间通信，同时充分解耦。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoteListViewController</span>: <span class="title">UIViewController</span>, <span class="title">EditorViewOutput</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showEditor</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> destination = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableView</span>&lt;<span class="type">EditorViewInput</span>&gt;(), preparation: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] destination <span class="keyword">in</span></div><div class="line">            destination.output = <span class="keyword">self</span></div><div class="line">        &#125;)</div><div class="line">        present(destination, animated: <span class="literal">true</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">EditorViewInput</span> </span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">EditorViewOutput</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><p><img src="Submodule.png" alt=""></p>
<p>大部分方案都没有讨论子模块存在的情况。如果使用了 MVVM 或者 VIPER 架构，此时一个 view controller 使用了 child view controller，那多个模块的 view model 和 interactor 之间如何交互？子模块由谁初始化、由谁管理？</p>
<p>有些方案是直接在父 view model 里创建和使用子 view model，但是这样就导致了 view 的实现方式影响了view model 的实现，如果父 view 里替换使用了另一个子 view，那父 view model 里的代码也需要修改。</p>
<h4 id="子模块的来源"><a href="#子模块的来源" class="headerlink" title="子模块的来源"></a>子模块的来源</h4><p>子模块的来源有：</p>
<ul>
<li>父 view 引用了一个封装好的子 view 控件，连带着引入了子 view 的整个 MVVM 或者 VIPER 模块</li>
<li>View model 或者 interactor 里使用了一个 Service</li>
</ul>
<h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><p>子 view 可能是一个 UIView，也可能是一个 Child UIViewController。因此子 view 有可能需要向外部请求数据，也可能独立完成所有任务，不需要依赖父模块。</p>
<p>如果子 view 可以独立，那在子模块里不会出现和父模块交互的逻辑，只有把一些事件通过 output 传递出去的接口。这时只需要把子 view 的 input 接口封装在父 view 的 input 接口里即可，父 view model / presenter / interactor 是不知道父 view 提供的这几个接口是通过子 view 实现的。</p>
<p>如果父模块需要调用子模块的业务接口，或接收子模块的数据或业务事件，并且不想影响 view 的接口，可以把子 view model / presenter / interactor 作为父 view model / presenter / interactor 的一个 service，在引入子模块时，注入到父 view model / presenter / interactor，从而绕过 view 层。这样子模块和父模块就能通过 service 的形式进行通信了，而这时，父模块也不知道这个 service 是来自子模块里的。</p>
<p>在这样的设计下，子模块和父模块是不知道彼此的存在的，只是通过接口进行交互。好处是父 view 如果想要更换为另一个相同功能的子 view 控件，就只需要在父 view 里修改，不会影响其他的 view model / presenter / interactor。</p>
<p>父模块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> viewModel: <span class="type">EditorViewModel</span>!</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addTextView</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> textViewController = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableView</span>&lt;<span class="type">TextViewInput</span>&gt;()) &#123; (destination) <span class="keyword">in</span></div><div class="line">            <span class="comment">// 设置模块间交互</span></div><div class="line">            <span class="comment">// 原本父 view 是无法接触到子模块的 view model / presenter / interactor</span></div><div class="line">            <span class="comment">// 此时子模块是把这些内部组件作为业务 input 开放给了外部</span></div><div class="line">            <span class="keyword">self</span>.viewModel.textService = destination.viewModel</div><div class="line">            destination.viewModel.output = <span class="keyword">self</span>.viewModel</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        addChildViewController(textViewController)</div><div class="line">        view.addSubview(textViewController.view)</div><div class="line">        textViewController.didMove(toParentViewController: <span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewController</span>: <span class="title">UIViewController</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;EditorViewModel&gt; viewModel;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewController</span></span></div><div class="line">  </div><div class="line">- (<span class="keyword">void</span>)addTextView &#123;</div><div class="line">    <span class="built_in">UIViewController</span> *textViewController = [ZIKRouterToView(TextViewInput) makeDestinationWithPreparation:^(<span class="keyword">id</span>&lt;TextViewInput&gt; destination) &#123;</div><div class="line">        <span class="comment">// 设置模块间交互</span></div><div class="line">        <span class="comment">// 原本父 view 是无法接触到子模块的 view model / presenter / interactor</span></div><div class="line">        <span class="comment">// 此时子模块是把这些内部组件作为业务 input 开放给了外部        </span></div><div class="line">        <span class="keyword">self</span>.viewModel.textService = destination.viewModel;</div><div class="line">        destination.viewModel.output = <span class="keyword">self</span>.viewModel;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [<span class="keyword">self</span> addChildViewController:textViewController];</div><div class="line">    [<span class="keyword">self</span>.view addSubview: textViewController.view];</div><div class="line">    [textViewController didMoveToParentViewController: <span class="keyword">self</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>子模块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TextViewInput</span> </span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">TextViewModuleOutput</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">    <span class="keyword">var</span> viewModel: <span class="type">TextViewModel</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextViewController</span>: <span class="title">UIViewController</span>, <span class="title">TextViewInput</span> </span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">TextViewModuleOutput</span>?</div><div class="line">    <span class="keyword">var</span> viewModel: <span class="type">TextViewModel</span>!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">TextViewInput</span> &lt;<span class="title">ZIKViewRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;TextViewModuleOutput&gt; output;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;TextViewModel&gt; viewModel;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TextViewController</span>: <span class="title">UIViewController</span> &lt;<span class="title">TextViewInput</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;TextViewModuleOutput&gt; output;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;TextViewModel&gt; viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="Output-的适配"><a href="#Output-的适配" class="headerlink" title="Output 的适配"></a>Output 的适配</h3><p>在使用 output 时，模块适配会带来一定麻烦。</p>
<p>例如这样一对 required-provided protocol：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RequiredEditorViewInput</span> </span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">RequiredEditorViewOutput</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProvidedEditorViewInput</span> </span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">ProvidedEditorViewOutput</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RequiredEditorViewInput</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;RequiredEditorViewOutput&gt; output;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProvidedEditorViewInput</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;ProvidedEditorViewOutput&gt; output;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>由于 output 的实现者不是固定的，因此无法让所有的 output 类都同时适配<code>RequiredEditorViewOutput</code>和<code>ProvidedEditorViewOutput</code>。此时建议直接使用对应的 protocol，不使用 required-provided 模式。</p>
<p>如果你仍然想要使用 required-provided 模式，那就需要用工厂模式来传递 output ，在内部用 proxy 进行适配。</p>
<p>实际模块的 router：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProvidedEditorViewModuleInput</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> makeDestinationWith(<span class="number">_</span> output: <span class="type">ProvidedEditorViewOutput</span>?) -&gt; <span class="type">ProvidedEditorViewInput</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProvidedEditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewController</span>, <span class="title">ViewRouteConfig</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">registerRoutableDestination</span>() </span>&#123;</div><div class="line">        register(<span class="type">RoutableViewModule</span>&lt;<span class="type">ProvidedEditorViewModuleInput</span>&gt;())</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultRouteConfiguration</span>() -&gt; <span class="title">ViewRouteConfig</span> </span>&#123;</div><div class="line">        <span class="keyword">let</span> config = <span class="type">ViewMakeableConfiguration</span>&lt;<span class="type">ProvidedViewInput</span>, (<span class="type">ProvidedEditorViewOutput</span>?) -&gt; <span class="type">ProvidedViewInput</span>?&gt;(&#123; <span class="number">_</span> <span class="keyword">in</span>&#125;)</div><div class="line">        config.makeDestinationWith = &#123; [<span class="keyword">unowned</span> config] output <span class="keyword">in</span></div><div class="line">            <span class="comment">// 设置 output</span></div><div class="line">            <span class="keyword">let</span> viewModel = <span class="type">EditorViewModel</span>(output: output)</div><div class="line">            config.makedDestination = <span class="type">EditorViewController</span>(viewModel: viewModel)</div><div class="line">            <span class="keyword">return</span> config.makedDestination</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> config</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">EditorViewController</span>? &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> config = configuration <span class="keyword">as</span>? <span class="type">ViewMakeableConfiguration</span>&lt;<span class="type">ProvidedViewInput</span>, (<span class="type">ProvidedEditorViewOutput</span>?) &#123;</div><div class="line">            <span class="keyword">return</span> config.makedDestination</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ProvidedEditorViewModuleInput</span> &lt;<span class="title">ZIKViewModuleRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;ProvidedEditorViewInput&gt; (makeDestinationWith)(<span class="keyword">id</span>&lt;ProvidedEditorViewOutput&gt; output);</div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ProvidedEditorViewRouter</span>: <span class="title">ZIKViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ProvidedEditorViewRouter</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)registerRoutableDestination &#123;</div><div class="line">    [<span class="keyword">self</span> registerModuleProtocol:ZIKRoutable(ProvidedEditorViewModuleInput)];  </div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (ZIKViewMakeableConfiguration *)defaultRouteConfiguration &#123;</div><div class="line">    ZIKViewMakeableConfiguration *config = [ZIKViewMakeableConfiguration new];</div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(config) weakConfig = config;</div><div class="line">    </div><div class="line">    config.makeDestinationWith = <span class="keyword">id</span> ^(<span class="keyword">id</span>&lt;ProvidedEditorViewOutput&gt; output) &#123;</div><div class="line">        <span class="comment">// 设置 output</span></div><div class="line">        EditorViewModel *viewModel = [[EditorViewModel alloc] initWithOutput:output];</div><div class="line">        weakConfig.makedDestination = [[EditorViewController alloc] initWithViewModel:viewModel];</div><div class="line">        <span class="keyword">return</span> weakConfig.makedDestination;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> config;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;PersonType&gt;)destinationWithConfiguration:(ZIKServiceMakeableConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">return</span> configuration.makedDestination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>适配代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RequiredEditorViewModuleInput</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> makeDestinationWith(<span class="number">_</span> output: <span class="type">RequiredEditorViewOutput</span>?) -&gt; <span class="type">RequiredEditorViewInput</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 用于适配的 required router</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequiredEditorViewRouter</span>: <span class="title">ProvidedEditorViewRouter</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">registerRoutableDestination</span>() </span>&#123;</div><div class="line">        register(<span class="type">RoutableViewModule</span>&lt;<span class="type">RequiredEditorViewModuleInput</span>&gt;())</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 兼容 configuration</span></div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultRouteConfiguration</span>() -&gt; <span class="title">PerformRouteConfig</span> </span>&#123;</div><div class="line">        <span class="keyword">let</span> config = <span class="keyword">super</span>.defaultRouteConfiguration()</div><div class="line">        <span class="keyword">let</span> makeDestinationWith = config.makeDestinationWith</div><div class="line">        </div><div class="line">        config.makeDestinationWith = &#123; requiredOutput <span class="keyword">in</span></div><div class="line">            <span class="comment">// proxy 负责把 RequiredEditorViewOutput 转为 ProvidedEditorViewOutput</span></div><div class="line">            <span class="keyword">let</span> providedOutput = <span class="type">EditorOutputProxy</span>(forwarding: requiredOutput)</div><div class="line">            <span class="keyword">return</span> makeDestinationWith(providedOutput)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> config</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorOutputProxy</span>: <span class="title">ProvidedEditorViewOutput</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> forwarding: <span class="type">RequiredEditorViewOutput</span></div><div class="line">    <span class="comment">// 实现 ProvidedEditorViewOutput，转发给 forwarding</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RequiredEditorViewModuleInput</span> &lt;<span class="title">ZIKViewModuleRoutable</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;RequiredEditorViewInput&gt; (makeDestinationWith)(<span class="keyword">id</span>&lt;RequiredEditorViewOutput&gt; output);</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 用于适配的 required router</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RequiredEditorViewRouter</span>: <span class="title">ProvidedEditorViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RequiredEditorViewRouter</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)registerRoutableDestination &#123;</div><div class="line">    [<span class="keyword">self</span> registerModuleProtocol:ZIKRoutable(RequiredEditorViewModuleInput)];  </div><div class="line">&#125;</div><div class="line"><span class="comment">// 兼容 configuration</span></div><div class="line">+ (ZIKViewMakeableConfiguration *)defaultRouteConfiguration &#123;</div><div class="line">    ZIKViewMakeableConfiguration *config = [<span class="keyword">super</span> defaultRouteConfiguration];</div><div class="line">    <span class="keyword">id</span>&lt;ProvidedEditorViewInput&gt;(^makeDestinationWith)(<span class="keyword">id</span>&lt;ProvidedEditorViewOutput&gt;) = config.makeDestinationWith;</div><div class="line">    </div><div class="line">    config.makeDestinationWith = <span class="keyword">id</span> ^(<span class="keyword">id</span>&lt;RequiredEditorViewOutput&gt; requiredOutput) &#123;</div><div class="line">        <span class="comment">// proxy 负责把 RequiredEditorViewOutput 转为 ProvidedEditorViewOutput</span></div><div class="line">        EditorOutputProxy *providedOutput = [[EditorOutputProxy alloc] initWithForwarding: requiredOutput];</div><div class="line">        <span class="keyword">return</span> makeDestinationWith(providedOutput);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> config;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;PersonType&gt;)destinationWithConfiguration:(ZIKServiceMakeableConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">return</span> configuration.makedDestination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="comment">// 实现 ProvidedEditorViewOutput，转发给 forwarding</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorOutputProxy</span>: <span class="title">NSProxy</span> &lt;<span class="title">ProvidedEditorViewOutput</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> forwarding;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorOutputProxy</span></span></div><div class="line">  </div><div class="line">- (<span class="keyword">instancetype</span>)initWithForwarding:(<span class="keyword">id</span>)forwarding &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">        _forwarding = forwarding;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.forwarding respondsToSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)protocol &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.forwarding conformsToProtocol:protocol];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.forwarding;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>可以看到，output 的适配有些繁琐。因此除非你的模块是通用模块，有实际的解耦需求，否则直接使用 provided protocol 即可。</p>
<h2 id="功能扩展"><a href="#功能扩展" class="headerlink" title="功能扩展"></a>功能扩展</h2><p>总结完使用接口进行模块解耦和依赖管理的方法，我们可以进一步对 router 进行扩展了。上面使用 <code>makeDestination</code> 创建模块是最基本的功能，使用 router 子类后，我们可以进行许多有用的功能扩展，这里给出一些示范。</p>
<h3 id="自动注册"><a href="#自动注册" class="headerlink" title="自动注册"></a>自动注册</h3><p>编写 router 代码时，需要注册 router 和 protocol 。在 OC 中可以在 +load 方法中注册，但是 Swift 里已经不能使用 +load 方法，而且分散在 +load 中的注册代码也不好管理。BeeHive 中通过宏定义和<code>__attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveServices&quot;&quot;&quot;)))</code>，把注册信息添加到了 mach-O 中的自定义区域，然后在启动时读取并自动注册，可惜这种方式在 Swift 中也无法使用了。</p>
<p>我们可以把注册代码写在 router 的<code>+registerRoutableDestination</code>方法里，然后逐个调用每个 router 类的<code>+registerRoutableDestination</code>方法即可。还可以更进一步，用 runtime 技术遍历 mach-O 中的<code>__DATA,__objc_classlist</code>区域的类列表，获取所有的 router 类，自动调用所有的<code>+registerRoutableDestination</code>方法。</p>
<p>把注册代码统一管理之后，如果不想使用自动注册，也能随时切换为手动注册。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span> </span>&#123;</div><div class="line">  </div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">registerRoutableDestination</span>() </span>&#123;</div><div class="line">        registerView(<span class="type">EditorViewController</span>.<span class="keyword">self</span>)</div><div class="line">        register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;())</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewRouter</span> : <span class="title">ZIKViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewRouter</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)registerRoutableDestination &#123;</div><div class="line">    [<span class="keyword">self</span> registerView:[EditorViewController <span class="keyword">class</span>]];</div><div class="line">    [<span class="keyword">self</span> registerViewProtocol:ZIKRoutable(EditorViewProtocol)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="封装界面跳转"><a href="#封装界面跳转" class="headerlink" title="封装界面跳转"></a>封装界面跳转</h3><p>iOS 中模块间耦合的原因之一，就是界面跳转的逻辑是通过 UIViewController 进行的，跳转功能被限制在了 view controller 上，导致数据流常常都绕不开 view 层。要想更好地管理跳转逻辑，就需要进行封装。</p>
<p>封装界面跳转可以屏蔽 UIKit 的细节，此时界面跳转的代码就可以放在非 view 层（例如 presenter、view model、interactor、service），并且能够跨平台，也能轻易地通过配置切换跳转方式。</p>
<p>如果是普通的模块，就用<code>ZIKServiceRouter</code>，而如果是界面模块，例如 <code>UIViewController</code> 和 <code>UIView</code>，就可以用<code>ZIKViewRouter</code>，在其中封装了界面跳转功能。</p>
<p>封装界面跳转后，使用方式如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//直接跳转到 editor 界面</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showEditor</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="type">Router</span>.perform(to: <span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;(), path: .push(from: <span class="keyword">self</span>))</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">//跳转到 editor 界面，跳转前用 protocol 配置界面</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">prepareAndShowEditor</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="type">Router</span>.perform(</div><div class="line">            to: <span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;(),</div><div class="line">            path: .push(from: <span class="keyword">self</span>),</div><div class="line">            preparation: &#123; destination <span class="keyword">in</span></div><div class="line">                <span class="comment">// 跳转前进行配置</span></div><div class="line">                <span class="comment">// destination 自动推断为 EditorViewProtocol</span></div><div class="line">            &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)showEditor &#123;</div><div class="line">    <span class="comment">//直接跳转到 editor 界面</span></div><div class="line">    [ZIKRouterToView(EditorViewProtocol) performPath:ZIKViewRoutePath.pushFrom(<span class="keyword">self</span>)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)prepareAndShowEditor &#123;</div><div class="line">    <span class="comment">//跳转到 editor 界面，跳转前用 protocol 配置界面</span></div><div class="line">    [ZIKRouterToView(EditorViewProtocol) </div><div class="line">        performPath:ZIKViewRoutePath.pushFrom(<span class="keyword">self</span>)</div><div class="line">        preparation:^(<span class="keyword">id</span>&lt;EditorViewProtocol&gt; destination) &#123;</div><div class="line">            <span class="comment">// 跳转前进行配置</span></div><div class="line">            <span class="comment">// destination 自动推断为 EditorViewProtocol</span></div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>可以用 <code>ViewRoutePath</code> 一键切换不同的跳转方式:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ViewRoutePath</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> push(from: <span class="type">UIViewController</span>)</div><div class="line">    <span class="keyword">case</span> presentModally(from: <span class="type">UIViewController</span>)</div><div class="line">    <span class="keyword">case</span> presentAsPopover(from: <span class="type">UIViewController</span>, configure: <span class="type">ZIKViewRoutePopoverConfigure</span>)</div><div class="line">    <span class="keyword">case</span> performSegue(from: <span class="type">UIViewController</span>, identifier: <span class="type">String</span>, sender: <span class="type">Any</span>?)</div><div class="line">    <span class="keyword">case</span> show(from: <span class="type">UIViewController</span>)</div><div class="line">    <span class="keyword">case</span> showDetail(from: <span class="type">UIViewController</span>)</div><div class="line">    <span class="keyword">case</span> addAsChildViewController(from: <span class="type">UIViewController</span>, addingChildViewHandler: (<span class="type">UIViewController</span>, @escaping () -&gt; <span class="type">Void</span>) -&gt; <span class="type">Void</span>)</div><div class="line">    <span class="keyword">case</span> addAsSubview(from: <span class="type">UIView</span>)</div><div class="line">    <span class="keyword">case</span> custom(from: <span class="type">ZIKViewRouteSource</span>?)</div><div class="line">    <span class="keyword">case</span> makeDestination</div><div class="line">    <span class="keyword">case</span> extensible(path: <span class="type">ZIKViewRoutePath</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而且在界面跳转后，还可以根据跳转时的跳转方式，一键回退界面，无需再手动区分 dismiss、pop 等各种情况：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> router: <span class="type">DestinationViewRouter</span>&lt;<span class="type">EditorViewProtocol</span>&gt;?</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showEditor</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// 持有 router</span></div><div class="line">        router = <span class="type">Router</span>.perform(to: <span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;(), path: .push(from: <span class="keyword">self</span>))</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Router 会对 editor view controller 执行 pop 操作，移除界面</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeEditor</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> router = router, router.canRemove <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        router.removeRoute()</div><div class="line">        router = <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestViewController</span>()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) ZIKDestinationViewRouter(<span class="keyword">id</span>&lt;EditorViewProtocol&gt;) *router;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)showEditor &#123;</div><div class="line">    <span class="comment">// 持有 router</span></div><div class="line">    <span class="keyword">self</span>.router = [ZIKRouterToView(EditorViewProtocol) performPath:ZIKViewRoutePath.pushFrom(<span class="keyword">self</span>)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Router 会对 editor view controller 执行 pop 操作，移除界面</span></div><div class="line">- (<span class="keyword">void</span>)removeEditor &#123;</div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.router canRemove]) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.router removeRoute];</div><div class="line">    <span class="keyword">self</span>.router = <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="自定义跳转"><a href="#自定义跳转" class="headerlink" title="自定义跳转"></a>自定义跳转</h3><p>有些界面的跳转方式很特殊，例如 tabbar 上的界面，需要通过切换 tabbar item 来进行。也有的界面有自定义的跳转动画，此时可以在 router 子类中重写对应方法，进行自定义跳转。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewController</span>, <span class="title">ViewRouteConfig</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">Any</span>? &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">EditorViewController</span>()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">canPerformCustomRoute</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">performCustomRoute</span><span class="params">(onDestination destination: EditorViewController, fromSource source: Any?, configuration: ViewRouteConfig)</span></span> &#123;</div><div class="line">        beginPerformRoute()</div><div class="line">        <span class="comment">// 自定义跳转</span></div><div class="line">        <span class="type">CustomAnimator</span>.transition(from: source, to: destination) &#123;</div><div class="line">            <span class="keyword">self</span>.endPerformRouteWithSuccess()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">canRemoveCustomRoute</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">removeCustomRoute</span><span class="params">(onDestination destination: EditorViewController, fromSource source: Any?, removeConfiguration: ViewRemoveConfig, configuration: ViewRouteConfig)</span></span> &#123;</div><div class="line">        beginRemoveRoute(fromSource: source)</div><div class="line">        <span class="comment">// 移除自定义跳转</span></div><div class="line">        <span class="type">CustomAnimator</span>.dismiss(destination) &#123;</div><div class="line">            <span class="keyword">self</span>.endRemoveRouteWithSuccess(onDestination: destination, fromSource: source)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">supportedRouteTypes</span>() -&gt; <span class="title">ZIKViewRouteTypeMask</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> [.custom, .viewControllerDefault]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewRouter</span> : <span class="title">ZIKViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewRouter</span></span></div><div class="line"></div><div class="line">- (EditorViewController *)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="keyword">return</span> [[EditorViewController alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)canPerformCustomRoute &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)performCustomRouteOnDestination:(<span class="keyword">id</span>)destination fromSource:(<span class="built_in">UIViewController</span> *)source configuration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    [<span class="keyword">self</span> beginPerformRoute];</div><div class="line">    <span class="comment">// 自定义跳转</span></div><div class="line">    [CustomAnimator transitionFrom:source to:destination completion:^&#123;</div><div class="line">        [<span class="keyword">self</span> endPerformRouteWithSuccess];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)canRemoveCustomRoute &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeCustomRouteOnDestination:(<span class="keyword">id</span>)destination fromSource:(<span class="built_in">UIViewController</span> *)source removeConfiguration:(ZIKViewRemoveConfiguration *)removeConfiguration configuration:(__kindof ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    [<span class="keyword">self</span> beginRemoveRouteFromSource:source];</div><div class="line">    <span class="comment">// 移除自定义跳转</span></div><div class="line">    [CustomAnimator dismiss:destination completion:^&#123;</div><div class="line">        [<span class="keyword">self</span> endRemoveRouteWithSuccessOnDestination:destination fromSource:source];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (ZIKViewRouteTypeMask)supportedRouteTypes &#123;</div><div class="line">    <span class="keyword">return</span> ZIKViewRouteTypeMaskCustom|ZIKViewRouteTypeMaskViewControllerDefault;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h3 id="支持-storyboard"><a href="#支持-storyboard" class="headerlink" title="支持 storyboard"></a>支持 storyboard</h3><p>很多项目使用了 storyboard，在进行模块化时，肯定不能要求所有使用 storyboard 的模块都改为使用代码。因此我们可以 hook 一些 storyboard 相关的方法，例如<code>-prepareSegue:sender:</code>，在其中调用<code>prepareDestination:configuring:</code>即可。</p>
<h3 id="URL-路由-1"><a href="#URL-路由-1" class="headerlink" title="URL 路由"></a>URL 路由</h3><p>虽然之前列出了 URL 路由的许多缺点，但是如果你的模块需要从 h5 界面调用，例如电商 app 需要实现跨平台的动态路由规则，那么 URL 路由就是最佳的方案。</p>
<p>但是我们并不想为了实现 URL 路由，使用另一套框架再重新封装一次模块。只需要在 router 上扩展 URL 路由的功能，即可同时用接口和 URL 管理模块。</p>
<p>你可以给 router 注册 url：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewProtocol</span>, <span class="title">ViewRouteConfig</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">registerRoutableDestination</span>() </span>&#123;</div><div class="line">        <span class="comment">// 注册 url</span></div><div class="line">        registerURLPattern(<span class="string">"app://editor/:title"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewRouter</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)registerRoutableDestination &#123;</div><div class="line">    <span class="comment">// 注册 url</span></div><div class="line">    [<span class="keyword">self</span> registerURLPattern:<span class="string">@"app://editor/:title"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>之后就可以用相应的 url 获取 router:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">ZIKAnyViewRouter</span>.performURL(<span class="string">"app://editor/test_note"</span>, path: .push(from: <span class="keyword">self</span>))</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ZIKAnyViewRouter performURL:<span class="string">@"app://editor/test_note"</span> path:ZIKViewRoutePath.pushFrom(<span class="keyword">self</span>)];</div></pre></td></tr></table></figure><br><br></details>

<p>以及处理 URL Scheme:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:])</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">let</span> urlString = url.absoluteString</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = <span class="type">ZIKAnyViewRouter</span>.performURL(urlString, fromSource: <span class="keyword">self</span>.rootViewController) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = <span class="type">ZIKAnyServiceRouter</span>.performURL(urlString) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)app openURL:(<span class="built_in">NSURL</span> *)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">UIApplicationOpenURLOptionsKey</span>,<span class="keyword">id</span>&gt; *)options &#123;</div><div class="line">    <span class="keyword">if</span> ([ZIKAnyViewRouter performURL:urlString fromSource:<span class="keyword">self</span>.rootViewController]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([ZIKAnyServiceRouter performURL:urlString]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br></details>

<p>每个 router 子类还能各自对 url 进行进一步处理，例如处理 url 中的参数、通过 url 执行对应方法、执行路由后发送返回值给调用者等。</p>
<p>每个项目对 URL 路由的需求都不一样，基于 ZIKRouter 强大的可扩展性，你也可以按照项目需求实现自己的 URL 路由规则。</p>
<h3 id="用-router-对象代替-router-子类"><a href="#用-router-对象代替-router-子类" class="headerlink" title="用 router 对象代替 router 子类"></a>用 router 对象代替 router 子类</h3><p>除了创建 router 子类，也可以使用通用的 router 实例对象，在每个对象的 block 属性中提供和 router 子类一样的功能，因此不必担心类过多的问题。原理就和用泛型 configuration 代替 configuration 子类一样。</p>
<p> ZIKViewRoute 对象通过 block 属性实现子类重写的效果，代码可以用链式调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="type">ZIKViewRoute</span>&lt;<span class="type">EditorViewController</span>, <span class="type">ViewRouteConfig</span>&gt;</div><div class="line">.make(withDestination: <span class="type">EditorViewController</span>.<span class="keyword">self</span>, makeDestination: (&#123; (config, router) -&gt; <span class="type">EditorViewController</span>? <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> <span class="type">EditorViewController</span>()</div><div class="line">&#125;))</div><div class="line">.prepareDestination(&#123; (destination, config, router) <span class="keyword">in</span></div><div class="line"></div><div class="line">&#125;).didFinishPrepareDestination(&#123; (destination, config, router) <span class="keyword">in</span></div><div class="line"></div><div class="line">&#125;)</div><div class="line">.register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;())</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[ZIKDestinationViewRoute(<span class="keyword">id</span>&lt;EditorViewProtocol&gt;) </div><div class="line"> makeRouteWithDestination:[ZIKInfoViewController <span class="keyword">class</span>] </div><div class="line"> makeDestination:^<span class="keyword">id</span>&lt;EditorViewProtocol&gt; _Nullable(ZIKViewRouteConfig *config, ZIKRouter *router) &#123;</div><div class="line">    <span class="keyword">return</span> [[EditorViewController alloc] init];</div><div class="line">&#125;]</div><div class="line">.prepareDestination(^(<span class="keyword">id</span>&lt;EditorViewProtocol&gt; destination, ZIKViewRouteConfig *config, ZIKViewRouter *router) &#123;</div><div class="line"></div><div class="line">&#125;)</div><div class="line">.didFinishPrepareDestination(^(<span class="keyword">id</span>&lt;EditorViewProtocol&gt; destination, ZIKViewRouteConfig *config, ZIKViewRouter *router) &#123;</div><div class="line"></div><div class="line">&#125;)</div><div class="line">.registerDestinationProtocol(ZIKRoutable(EditorViewProtocol));</div></pre></td></tr></table></figure><br><br></details>

<h3 id="简化-router-实现"><a href="#简化-router-实现" class="headerlink" title="简化 router 实现"></a>简化 router 实现</h3><p>基于 ZIKViewRoute 对象实现的 router，可以进一步简化 router 的实现代码。</p>
<p>如果你的类很简单，并不需要用到 router 子类，直接一行代码注册类即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">ZIKAnyViewRouter</span>.register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;(), forMakingView: <span class="type">EditorViewController</span>.<span class="keyword">self</span>)</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ZIKViewRouter registerViewProtocol:ZIKRoutable(EditorViewProtocol) forMakingView:[EditorViewController <span class="keyword">class</span>]];</div></pre></td></tr></table></figure><br><br></details>

<p>或者用 block 自定义创建对象的方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">ZIKAnyViewRouter</span>.register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;(), </div><div class="line">                 forMakingView: <span class="type">EditorViewController</span>.<span class="keyword">self</span>) &#123; (config, router) -&gt; <span class="type">EditorViewProtocol</span>? <span class="keyword">in</span></div><div class="line">                     <span class="keyword">return</span> <span class="type">EditorViewController</span>()</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[ZIKViewRouter</div><div class="line">    registerViewProtocol:ZIKRoutable(EditorViewProtocol)</div><div class="line">    forMakingView:[EditorViewController <span class="keyword">class</span>]</div><div class="line">    making:^<span class="keyword">id</span> _Nullable(ZIKViewRouteConfiguration *config, ZIKViewRouter *router) &#123;</div><div class="line">        <span class="keyword">return</span> [[EditorViewController alloc] init];</div><div class="line"> &#125;];</div></pre></td></tr></table></figure><br><br></details>

<p>或者指定用 C 函数创建对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function makeEditorViewController(config: <span class="type">ViewRouteConfig</span>) -&gt; <span class="type">EditorViewController</span>? &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">EditorViewController</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">ZIKAnyViewRouter</span>.register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;(), </div><div class="line">                 forMakingView: <span class="type">EditorViewController</span>.<span class="keyword">self</span>, making: makeEditorViewController)</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span>&lt;EditorViewController&gt; makeEditorViewController(ZIKViewRouteConfiguration *config) &#123;</div><div class="line">    <span class="keyword">return</span> [[EditorViewController alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">[ZIKViewRouter</div><div class="line">    registerViewProtocol:ZIKRoutable(EditorViewProtocol)</div><div class="line">    forMakingView:[EditorViewController <span class="keyword">class</span>]</div><div class="line">    factory:makeEditorViewController];</div></pre></td></tr></table></figure><br><br></details>

<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>有时候模块需要处理一些系统事件或者 app 的自定义事件，此时可以让 router 子类实现，再进行遍历分发。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeServiceRouter</span>: <span class="title">ZIKServiceRouter</span> </span>&#123;</div><div class="line">    <span class="meta">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">applicationDidEnterBackground</span>(<span class="title">_</span> <span class="title">application</span>: <span class="title">UIApplication</span>) </span>&#123;</div><div class="line">        <span class="comment">// handle applicationDidEnterBackground event</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">NSObject</span>, <span class="title">NSApplicationDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">applicationDidEnterBackground</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="type">Router</span>.enumerateAllViewRouters &#123; (routerType) <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> routerType.responds(to: #selector(applicationDidEnterBackground(<span class="number">_</span>:))) &#123;</div><div class="line">                routerType.perform(#selector(applicationDidEnterBackground(<span class="number">_</span>:)), with: application)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="type">Router</span>.enumerateAllServiceRouters &#123; (routerType) <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> routerType.responds(to: #selector(applicationDidEnterBackground(<span class="number">_</span>:))) &#123;</div><div class="line">                routerType.perform(#selector(applicationDidEnterBackground(<span class="number">_</span>:)), with: application)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SomeServiceRouter</span> : <span class="title">ZIKServiceRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SomeServiceRouter</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</div><div class="line">    <span class="comment">// handle applicationDidEnterBackground event</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</div><div class="line">    </div><div class="line">    [ZIKAnyViewRouter enumerateAllViewRouters:^(Class routerClass) &#123;</div><div class="line">        <span class="keyword">if</span> ([routerClass respondsToSelector:<span class="keyword">@selector</span>(applicationDidEnterBackground:)]) &#123;</div><div class="line">            [routerClass applicationDidEnterBackground:application];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    [ZIKAnyServiceRouter enumerateAllServiceRouters:^(Class routerClass) &#123;</div><div class="line">        <span class="keyword">if</span> ([routerClass respondsToSelector:<span class="keyword">@selector</span>(applicationDidEnterBackground:)]) &#123;</div><div class="line">            [routerClass applicationDidEnterBackground:application];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>借助于使用接口管理依赖的方案，我们在对模块进行单元测试时，可以自由配置 mock 依赖，而且无需 hook 模块内部的代码。</p>
<p>例如这样一个依赖于网络模块的登陆模块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 登录模块</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(account: String, password: String, completion: <span class="params">(Result&lt;LoginError&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        <span class="comment">// 内部使用 RequiredNetServiceInput 进行网络访问</span></div><div class="line">        <span class="keyword">let</span> netService = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableService</span>&lt;<span class="type">RequiredNetServiceInput</span></div><div class="line">        &gt;())</div><div class="line">        <span class="keyword">let</span> request = makeLoginRequest(account: account, password: password)</div><div class="line">        netService?.<span class="type">POST</span>(request: request, completion: completion)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 声明依赖</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RoutableService</span> <span class="title">where</span> <span class="title">Protocol</span> == <span class="title">RequiredNetServiceInput</span> </span>&#123;</div><div class="line">    <span class="keyword">init</span>() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 登录模块</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LoginService</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LoginService</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)loginWithAccount:(<span class="built_in">NSString</span> *)account password:(<span class="built_in">NSString</span> *)password  completion:(<span class="keyword">void</span>(^)(Result *result))completion &#123;</div><div class="line">    <span class="comment">// 内部使用 RequiredNetServiceInput 进行网络访问</span></div><div class="line">    <span class="keyword">id</span>&lt;RequiredNetServiceInput&gt; netService = [ZIKRouterToService(RequiredNetServiceInput) makeDestination];</div><div class="line">    Request *request = makeLoginRequest(account, password);</div><div class="line">    [netService POSTRequest:request completion: completion];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="comment">// 声明依赖</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RequiredNetServiceInput</span> &lt;<span class="title">ZIKServiceRoutable</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)POSTRequest:(Request *)request completion:(<span class="keyword">void</span>(^)(Result *result))completion;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>在编写单元测试时，不需要引入真实的网络模块，可以提供一个自定义的 mock 网络模块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockNetService</span>: <span class="title">RequiredNetServiceInput</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">POST</span><span class="params">(request: Request, completion: <span class="params">(Result&lt;NetError&gt;)</span></span></span> &#123;</div><div class="line">        completion(.success)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册 mock 依赖</span></div><div class="line"><span class="type">ZIKAnyServiceRouter</span>.register(<span class="type">RoutableService</span>&lt;<span class="type">RequiredNetServiceInput</span>&gt;(), </div><div class="line">                 forMakingService: <span class="type">MockNetService</span>.<span class="keyword">self</span>) &#123; (config, router) -&gt; <span class="type">EditorViewProtocol</span>? <span class="keyword">in</span></div><div class="line">                     <span class="keyword">return</span> <span class="type">MockNetService</span>()</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MockNetService</span> : <span class="title">NSObject</span> &lt;<span class="title">RequiredNetServiceInput</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MockNetService</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)POSTRequest:(Request *)request completion:(<span class="keyword">void</span>(^)(Result *result))completion &#123;</div><div class="line">    completion([Result success]);</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册 mock 依赖</span></div><div class="line">[ZIKServiceRouter registerServiceProtocol:ZIKRoutable(EditorViewInput) forMakingService:[MockNetService <span class="keyword">class</span>]];</div></pre></td></tr></table></figure><br><br></details>

<p>对于那些没有接口交互的外部依赖，例如只是简单的跳转到对应界面，则只需注册一个空白的 proxy。</p>
<p>单元测试代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginServiceTests</span>: <span class="title">XCTestCase</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testLoginSuccess</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> expectation = expectation(description: <span class="string">"end login"</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> loginService = <span class="type">LoginService</span>()</div><div class="line">        loginService.login(account: <span class="string">"account"</span>, password: <span class="string">"pwd"</span>) &#123; result <span class="keyword">in</span></div><div class="line">            expectation.fulfill()</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        waitForExpectations(timeout: <span class="number">5</span>, handler: &#123; <span class="keyword">if</span> <span class="keyword">let</span> error = $<span class="number">0</span> &#123;<span class="built_in">print</span>(error)&#125;&#125;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LoginServiceTests</span> : <span class="title">XCTestCase</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LoginServiceTests</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)testLoginSuccess &#123;</div><div class="line">    <span class="built_in">XCTestExpectation</span> *expectation = [<span class="keyword">self</span> expectationWithDescription:<span class="string">@"end login"</span>];</div><div class="line">    </div><div class="line">    [[LoginService new] loginWithAccount:<span class="string">@""</span> password:<span class="string">@""</span> completion:^(Result *result) &#123;</div><div class="line">        [expectation fulfill];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> waitForExpectationsWithTimeout:<span class="number">5</span> handler:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">        !error? : <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<p>使用接口管理依赖，可以更容易 mock，剥除外部依赖对测试的影响，让单元测试更稳定。</p>
<h2 id="接口版本管理"><a href="#接口版本管理" class="headerlink" title="接口版本管理"></a>接口版本管理</h2><p>使用接口管理模块时，还有一个问题需要注意。接口是会随着模块更新而变化的，这个接口已经被很多外部使用了，要如何减少接口变化产生的影响？</p>
<p>此时需要区分新接口和旧接口，区分版本，推出新接口的同时，保留旧接口，并将旧接口标记为废弃。这样使用者就可以暂时使用旧接口，渐进式地修改代码。</p>
<p>这部分可以参考 Swift 和 OC 中的版本管理宏。</p>
<p>接口废弃，可以暂时使用，建议尽快使用新接口代替：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift</span></div><div class="line"><span class="meta">@available</span>(iOS, deprecated: <span class="number">8.0</span>, message: <span class="string">"Use new interface instead"</span>)</div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Objective-C</span></div><div class="line">API_DEPRECATED_WITH_REPLACEMENT(<span class="string">"performPath:configuring:"</span>, ios(<span class="number">7.0</span>, <span class="number">7.0</span>));</div></pre></td></tr></table></figure>
<p>接口已经无效：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift</span></div><div class="line"><span class="meta">@available</span>(iOS, unavailable)</div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Objective-C</span></div><div class="line"><span class="built_in">NS_UNAVAILABLE</span></div></pre></td></tr></table></figure>
<h2 id="最终形态"><a href="#最终形态" class="headerlink" title="最终形态"></a>最终形态</h2><p>最后，一个 router 的最终形态就是下面这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorViewRouter</span>: <span class="title">ZIKViewRouter</span>&lt;<span class="title">EditorViewController</span>, <span class="title">ViewRouteConfig</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">registerRoutableDestination</span>() </span>&#123;</div><div class="line">        registerView(<span class="type">EditorViewController</span>.<span class="keyword">self</span>)</div><div class="line">        register(<span class="type">RoutableView</span>&lt;<span class="type">EditorViewProtocol</span>&gt;())</div><div class="line">        registerURLPattern(<span class="string">"app://editor/:title"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">processUserInfo</span><span class="params">(<span class="number">_</span> userInfo: [AnyHashable : Any] = [:], from url: URL)</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> title = userInfo[<span class="string">"title"</span>]</div><div class="line">        <span class="comment">// 处理 url 中的参数</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 子类重写，创建模块</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">destination</span><span class="params">(with configuration: ViewRouteConfig)</span></span> -&gt; <span class="type">Any</span>? &#123;</div><div class="line">        <span class="keyword">let</span> destination = <span class="type">EditorViewController</span>()</div><div class="line">        <span class="keyword">return</span> destination</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 配置模块，注入静态依赖</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareDestination</span><span class="params">(<span class="number">_</span> destination: EditorViewController, configuration: ViewRouteConfig)</span></span> &#123;</div><div class="line">        <span class="comment">// 注入 service 依赖</span></div><div class="line">        destination.storageService = <span class="type">Router</span>.makeDestination(to: <span class="type">RoutableService</span>&lt;<span class="type">EditorStorageServiceInput</span>&gt;())</div><div class="line">        <span class="comment">// 其他配置</span></div><div class="line">        <span class="comment">// 处理来自 url 的参数</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> title = configuration.userInfo[<span class="string">"title"</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</div><div class="line">            destination.title = title</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            destination.title = <span class="string">"默认标题"</span></div><div class="line">        &#125;        </div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 事件处理</span></div><div class="line">    <span class="meta">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">applicationDidEnterBackground</span>(<span class="title">_</span> <span class="title">application</span>: <span class="title">UIApplication</span>) </span>&#123;</div><div class="line">        <span class="comment">// handle applicationDidEnterBackground event</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<details><summary>Objective-C Sample</summary><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// editor 模块的 router</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EditorViewRouter</span> : <span class="title">ZIKViewRouter</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EditorViewRouter</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)registerRoutableDestination &#123;</div><div class="line">    [<span class="keyword">self</span> registerView:[EditorViewController <span class="keyword">class</span>]];</div><div class="line">    [<span class="keyword">self</span> registerViewProtocol:ZIKRoutable(EditorViewProtocol)];</div><div class="line">    [<span class="keyword">self</span> registerURLPattern:<span class="string">@"app://editor/:title"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)processUserInfo:(<span class="built_in">NSDictionary</span> *)userInfo fromURL:(<span class="built_in">NSURL</span> *)url &#123;</div><div class="line">    <span class="built_in">NSString</span> *title = userInfo[<span class="string">@"title"</span>];</div><div class="line">    <span class="comment">// 处理 url 中的参数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 子类重写，创建模块</span></div><div class="line">- (EditorViewController *)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    EditorViewController *destination = [[EditorViewController alloc] init];</div><div class="line">    <span class="keyword">return</span> destination;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 配置模块，注入静态依赖</span></div><div class="line">- (<span class="keyword">void</span>)prepareDestination:(EditorViewController *)destination configuration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    <span class="comment">// 注入 service 依赖</span></div><div class="line">    destination.storageService = [ZIKRouterToService(EditorStorageServiceInput) makeDestination];</div><div class="line">    <span class="comment">// 其他配置</span></div><div class="line">    <span class="comment">// 处理来自 url 的参数</span></div><div class="line">    <span class="built_in">NSString</span> *title = configuration.userInfo[<span class="string">@"title"</span>];</div><div class="line">    <span class="keyword">if</span> (title) &#123;</div><div class="line">        destination.title = title;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        destination.title = <span class="string">@"默认标题"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 事件处理</span></div><div class="line">+ (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</div><div class="line">    <span class="comment">// handle applicationDidEnterBackground event</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br></details>

<h2 id="基于接口进行解耦的优势"><a href="#基于接口进行解耦的优势" class="headerlink" title="基于接口进行解耦的优势"></a>基于接口进行解耦的优势</h2><p>我们可以看到基于接口管理模块的优势：</p>
<ul>
<li>依赖编译检查，实现严格的类型安全</li>
<li>依赖编译检查，减少重构时的成本</li>
<li>通过接口明确声明模块所需的依赖，允许外部进行依赖注入</li>
<li>保持动态特性的同时，进行路由检查，避免使用不存在的路由模块</li>
<li>利用接口，区分 required protocol 和 provided protocol，进行明确的模块适配，实现彻底解耦</li>
</ul>
<p>回过头看之前的 8 个解耦指标，ZIKRouter 已经完全满足。而 router 提供的多种模块管理方式（makeDestination、prepareDestination、依赖注入、页面跳转、storyboard 支持），能够覆盖大多数现有的场景，从而实现渐进式的模块化，减轻重构现有代码的成本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于组件化的探讨已经有不少了，在之前的文章”iOS VIPER架构实践(三)：面向接口的路由设计”中，综合比较了各种方案后，我倾向于使用面向接口的方式进行组件化。&lt;/p&gt;
&lt;p&gt;这是一篇从代码层面讲解模块解耦的文章，会全方位地展示如何实践面向接口的思想，尽量全面地探讨在模块
    
    </summary>
    
      <category term="代码架构" scheme="http://zuikyo.github.io/categories/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"/>
    
      <category term="组件化" scheme="http://zuikyo.github.io/categories/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="解耦" scheme="http://zuikyo.github.io/categories/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/%E7%BB%84%E4%BB%B6%E5%8C%96/%E8%A7%A3%E8%80%A6/"/>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向指南：静态分析</title>
    <link href="http://zuikyo.github.io/2018/02/16/iOS_reverse_engineering_guide-static_analyzing/"/>
    <id>http://zuikyo.github.io/2018/02/16/iOS_reverse_engineering_guide-static_analyzing/</id>
    <published>2018-02-15T18:15:00.000Z</published>
    <updated>2018-11-01T20:15:15.130Z</updated>
    
    <content type="html"><![CDATA[<p>静态分析是指对二进制包进行反编译，分析静态的代码逻辑。</p>
<p>本文内容包括：app 砸壳过程、工具和环境的坑、导出 OC 头文件、使用 hopper 和 IDA 反编译、arm 寄存器功能、静态分析经验、推荐的 IDA 插件、如何分析系统库。</p>
<h2 id="对-app-砸壳解密"><a href="#对-app-砸壳解密" class="headerlink" title="对 app 砸壳解密"></a><a name="decrypt"></a>对 app 砸壳解密</h2><p>从 App Store 下载的 app 是经过加密的，需要对其进行解密后，才能进行分析。如果你懒得砸壳，可以直接去各种苹果助手下载越狱版 app，那些是已经解密过的。但是如果要找的 app 在助手上没有，就只能自己砸壳了。</p>
<p>砸壳可以使用 dumpdecrypted，也可以使用更简单的 clutch。这里用 dumpdecrypted 讲解。步骤如下。</p>
<h3 id="1-下载-dumpdecrypted"><a href="#1-下载-dumpdecrypted" class="headerlink" title="1.下载 dumpdecrypted"></a><a name="decrypt1"></a>1.下载 dumpdecrypted</h3><p>从<a href="https://github.com/AloneMonkey/dumpdecrypted" target="_blank" rel="external">https://github.com/AloneMonkey/dumpdecrypted</a>下载源码，编译出一个 dumpdecrypted.dylib 文件。这个版本的 dumpdecrypted 添加了对 framework 的 dump。</p>
<h3 id="2-安装-openSSH"><a href="#2-安装-openSSH" class="headerlink" title="2.安装 openSSH"></a><a name="decrypt2"></a>2.安装 openSSH</h3><p> iOS 9及以下系统，在 Cydia 里安装 openSSH 即可。</p>
<p> iOS 10越狱自带了 openSSH，但是默认是关闭的，需要做一点修改。</p>
<p>如果是用的 yalu 越狱：</p>
<ul>
<li>1.用苹果助手或者其他工具进入 iOS 的<code>/private/var/containers/Bundle/Application/yalu102/yalu102.app/</code>。</li>
<li>2.用文本编辑器打开 <code>dropbear.plist</code> 文件。</li>
<li>3.替换 127.0.0.1:22 为 22。</li>
<li>4.重启设备，重新使用越狱工具恢复越狱。</li>
</ul>
<p>参考：<a href="http://bbs.iosre.com/t/make-package-ssh-ios10-2/7564" target="_blank" rel="external">http://bbs.iosre.com/t/make-package-ssh-ios10-2/7564</a></p>
<p>或者直接去 Cydia 里安装 dropbear 插件。</p>
<h3 id="3-连接到-iOS-设备"><a href="#3-连接到-iOS-设备" class="headerlink" title="3.连接到 iOS 设备"></a><a name="decrypt3"></a>3.连接到 iOS 设备</h3><p>iOS 设备安装了 openSSH 后，在 Mac 端打开终端，确保 Mac 和 iOS 设备连接到同一网络，在终端里输入命令：ssh root@iOSIP。iOS 设备的 ip 地址：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-822e07f9921701cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS IP"></p>
<p>在终端中输入命令：<code>ssh root@10.5.53.182</code>，回车，接着输入 ssh 的默认密码<code>alpine</code>后即可连接到 iOS 设备。</p>
<h3 id="4-找到需要砸壳的-app"><a href="#4-找到需要砸壳的-app" class="headerlink" title="4.找到需要砸壳的 app"></a><a name="decrypt4"></a>4.找到需要砸壳的 app</h3><p>找到 app 所在目录，格式为<code>/var/mobile/Containers/Data/Application/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/</code>，可以使用同步助手、itools 等工具查找。</p>
<p>也可以在 Cydia 里安装 ps 命令行工具后，使用<code>ps –e</code>命令查找，方法是 ssh 成功后，关闭所有 app，打开需要砸壳的 app，输入<code>ps –e</code>命令，即可打印出所有进程，<code>/var/mobile</code>开头的那个目录就是 app 所在的目录。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-1aee28ef7177ccd0.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dump path"></p>
<h3 id="5-进行砸壳"><a href="#5-进行砸壳" class="headerlink" title="5.进行砸壳"></a><a name="decrypt5"></a>5.进行砸壳</h3><p>下面的砸壳是旧版 dumpdecrypted 的方法，比较繁琐。AloneMonkey 的 这个 <a href="https://github.com/AloneMonkey/dumpdecrypted" target="_blank" rel="external">https://github.com/AloneMonkey/dumpdecrypted</a> 更加简单。</p>
<ul>
<li>把<code>dumpdecrypted.dylib</code>拷贝到<code>/usr/lib</code>。 iOS 9之前是拷贝到 app 的 Document 目录的， iOS 9 之后出现了权限问题，所以拷贝到<code>/usr/lib</code></li>
<li>修改 user 为<code>mobile</code>：<code>su mobile</code></li>
<li>进入到某个具有写权限的目录，例如<code>cd /var/mobile/Documents</code></li>
<li>使用<code>DYLD_INSERT_LIBRARIES</code>加载动态库到 app 上，格式为<code>DYLD_INSERT_LIBRARIES=&#39;dumpdecrypted.dylib的目录&#39; &#39;需要砸壳的app执行文件的目录&#39;</code>，例如：<code>DYLD_INSERT_LIBRARIES=/usr/lib/dumpdecrypted.dylib /var/mobile/Applications/F7753B03-3F06-4524-A735-5BF5B398C730/WeChat.app/WeChat</code>。这是系统的 dyld 提供的加载动态库的功能，可以在 dyld 源代码中看到这部分逻辑。</li>
</ul>
<p>如果出现<code>dyld: could not load inserted library &#39;dumpdecrypted.dylib&#39; because no suitable image found.  Did find:
dumpdecrypted.dylib: required code signature missing for &#39;dumpdecrypted.dylib&#39;</code><br>，需要对 dumpdecrypted.dylib 进行签名。</p>
<p>在 Mac 上列出证书：<code>security find-identity -v -p codesigning</code>，用列出的证书签名：<br><code>codesign --force --verify --verbose --sign &quot;iPhone Developer: xxx xxxx (xxxxxxxxxx)&quot; dumpdecrypted.dylib</code>。把签名后的<code>dumpdecrypted.dylib</code>重新拷到 iOS 设备上，重新进行砸壳。</p>
<p>砸壳完毕后，在当前目录会生成一个<code>.decrypted</code>后缀的文件，这就是砸壳后的文件，将其拷贝到 Mac 上即可导入其头文件、用反编译工具打开分析。可以在 Mac 上使用 scp 命令拷贝越狱机上的文件：<code>scp -P 端口号（默认22） root@iOSIP:/var/mobile/Documents/xxx.decrypted ~/Documents/xxx.decrypted</code>。如果拷贝的是文件夹，加上<code>-r</code>参数。</p>
<p><code>dumpdecrypted</code>原理是 app 启动后会被系统解密，因此可以把解密后的内存 dump 出来。但是如果要对 app extension 进行砸壳，由于 extension 是依赖于主 app 的，不能独立启动，所以砸壳方法就失效了。可以参考这个改进版对 extension 砸壳的方法:<a href="https://github.com/CarinaTT/dumpdecrypted" target="_blank" rel="external">https://github.com/CarinaTT/dumpdecrypted</a></p>
<h2 id="使用-class-dump-导出-app-的头文件"><a href="#使用-class-dump-导出-app-的头文件" class="headerlink" title="使用 class-dump 导出 app 的头文件"></a><a name="class-dump"></a>使用 class-dump 导出 app 的头文件</h2><p>Class-dump 是一个可以导出 Objective-C 头文件的工具，官网：<a href="http://stevenygard.com" target="_blank" rel="external">http://stevenygard.com</a>。</p>
<p>通过分析头文件里的 API，可以简单地分析一个类的实现，或者查找一些私有 API。</p>
<p>class-dump 官网上的版本不能导出用 swift 编写的工程的头文件，当出现<code>Error: Cannot find offset for address 0x3a546a04 in dataOffsetForAddress:</code>这样的错误时，就说明这个 app 可能是用 swift 编写的。</p>
<p>建议去 github 上手动编译最新版的 class-dump，或者使用 class-dump-z 代替，下载地址：<a href="https://code.google.com/archive/p/networkpx/downloads" target="_blank" rel="external">https://code.google.com/archive/p/networkpx/downloads</a>。</p>
<p>把下载到的<code>class-dump-z</code>执行文件放到<code>/usr/local/bin/</code>，赋予执行权限<code>chmod +x /usr/local/bin/class-dump-z</code>。这样就可以在终端使用 class-dump 命令了：<code>class-dump-z –H &#39;需要导出头文件的app目录&#39; –o &#39;导出头文件的存放目录&#39;</code>。</p>
<p>例如要 dump 系统自带的计算器，导出它的头文件，命令如下：<br><code>class-dump-z -H /Applications/Calculator.app -o ~/Documents/headers</code>。</p>
<p>拿到砸壳后的 .decrypted 文件后，直接使用<code>class-dump-z</code>即可导出头文件。</p>
<p>此时，使用之前 reveal 定位到的类名，即可找到对应的文件，查看类里面的方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-81d1b9aa31908834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="class-dump"></p>
<p>可以看到，在扫一扫界面，微信使用了<code>- (void)captureOutput: didOutputSampleBuffer: fromConnection:</code>这个方法，说明它是截取了视频流的帧图像，再对图像进行二维码分析，而不是用<code>AVFoundiation</code>提供的二维码识别方法。</p>
<p>如果还想进一步查看方法的逻辑，可以使用<code>Hopper Disassembler</code>对 .decrypted 文件进行反编译。</p>
<h2 id="使用使用-Hopper-Disassembler-静态分析"><a href="#使用使用-Hopper-Disassembler-静态分析" class="headerlink" title="使用使用 Hopper Disassembler 静态分析"></a><a name="hopper"></a>使用使用 Hopper Disassembler 静态分析</h2><p>一个专门反编译 OC 程序的工具。官网：<a href="http://www.hopperapp.com" target="_blank" rel="external">http://www.hopperapp.com</a>。试用版有功能限制，30分钟退出一次，不能保存和导入反编译后的文件，不能动态调试等。</p>
<p>打开 Hopper Disassembler，直接将 .decrypted 文件拖入，选择对应的 CPU 架构类型即可，例如这个.decrypted 是从 iPad mini2 上生成的，那么就是 arm64。</p>
<p>打开后会自动进行分析，列出方法名、字符串等信息，但是大多数都是汇编语言。阅读汇编语言，还需要了解对应架构寄存器功能的知识。</p>
<p>在左侧可以搜索类名，方法名。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-3d25914f69e1555a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hopper1"></p>
<p>右侧的 is referenced by 和 have reference to 可以看到方法之间的的交叉引用关系：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-67510de930ee742d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hopper2"></p>
<p>按空格键可以弹出方法的逻辑跳转图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-11f39ea93115cf37.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hopper3"></p>
<p>Hopper Disassembler 可以将汇编语言转换为 OC 风格的伪代码，但是旧版的 hopper 不能对 arm64 文件使用这个功能。建议使用 armv7s 以下的 iOS 设备的原因就在这里。以下是使用 iPad2 越狱设备反编译后，生成的汇编代码和对应的伪代码，由于微信的代码比较复杂，这里选用的是另外一个更简单的二维码 app 的代码：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-2191087bf3343a25.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hopper4"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-c7889490ffd30d55.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hopper5"></p>
<p>可以看到<code>aptureOutput: didOutputSampleBuffer: fromConnection:</code>里，首先用取到的帧生成了一张图片，再用<code>createRotatedImage:degrees:</code>对图片做了一次处理，最后用<code>decodeImage:cgimg:</code>对图片进行二维码分析。要想查看这些方法，只需要再搜索对应的方法名就可以了。最新版 hopper 也可以双击直接跳转。</p>
<p>另外一个反编译工具 IDA 也可以反编译 armv7 的 app ，使用方法类似，可以和 Hopper Disassembler 对照着看。需要注意的是 IDA 的 Pro 版才支持 arm64 的 app，而 Pro 版不支持免费试用。</p>
<h2 id="静态分析经验总结"><a href="#静态分析经验总结" class="headerlink" title="静态分析经验总结"></a><a name="static-analysis"></a>静态分析经验总结</h2><h3 id="追踪调用流程"><a href="#追踪调用流程" class="headerlink" title="追踪调用流程"></a><a name="static-analysis1"></a>追踪调用流程</h3><ul>
<li>对于静态函数，直接用交叉引用功能<code>is referenced by</code>查看函数在哪里被引用。注意 hopper 面板里列出的引用不是完整的，可以用快捷键<code>x</code>列出完整的引用</li>
<li>对于 OC 方法，由于 runtime 在调用时不是直接引用方法，而是引用了 selector，所以需要搜索方法名字符串和 selector，然后再用<code>is referenced by</code>查找哪些地址引用了此字符串或者 selector，来查找方法调用</li>
<li>通过寄存器的赋值操作回溯参数的传递</li>
<li>通过查找某些关键字符串，回溯到关键函数</li>
</ul>
<p>注意，反汇编工具有时候会分析出错误的指令，所以有些函数体是丢失的，需要在反编译时手动 undefined。</p>
<h3 id="分析汇编代码"><a href="#分析汇编代码" class="headerlink" title="分析汇编代码"></a><a name="static-analysis2"></a>分析汇编代码</h3><ul>
<li>使用 hopper 的伪代码转换功能，可以将 OC 方法的汇编代码转换为 OC 风格的伪代码。此功能对 arm64 的支持不是很好，建议使用 armv7 或者 armv7s 的越狱机</li>
<li>在函数的开始，32 位 arm 上前四个参数存放在 r0-r3 中，其他参数存放在栈中，结束后，返回值放在 r0 中；在 arm64 上，前7个参数存放在 x0–x7 中，返回值存在 x0 中</li>
<li>有些代码是被开发者故意混效过的，例如打乱执行流程、加入冗余代码，可以借助一些 IDA 插件处理后再分析，例如 CrowdDetox、optimice python plugin，不过只是分析 iOS 的话，很少会遇到这种情况</li>
</ul>
<h3 id="基本的汇编知识"><a href="#基本的汇编知识" class="headerlink" title="基本的汇编知识"></a><a name="static-analysis3"></a>基本的汇编知识</h3><p>你并不需要花时间理解每一条汇编指令，只需要梳理出关键点就能理清代码的逻辑。</p>
<p>逆向中关键的指令：</p>
<ul>
<li><code>ldr</code>，<code>mov</code>，读取指令，从地址读取数据到寄存器。</li>
<li><code>str</code>，保存指令，保存数据到寄存器。</li>
<li><code>b</code>，跳转指令，跳转到某个地址。</li>
<li><code>cmp</code>，比较指令，说明这里有分支。</li>
</ul>
<p>32 位 arm 的调用约定：</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r0-r3</td>
<td>传递参数与返回值。如果断点在 OC 方法的第一行，那 r0 就是 self，r1 就是 cmd。如果超过四个参数，或者一些例如结构体的参数超过了32位 bit，那么参数将会通过栈来传递；返回值一般都在 r0 上</td>
</tr>
<tr>
<td>r4-r6, r8, r10-r11</td>
<td>没有特殊规定，通用寄存器</td>
</tr>
<tr>
<td>r7</td>
<td>栈帧指针寄存器(Frame Pointer)，指向前一个保存的栈帧(stack frame)和链接寄存器(link register， lr)在栈上的地址</td>
</tr>
<tr>
<td>r9</td>
<td>操作系统保留</td>
</tr>
<tr>
<td>r12</td>
<td>IP 寄存器(intra-procedure scratch)</td>
</tr>
<tr>
<td>r13</td>
<td>SP 寄存器(stack pointer)，是栈顶指针</td>
</tr>
<tr>
<td>r14</td>
<td>LR 寄存器(link register)，存放函数返回后需要继续执行的指令地址</td>
</tr>
<tr>
<td>r15</td>
<td>PC 寄存器(program counter)，指向当前指令地址</td>
</tr>
<tr>
<td>CPSR</td>
<td>当前程序状态寄存器(Current Program State Register)，在用户状态下存放像 condition 标志中断禁用等标志</td>
</tr>
</tbody>
</table>
<p>arm64 的调用约定：</p>
<p>arm64有 r0 - r30 是31个通用整形寄存器，PC 不能再作为寄存器直接访问。每个寄存器可以存取一个64位大小的数。 当使用 x0 - x30 访问时，它就是一个64位的数。当使用 w0 - w30 访问时，访问的是这些寄存器的低32位。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x0–x7</td>
<td>传递参数与返回值。如果参数个数超过了8个，多余的参数会存在栈上；返回值一般都在 x0 上</td>
</tr>
<tr>
<td>x29</td>
<td>栈帧指针寄存器(Frame Pointer)，指向前一个保存的栈帧(stack frame)和链接寄存器(link register， lr)在栈上的地址</td>
</tr>
<tr>
<td>x31</td>
<td>SP 寄存器(stack pointer)，是栈顶指针；根据不同指令，也有可能是 zero register</td>
</tr>
<tr>
<td>x30</td>
<td>LR 寄存器(link register)，存放函数的返回地址</td>
</tr>
<tr>
<td>CPSR</td>
<td>当前程序状态寄存器(Current Program State Register)，在用户状态下存放像 condition 标志中断禁用等标志</td>
</tr>
</tbody>
</table>
<p>x86-64 的调用约定：</p>
<p>x86-64 有16个64位寄存器，分别是：</p>
<p>rax，rbx，rcx，rdx，esi，edi，rbp，rsp，r8，r9，r10，r11，r12，r13，r14，r15</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rax</td>
<td>作为函数返回值使用</td>
</tr>
<tr>
<td>rsp</td>
<td>栈指针寄存器，指向栈顶</td>
</tr>
<tr>
<td>rdi，rsi，rdx，rcx，r8，r9</td>
<td>依次用作函数参数；如果断点在 OC 方法的第一行，那 rdi 就是 self，rsi 就是 cmd</td>
</tr>
<tr>
<td>rbx，rbp，r10，r11，r12，r13，r14，r15</td>
<td>通用寄存器</td>
</tr>
</tbody>
</table>
<p>栈帧相关的知识，可以参考：<a href="https://blog.cnbluebox.com/blog/2017/07/24/arm64-start/" target="_blank" rel="external">iOS开发同学的arm64汇编入门</a></p>
<h3 id="汇编指令速查插件"><a href="#汇编指令速查插件" class="headerlink" title="汇编指令速查插件"></a><a name="static-analysis4"></a>汇编指令速查插件</h3><p>有许多很有用的插件可以对静态分析提供帮助。</p>
<p>有时候看到不了解的汇编指令，每次都去 Google 查找，是一件很低效的事。可以安装插件，直接在 hopper 和 IDA 中显示指令的功能。</p>
<h4 id="Hopper-插件：hopperref"><a href="#Hopper-插件：hopperref" class="headerlink" title="Hopper 插件：hopperref"></a><a name="static-analysis4-1"></a>Hopper 插件：hopperref</h4><p>Hopper 可以使用 Python 编写的扩展插件。安装插件<a href="https://github.com/zbuc/hopperref" target="_blank" rel="external">hopperref</a>，把<code>Show Instruction Reference.py``arm.sql``x86-64.sql</code>拷贝到<code>~/Library/Application Support/Hopper/Scripts/</code>目录下即可。之后就能在 hopper 界面的菜单栏<code>Scripts</code>中找到<code>Show Instruction Reference</code>选项，点击即可输出选中指令的详细文档。</p>
<p><code>mov</code>指令的文档：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-baa81910713a18e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hopperref"></p>
<h4 id="IDA-插件：idaref"><a href="#IDA-插件：idaref" class="headerlink" title="IDA 插件：idaref"></a><a name="static-analysis4-2"></a>IDA 插件：idaref</h4><p>hopperref 插件是源自 一个 IDA 的插件 <a href="https://github.com/nologic/idaref" target="_blank" rel="external">idaref</a>。</p>
<p>把<code>idaref.py</code>拷贝到<code>your_ida_path/ida.app/Contents/MacOS/plugins/</code>下，把<code>archs</code>文件夹拷贝到<code>your_ida_path/ida.app/Contents/MacOS/plugins/archs</code>。<code>archs</code>文件夹里是汇编指令的文档<code>x86-64.sql``x86-64_old.sql``arm.sql``mips32.sql``xtensa.sql</code>。</p>
<p>之后打开 IDA，就可以在<code>Edit</code>菜单中多出了<code>idaref</code>选项，选择<code>Start Idaref</code>就开启了自动提示，</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-dd663a1ab9b1e795.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="idaref"></p>
<p>当选中汇编指令时，对应的文档就会显示在<code>Instruction Reference</code>窗口中。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-be8fb93e66acc3b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="idaref output"></p>
<h4 id="IDA-插件：FRIEND"><a href="#IDA-插件：FRIEND" class="headerlink" title="IDA 插件：FRIEND"></a><a name="static-analysis4-3"></a>IDA 插件：FRIEND</h4><p>除了 idaref，还有另一个插件 <a href="https://github.com/alexhude/FRIEND" target="_blank" rel="external">FRIEND</a> 也提供了汇编指令和寄存器的文档功能。只要把鼠标停在指令或者寄存器上就会显示文档悬浮窗。</p>
<p>需要注意的是，编译出来的 IDA dylib 插件是对应 IDA 版本的，如果要使用不同版本的 IDA，就需要重新编译。把对应版本的<code>FRIEND.dylib</code>和<code>FRIEND64.dylib</code>拷贝到<code>your_ida_path/ida.app/Contents/MacOS/plugins/</code>下，再打开 IDA 就会在<code>Edit-&gt;Plugins</code>中多出<code>FRIEND</code>选项。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-36d73eb7956d83bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ida FRIEND"></p>
<p>点击选项，打开 FRIEND 的设置。需要加载 FRIEND 提供的 XML 配置文件，对应二进制文件的 x86_64 或者 arm 平台。例如<code>x86_64.xml</code>配置中提供了<code>x86_64 instructions</code>项，选中后，勾上下面的四个功能选项，点击 OK 保存。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-f1269d0468e9cace.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ida FRIEND settings"></p>
<p>之后，当鼠标停在指令或者寄存器上就会显示文档悬浮窗。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-3ad2f930a3046e70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ida FRIEND instructions"></p>
<h3 id="识别库函数"><a href="#识别库函数" class="headerlink" title=" 识别库函数"></a><a name="static-analysis5"></a> 识别库函数</h3><p>很多时候，二进制文件中的函数都被去掉了符号，因此只能看到很多<code>sub_100017D90</code>这样的函数，难以直观分析。而程序会使用到很多第三方库，例如加密库、压缩库、网络库，这些第三方库一般都是开源的，可以得到函数符号，如果能恢复这部分函数的符号，就能避免浪费时间在分析这些开源代码上，也能通过分析开源库的交叉引用，追踪程序自身的逻辑。</p>
<p>这部分代码一般都是 C 和 C++ 函数，OC 方法的名字都保存在 Mach-O 文件的符号表中，不会被去除符号。如果你需要分析 C++ 程序，可以使用下面的工具进行辅助。</p>
<h4 id="FLIRT：库快速识别和鉴定技术"><a href="#FLIRT：库快速识别和鉴定技术" class="headerlink" title="FLIRT：库快速识别和鉴定技术"></a>FLIRT：库快速识别和鉴定技术</h4><p>IDA 提供了<code>FLIRT Signature</code>功能，FLIRT 全称是库快速识别和鉴定技术，可以为带有符号的库文件中的函数生成签名，再把签名文件导入到分析后的 app 中，就会识别出匹配到的函数，重命名为正确的符号。</p>
<p>但是生成正确的签名并不容易。用于生成签名的库文件，编译时的编译器版本、配置和 app 中用到的库的编译器版本、配置需要相同。这样才能生成相同的代码，从而生成相同的代码签名。</p>
<p>具体的使用方法，可以在书籍<code>IDA Pro 权威指南</code>中找到。</p>
<h4 id="识别加密函数"><a href="#识别加密函数" class="headerlink" title="识别加密函数"></a>识别加密函数</h4><p>类似的，有些 IDA 插件可以识别程序中用到的加密常数、加密方法和压缩方法。例如 Find Crypt 可以寻找常用加密算法中的常数，IDA signsrch 可以寻找二进制文件所使用的加密、压缩算法，IDA scope 可以自动识别 windows 函数和压缩、加密算法。</p>
<p>可以从这些关键函数入手，寻找程序中的关键逻辑。</p>
<h3 id="如何分析系统库"><a href="#如何分析系统库" class="headerlink" title="如何分析系统库"></a>如何分析系统库</h3><p>有时候在分析某个 crash 时，或者对某个系统功能感兴趣时，会需要分析特定版本的 iOS 系统库的实现，例如<code>UIKit.framework</code> <code>Foundiation.framework</code>。</p>
<p>绝大部分时候，只需要分析模拟器版本的系统库就可以了。因为模拟器的系统库保留了所有的符号，查找交叉引用更直接。</p>
<p>不过有些系统库只在真机上才有，或者你需要特定版本的库用于分析 crash 时，可以从这里下载对应的系统库。</p>
<p>真机的系统库和模拟器的有些差别。系统库在真机上经过了很多编译优化，去除了大部分私有的函数符号，交叉引用也不像模拟器版本的那样直接。真机上的所有系统 framework 都被整合成了一个大文件，名为<code>dyld_shared_cache_arm64</code>或者<code>dyld_shared_cache_armv7</code>。函数在寻址时，是基于整个<code>dyld_shared_cache_xxx</code>文件进行寻址的。</p>
<p>当你把真机连接到 Xcode，Xcode 会把真机上的系统库拷贝到<code>~/Library/Developer/Xcode/iOS DeviceSupport</code>，从<code>dyld_shared_cache_xxx</code>中切分出每个单独的 framework。但是当你反编译这些 framework 时，会发现代码里会使用很多无效地址的函数指针，难以分析。这是因为在<code>dyld_shared_cache_xxx</code>中，一个 framework 引用另一个 framework 中的函数时，是相当于在一个库中直接引用的，直接跳转到对应的地址，而不是再用函数符号经过 lazy binder 进行调用。当 framework 从<code>dyld_shared_cache_xxx</code>中切分出来后，这些函数调用的地址就会指向 framework 外，无法追踪。</p>
<p>所以在分析真机的系统库时，最好是配合模拟器版本的系统库辅助分析，可以看到私有的符号，也可以看到更明确的交叉引用。或者用 IDA 直接分析整个 <code>dyld_shared_cache_xxx</code>文件，不过这样做需要反汇编整个文件，耗时很大。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>静态分析的整个流程如上，剩下的就是积累经验了。通过静态分析查看一些简单函数的实现，在大部分情况下都足够了。不过静态分析的信息是有限的，有时候很难找到想要的函数，这时候就需要动态分析上场了。下一篇文章将讲解动态分析。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://bbs.iosre.com/t/make-package-ssh-ios10-2/7564" target="_blank" rel="external">http://bbs.iosre.com/t/make-package-ssh-ios10-2/7564</a></li>
<li><a href="https://blog.cnbluebox.com/blog/2017/07/24/arm64-start/" target="_blank" rel="external">iOS开发同学的arm64汇编入门</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态分析是指对二进制包进行反编译，分析静态的代码逻辑。&lt;/p&gt;
&lt;p&gt;本文内容包括：app 砸壳过程、工具和环境的坑、导出 OC 头文件、使用 hopper 和 IDA 反编译、arm 寄存器功能、静态分析经验、推荐的 IDA 插件、如何分析系统库。&lt;/p&gt;
&lt;h2 id=
    
    </summary>
    
      <category term="逆向工程" scheme="http://zuikyo.github.io/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 逆向指南：界面分析</title>
    <link href="http://zuikyo.github.io/2018/01/06/iOS_reverse_engineering_guide-view_analyzing/"/>
    <id>http://zuikyo.github.io/2018/01/06/iOS_reverse_engineering_guide-view_analyzing/</id>
    <published>2018-01-05T20:14:00.000Z</published>
    <updated>2018-11-01T20:14:08.230Z</updated>
    
    <content type="html"><![CDATA[<p>写几篇文章总结一下 iOS 逆向的整个流程，逆向初学者可以作为入门指南。内容包括逆向工具和环境配置、踩坑点、界面分析、砸壳、静态分析、动态分析、lldb 调试、推荐 hopper 和 IDA 插件、IDA 插件的编写、各种分析技巧。</p>
<h2 id="逆向的作用"><a href="#逆向的作用" class="headerlink" title="逆向的作用"></a>逆向的作用</h2><p>对于 iOS 开发工程师：</p>
<ul>
<li>通过查看界面、阅读汇编代码，研究参考其他 app 的实现方案</li>
<li>研究系统库的实现逻辑，用于修复 bug</li>
<li>查找使用私有 API，实现一些黑科技功能</li>
<li>接触底层原理，对 iOS 安全防护有更深入的掌握</li>
<li>获取其他 app 中的资源，例如游戏贴图</li>
<li>对第三方 app 进行一些自定义”改造”</li>
</ul>
<p>我个人觉得逆向对我最大的帮助就是能够查看各种闭源代码的实现，满足好奇心的同时也拓展了思路，能够学到很多。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>逆向中常用的工具有：</p>
<ul>
<li>越狱 iOS 设备一台（越狱后需要安装 openSSH 和一系列开发工具，建议使用 32 位的 armv7、armv7s 设备，因为旧版 Hopper Disassembler 不支持为 arm64 架构的汇编生成伪代码，最新版虽然支持，但是仍然不如 32 位的易读）</li>
<li>reveal：查看任意 app 界面</li>
<li>dumpdecrypted：对 app store 上下载的 app 进行砸壳解密的工具</li>
<li>clutch：和 dumpdecrypted 功能相同，也是 app 砸壳工具，用法更简单</li>
<li>class-dump, class-dump-z：分析 Mach-O 文件的类，导出 Objective-C 头文件</li>
<li>Hopper Disassembler：反编译 iOS app 工具</li>
<li>IDA：更强大的反编译工具， 缺点是价格贵</li>
</ul>
<p>通过这些工具的作用，也差不多能一窥 iOS 逆向的面貌。</p>
<h2 id="界面分析"><a href="#界面分析" class="headerlink" title="界面分析"></a>界面分析</h2><p>这篇文章首先讲讲对普通开发者最有用的界面分析：如何查看任意 app 的界面结构。</p>
<p>有时候我们对某个 app 的界面实现方式感兴趣，直接查看它的界面层级就能明白大致的思路。</p>
<h3 id="使用-reveal-查看-app-界面"><a href="#使用-reveal-查看-app-界面" class="headerlink" title="使用 reveal 查看 app 界面"></a>使用 reveal 查看 app 界面</h3><p>Reveal 是一个 Mac 端的商业软件，可以查看任意 app 的界面构成，以及所属的类名、约束等信息。找到对应的功能的类名后，就可以使用后面的工具找对应的头文件查看方法。Reveal 有试用版，试用期30天，官方和淘宝店铺有正版合作，有国区优惠。使用方法如下。</p>
<h4 id="1-客户端安装reveal插件"><a href="#1-客户端安装reveal插件" class="headerlink" title="1.客户端安装reveal插件"></a>1.客户端安装reveal插件</h4><p>Reveal 的环境配置有一些坑，并且在不同的系统版本上配置方式不一样。</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>iPhone 越狱后在 Cydia 里搜索<code>RevealLoader</code>安装插件。Reveal 有多个版本，reveal 1.6.3支持 iOS 7，reveal 2（版本号从2一直增加到了最近的13）最低支持 iOS 8。如果用的是 reveal 2，则在 iOS 9 及以下系统仍然使用<code>RevealLoader</code>，iOS 10 越狱机上则安装<code>Reveal2Loader</code>。安装后在设置里会出现 reveal 工具栏（可能需要重启设备），找到需要查看的 app，打开开关，然后重启 app。</p>
<p>如果使用 reveal 2，还需要手动添加一个动态库到设备上，原因是客户端的库需要和 Mac 端的库版本一致。在 Mac 端的 reveal 中打开 <code>Help -&gt; Show Reveal Library in Finder</code> (根据目标机器的类型选择 iOS Library 或者 TvOS Library)，将<code>RevealServer.framework</code>拷贝出来。</p>
<p>如果是 iOS 9，使用<code>RevealLoader</code>插件时，需要把<code>RevealServer.framework/RevealServer</code>二进制文件重命名为<code>libReveal.dylib</code>，拷贝到设备的<code>/Library/RHRevealLoader</code>文件夹下，没有文件夹则手动创建一个。</p>
<p>如果是 iOS 10，使用<code>Reveal2Loader</code>插件时，则将<code>RevealServer.framework</code>拷贝到目标设备上的<code>/Library/Frameworks/</code>目录下，如果已经存在同名文件，则替换。</p>
<p>最后，终端 SSH 到 iOS 设备，执行<code>killall SpringBoard</code>，重启 SpringBoard 即可。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-06dbc695d6722c02.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="reveal1.jpg"></p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>这个工具是把 reveal 的库添加到了<code>/Library/MobileSubstrate/DynamicLibraries</code>，并且提供了一个管理界面，并不是必须安装。当 app 启动时，MobileSubstrate 会自动把 reveal 的动态库注入到 app 中，然后和 Mac 端的软件进行通信。</p>
<p>如果选择不安装此工具，配置方法请参考<a href="https://zhuanlan.zhihu.com/p/19646016?columnSlug=iOSRe" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/19646016?columnSlug=iOSRe</a>。</p>
<h4 id="2-Mac-端打开-reveal-软件"><a href="#2-Mac-端打开-reveal-软件" class="headerlink" title="2.Mac 端打开 reveal 软件"></a>2.Mac 端打开 reveal 软件</h4><p>Mac 端安装 reveal 软件，把 iOS 设备和 Mac 连接到同一 wifi 下。<br>开启需要查看的 app，进入需要查看的界面，在 Mac 端 reveal 里选中，即可开启。</p>
<h4 id="3-查看页面信息"><a href="#3-查看页面信息" class="headerlink" title="3.查看页面信息"></a>3.查看页面信息</h4><p>你可以拖动界面，立体地查看界面结构。这个查看方式是 reveal 首先发布的，后来苹果官方把它集成到了 Xcode 中。</p>
<p>页面的右边，可以找到此页面对应的类名，以及尺寸、约束等信息。<br>下面是微信的扫一扫界面，可以看到界面的类名为 CameraScannerView 和 CameraScannerViewController。reveal2 开始，也可以查看 extension 的界面，比如通知中心插件。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1865432-771461969a9f80fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="reveal查看界面"></p>
<h3 id="其他界面查看方式"><a href="#其他界面查看方式" class="headerlink" title="其他界面查看方式"></a>其他界面查看方式</h3><p>不用 reveal 也可以查看 app 的界面。</p>
<h4 id="1-lldb-打印界面层级"><a href="#1-lldb-打印界面层级" class="headerlink" title="1. lldb 打印界面层级"></a>1. lldb 打印界面层级</h4><p>可以在动态分析 app 时，用 lldb 打印出 app 的界面层级。命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">po [[UIApp keyWindow] recursiveDescription]</div></pre></td></tr></table></figure>
<p>打印出来的结果类似于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;UIWindow: 0x7fbb91511d50; frame = (0 0; 375 667); gestureRecognizers = &lt;NSArray: 0x60400025bc90&gt;; layer = &lt;UIWindowLayer: 0x604000235820&gt;&gt;</div><div class="line">   | &lt;UILayoutContainerView: 0x7fbb91513e00; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x604000235fe0&gt;&gt;</div><div class="line">   |    | &lt;UIView: 0x7fbb9151a440; frame = (0 0; 375 0); layer = &lt;CALayer: 0x604000237420&gt;&gt;</div><div class="line">   |    | &lt;UILayoutContainerView: 0x7fbb91514420; frame = (0 0; 375 667); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x60400025d9d0&gt;; layer = &lt;CALayer: 0x604000235e60&gt;&gt;</div><div class="line">   |    |    | &lt;UINavigationTransitionView: 0x7fbb91516070; frame = (0 0; 375 667); clipsToBounds = YES; autoresize = W+H; layer = &lt;CALayer: 0x604000236920&gt;&gt;</div><div class="line">   |    |    |    | &lt;UIViewControllerWrapperView: 0x7fbb9151aa20; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x6040000379e0&gt;&gt;</div><div class="line">   |    |    |    |    | &lt;UIView: 0x7fbb9160d7b0; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x60400023e4c0&gt;&gt;</div><div class="line">   |    |    |    |    |    | &lt;UIButton: 0x7fbb917190d0; frame = (170 90; 34 30); opaque = NO; autoresize = RM+BM; layer = &lt;CALayer: 0x60000022bf20&gt;&gt;</div><div class="line">   |    |    |    |    |    |    | &lt;UIButtonLabel: 0x7fbb91611210; frame = (0 6; 34 18); text = &apos;push&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x604000292fc0&gt;&gt;</div><div class="line">   |    |    |    |    |    | &lt;UIButton: 0x7fbb91606c30; frame = (123 207; 128 30); opaque = NO; autoresize = RM+BM; layer = &lt;CALayer: 0x60400023a820&gt;&gt;</div><div class="line">   |    |    |    |    |    |    | &lt;UIButtonLabel: 0x7fbb91418310; frame = (0 6; 128 18); text = &apos;push and auto pop&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x600000299cd0&gt;&gt;</div><div class="line">   |    |    |    |    |    | &lt;_UILayoutGuide: 0x7fbb9160db40; frame = (0 0; 0 64); hidden = YES; layer = &lt;CALayer: 0x60400023e920&gt;&gt;</div><div class="line">   |    |    |    |    |    | &lt;_UILayoutGuide: 0x7fbb9160df50; frame = (0 667; 0 0); hidden = YES; layer = &lt;CALayer: 0x60400023e700&gt;&gt;</div><div class="line">   |    |    | &lt;UINavigationBar: 0x7fbb9150b170; frame = (0 20; 375 44); opaque = NO; autoresize = W; layer = &lt;CALayer: 0x604000039660&gt;&gt;</div><div class="line">   |    |    |    | &lt;_UIBarBackground: 0x7fbb9150e540; frame = (0 -20; 375 64); userInteractionEnabled = NO; layer = &lt;CALayer: 0x6040000395e0&gt;&gt;</div><div class="line">   |    |    |    |    | &lt;UIImageView: 0x7fbb9150e9d0; frame = (0 64; 375 0.5); userInteractionEnabled = NO; layer = &lt;CALayer: 0x604000039500&gt;&gt;</div><div class="line">   |    |    |    |    | &lt;UIVisualEffectView: 0x7fbb9150ec00; frame = (0 0; 375 64); layer = &lt;CALayer: 0x6040000394e0&gt;&gt;</div><div class="line">   |    |    |    |    |    | &lt;_UIVisualEffectBackdropView: 0x7fbb91710df0; frame = (0 0; 375 64); autoresize = W+H; userInteractionEnabled = NO; layer = &lt;UICABackdropLayer: 0x600000228da0&gt;&gt;</div><div class="line">   |    |    |    |    |    | &lt;_UIVisualEffectSubview: 0x7fbb917119a0; frame = (0 0; 375 64); autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CALayer: 0x600000228f40&gt;&gt;</div><div class="line">   |    |    |    | &lt;_UINavigationBarLargeTitleView: 0x7fbb91511290; frame = (0 0; 0 44); clipsToBounds = YES; alpha = 0; hidden = YES; layer = &lt;CALayer: 0x604000039720&gt;&gt;</div><div class="line">   |    |    |    |    | &lt;UILabel: 0x7fbb9171bae0; frame = (0 0; 0 0); userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x6000002972f0&gt;&gt;</div><div class="line">   |    |    |    | &lt;_UINavigationBarContentView: 0x7fbb9150f560; frame = (0 0; 375 44); clipsToBounds = YES; layer = &lt;CALayer: 0x604000039400&gt;&gt;</div><div class="line">   |    |    |    |    | &lt;_UIButtonBarButton: 0x7fbb9171c570; frame = (0 0; 80 44); layer = &lt;CALayer: 0x60400023d6c0&gt;&gt;</div><div class="line">   |    |    |    |    |    | &lt;_UIModernBarButton: 0x7fbb915178e0; frame = (8 11.5; 13 21); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x60400023f200&gt;&gt;</div><div class="line">   |    |    |    |    |    |    | &lt;UIImageView: 0x7fbb9141caf0; frame = (0 0; 13 21); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x600000230300&gt;&gt;</div><div class="line">   |    |    |    |    |    | &lt;_UIBackButtonContainerView: 0x7fbb91419ef0; frame = (0 0; 80 44); autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CALayer: 0x60000022ec20&gt;&gt;</div><div class="line">   |    |    |    |    |    |    | &lt;_UIModernBarButton: 0x7fbb9150c480; frame = (27 9; 53 23.5); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x60400023e900&gt;&gt;</div><div class="line">   |    |    |    |    |    |    |    | &lt;UIButtonLabel: 0x7fbb91511700; frame = (-1.5 3; 53 20.5); text = &apos;Master&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x604000291b70&gt;&gt;</div><div class="line">   |    |    |    |    | &lt;UILabel: 0x7fbb9171c290; frame = (148.5 12; 78.5 20.5); text = &apos;Test Push&apos;; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x600000297ca0&gt;&gt;</div><div class="line">   |    |    |    | &lt;_UINavigationBarModernPromptView: 0x7fbb9170cf10; frame = (0 0; 0 44); alpha = 0; hidden = YES; layer = &lt;CALayer: 0x6000002270c0&gt;&gt;</div><div class="line">   |    |    |    |    | &lt;UILabel: 0x7fbb9170d430; frame = (0 25.5; 0 0); text = &apos;&apos;; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x600000290400&gt;&gt;</div></pre></td></tr></table></figure>
<p><code>recursiveDescription</code>是<code>UIView</code>的私有API，注意不是所有的<code>UIView</code>都能使用，在有些视图上会crash。</p>
<p>可以再用<code>nextResponder</code>获取<code>UIView</code>对应的 view controller。</p>
<p>由于看得眼花，所以这个方式我很少用。</p>
<h4 id="2-直接使用-Xcode-的Debug-View-Hierarchy"><a href="#2-直接使用-Xcode-的Debug-View-Hierarchy" class="headerlink" title="2. 直接使用 Xcode 的Debug View Hierarchy"></a>2. 直接使用 Xcode 的<code>Debug View Hierarchy</code></h4><p>可以用 Xcode 直接调试重签名后的 app，然后就可以用<code>Debug View Hierarchy</code>查看界面层级了。</p>
<p>参考：<a href="https://zuikyo.github.io/2017/05/04/iOS逆向：用Xcode直接调试第三方app/">iOS逆向：用Xcode直接调试第三方app</a></p>
<h4 id="3-越狱插件：FLEX"><a href="#3-越狱插件：FLEX" class="headerlink" title="3. 越狱插件：FLEX"></a>3. 越狱插件：FLEX</h4><p>可以安装越狱插件，直接注入到 app 中，打印出界面信息。可以去 Cydia 中直接下载安装，也可以去这里编译源码使用：<a href="https://github.com/Flipboard/FLEX" target="_blank" rel="external">FLEX</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>界面分析对于猜想某个界面的实现方式有很大帮助。想要分析其它功能时，也可以通过界面分析先找到对应的类，再进一步进行静态分析和动态分析。下一篇文章将会讲解如何进行静态分析。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写几篇文章总结一下 iOS 逆向的整个流程，逆向初学者可以作为入门指南。内容包括逆向工具和环境配置、踩坑点、界面分析、砸壳、静态分析、动态分析、lldb 调试、推荐 hopper 和 IDA 插件、IDA 插件的编写、各种分析技巧。&lt;/p&gt;
&lt;h2 id=&quot;逆向的作用&quot;&gt;&lt;
    
    </summary>
    
      <category term="逆向工程" scheme="http://zuikyo.github.io/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS VIPER架构实践(三)：面向接口的路由设计</title>
    <link href="http://zuikyo.github.io/2017/09/27/iOS%20VIPER%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5(%E4%B8%89)%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%B7%AF%E7%94%B1%E8%AE%BE%E8%AE%A1/"/>
    <id>http://zuikyo.github.io/2017/09/27/iOS VIPER架构实践(三)：基于接口的路由设计/</id>
    <published>2017-09-27T15:36:00.000Z</published>
    <updated>2018-01-24T01:47:46.110Z</updated>
    
    <content type="html"><![CDATA[<p>路由是实现模块间解耦的一个有效工具。如果要进行组件化开发，路由是必不可少的一部分。目前iOS上绝大部分的路由工具都是基于URL匹配的，优缺点都很明显。这篇文章里将会给出一个更加原生和安全的设计，这个设计的特点是：</p>
<ul>
<li>路由时用protocol寻找模块</li>
<li><strong>可以对模块进行固定的依赖注入和运行时依赖注入</strong></li>
<li><strong>支持不同模块间进行接口适配和转发，因此无需和某个固定的protocol关联</strong></li>
<li><strong>充分解耦的同时，增加类型安全</strong></li>
<li>支持移除已执行的路由</li>
<li>封装UIKit界面跳转方法，可以一键跳转和移除</li>
<li>支持storyboard，支持其他任意模块</li>
<li>可以检测界面跳转时的大部分错误</li>
</ul>
<p>如果你想要一个能够充分解耦、类型安全、有依赖注入功能的路由器，那这个就是目前所能找到的最佳方案。</p>
<p>这个路由工具是为了实践VIPER模式而设计的，目的是为VIPER提供依赖注入功能，不过它也可以用于MVC、MVP、MVVM，没有任何限制。</p>
<p>工具和Demo地址：<a href="https://github.com/Zuikyo/ZIKRouter" target="_blank" rel="external">ZIKRouter</a>。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>Router的作用<ul>
<li>路由缺失时的情况</li>
<li>寻找模块</li>
<li>声明依赖和接口</li>
<li>Builder和依赖注入</li>
</ul>
</li>
<li>现有的Router<ul>
<li>URL Router<ul>
<li>优点<ul>
<li>极高的动态性</li>
<li>统一多端路由规则</li>
<li>适配URL scheme</li>
</ul>
</li>
<li>缺点<ul>
<li>不适合通用模块</li>
<li>安全性差</li>
<li>维护困难</li>
</ul>
</li>
</ul>
</li>
<li>Protocol Router<ul>
<li>优点 <ul>
<li>安全性好，维护简单  </li>
<li>适用于所有模块</li>
<li>优雅地声明依赖</li>
</ul>
</li>
<li>缺点<ul>
<li>动态性有限</li>
<li>需要额外适配URL Scheme</li>
</ul>
</li>
<li>Protocol是否会导致耦合？<ul>
<li>业务设计的互相关联</li>
<li><code>Required Interface</code> 和 <code>Provided Interface</code></li>
</ul>
</li>
</ul>
</li>
<li>Target-Action<ul>
<li>优点</li>
<li>缺点</li>
</ul>
</li>
<li>UIStoryboardSegue</li>
<li>总结</li>
</ul>
</li>
<li>ZIKRouter的特性<ul>
<li>离散式管理</li>
<li>自由定义路由参数</li>
<li>移除已执行的路由</li>
<li>通过protocol获取对应模块<ul>
<li>Protocol作为匹配标识</li>
<li>多对一匹配</li>
</ul>
</li>
<li>依赖注入和依赖声明<ul>
<li>固定依赖和运行时依赖</li>
<li>直接在头文件中声明</li>
</ul>
</li>
<li>使用泛型指明特定router</li>
<li>类型安全<ul>
<li>传入正确的protocol</li>
<li>泛型的协变和逆变</li>
</ul>
</li>
<li>用Adapter兼容接口<ul>
<li>为<code>Provided</code>模块添加<code>Required Interface</code></li>
<li>用中介者转发接口</li>
</ul>
</li>
<li>封装UIKit跳转和移除方法<ul>
<li>封装iOS的路由方法</li>
<li>识别<code>adaptative</code>类型的路由</li>
<li>支持自定义路由</li>
<li>关于extension里的跳转方法</li>
</ul>
</li>
<li>支持storyboard</li>
<li>AOP</li>
<li>路由错误检查</li>
<li>支持任意模块</li>
<li>性能</li>
</ul>
</li>
<li>项目地址和Demo</li>
</ul>
<h2 id="Router的作用"><a href="#Router的作用" class="headerlink" title="Router的作用"></a>Router的作用</h2><p>首先，我们需要梳理清楚，为什么我们需要Router，Router能带来什么好处，解决什么问题？我们需要一个什么样的Router？</p>
<h3 id="路由缺失时的情况"><a href="#路由缺失时的情况" class="headerlink" title="路由缺失时的情况"></a>路由缺失时的情况</h3><p>没有路由时，界面跳转的代码就很容易产生模块间耦合。</p>
<p>iOS中执行界面跳转时，用的是UIViewController上提供的跳转方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[sourceViewController.navigationController pushViewController:destinationViewController animated:YES];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[sourceViewController presentViewController:destinationViewController animated:YES completion:nil];</div></pre></td></tr></table></figure>
<p>如果是直接导入destinationViewController的头文件进行引用，就会导致和destinationViewController模块产生耦合。类似的，一个模块引用另一个模块时也会产生这样的耦合。因此我们需要一个方式来获取destinationViewController，但又不能对其产生直接引用。</p>
<p>这时候就需要路由提供的”寻找模块”的功能。以某种动态的方式获取目的模块。</p>
<p>那么路由是怎么解决模块耦合的呢？在上一篇VIPER讲解里，路由有这几个主要职责：</p>
<ul>
<li>寻找指定模块，执行具体的路由操作</li>
<li>声明模块的依赖</li>
<li>声明模块的对外接口</li>
<li>对模块内各部分进行依赖注入</li>
</ul>
<p>通过这几个功能，就能实现模块间的完全解耦。</p>
<h3 id="寻找模块"><a href="#寻找模块" class="headerlink" title="寻找模块"></a>寻找模块</h3><p>路由最重要的功能就是给出一种寻找某个指定模块的方案。这个方案是松耦合的，获取到的模块在另一端可以随时被另一个相同功能的模块替换，从而实现两个模块之间的解耦。</p>
<p>寻找模块的实现方式其实只有有限的几种：</p>
<ul>
<li>用一个字符串identifier来标识某个对应的界面（URL Router、UIStoryboardSegue）</li>
<li>利用Objective-C的runtime特性，直接调用目的模块的方法（CTMediator）</li>
<li>用一个protocol来和某个界面进行匹配（蘑菇街的第二种路由和阿里的BeeHive），这样就可以更安全的对目的模块进行传参</li>
</ul>
<p>这几种方案的优劣将在之后逐一细说。</p>
<h3 id="声明依赖和接口"><a href="#声明依赖和接口" class="headerlink" title="声明依赖和接口"></a>声明依赖和接口</h3><p>一个模块A有时候需要使用其他模块的功能，例如最通用的log功能，不同的app有不同的log模块，如果模块A对通用性要求很高，log方法就不能在模块A里写死，而是应该通过外部调用。这时这个模块A就依赖于一个log模块了。App在使用模块A的时候，需要知道它的依赖，从而在使用模块A之前，对其注入依赖。</p>
<p>当通过cocoapods这样的包管理工具来配置不同模块间的依赖时，一般模块之间是强耦合的，模块是一一对应的，当需要替换一个模块时会很麻烦，容易牵一发而动全身。如果是一个单一功能模块，的确需要依赖其他特定的各种库时，那这样做没有问题。但是如果是一个业务模块中引用了另一个业务模块，就应该尽量避免互相耦合。因为不同的业务模块一般是由不同的人负责，应该避免出现一个业务模块的简单修改（例如调整了方法或者属性的名字）导致引用了它的业务模块也必须修改的情况。</p>
<p>这时候，业务模块就需要在代码里声明自己需要依赖的模块，让app在使用时提供这些模块，从而充分解耦。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@protocol ZIKLoginServiceInput &lt;NSObject&gt;</div><div class="line">- (void)loginWithAccount:(NSString *)account</div><div class="line">                password:(NSString *)password</div><div class="line">                 success:(void(^_Nullable)(void))successHandler</div><div class="line">                   error:(void(^_Nullable)(void))errorHandler;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface ZIKNoteListViewController ()</div><div class="line">//笔记界面需要登录后才能查看，因此在头文件中声明，让外部在使用的时候设置此属性</div><div class="line">@property (nonatomic, strong) id&lt;ZIKLoginServiceInput&gt; loginService;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个声明依赖的工作其实是模块的Builder的职责。一个界面模块大部分情况下都不止有一个UIViewController，也有其他一些Manager或者Service，而这些角色都是有各自的依赖的，都统一由模块的Builder声明，再在Builder内部设置依赖。不过在上一篇文章的VIPER讲解里，我们把Builder的职责也放到了Router里，让每个模块单独提供一个自己的Router。因此在这里，Router是一个离散的设计，而不是一个单例Router掌管所有的路由。这样的好处就是每个模块可以充分定制和控制自己的路由过程。</p>
<p>可以声明依赖，也就可以同时声明模块的对外接口。这两者很相似，所以不再重复说明。</p>
<h3 id="Builder和依赖注入"><a href="#Builder和依赖注入" class="headerlink" title="Builder和依赖注入"></a>Builder和依赖注入</h3><p>执行路由的同时用Builder进行模块构建，构建的时候就对模块内各个角色进行依赖注入。当你调用某个模块的时候，需要的不是某个简单的具体类，而是一个构建完毕的模块中的某个具体类。在使用这个模块前，模块需要做一些初始化的操作，比如VIPER里设置各个角色之间的依赖关系，就是一个初始化操作。因此使用路由去获取某个模块中的类，必定需要通过模块的Builder进行。很多路由工具都缺失了这部分功能。</p>
<p>你可以把依赖注入简单地看成对目的模块传参。在进行界面跳转和使用某个模块时，经常需要设置目的模块的一些参数，例如设置delegate回调。这时候就必须调用一些目的模块的方法，或者传递一些对象。由于每个模块需要的参数都不一样，目前大部分Router都是使用字典包裹参数进行传递。但其实还有更好、更安全的方案，下面将会进行详解。</p>
<p>你也可以把Router、Builder和Dependency Injector分开，不过如果Router是一个离散型的设计，那么都交给各自的Router去做也很合理，同时能够减少代码量，也能够提供细粒度的AOP。</p>
<h2 id="现有的Router"><a href="#现有的Router" class="headerlink" title="现有的Router"></a>现有的Router</h2><p>梳理完了路由的职责，现在来比较一下现有的各种Router方案。关于各个方案的具体实现细节我就不再展开看，可以参考这篇详解的文章：<a href="http://www.jianshu.com/p/76da56b3bd55" target="_blank" rel="external">iOS 组件化 —— 路由设计思路分析</a>。</p>
<h3 id="URL-Router"><a href="#URL-Router" class="headerlink" title="URL Router"></a>URL Router</h3><p>目前绝大多数的Router都是用一串URL来表示需要打开的某个界面，代码上看来大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//注册某个URL，和路由处理进行匹配保存</div><div class="line">[URLRouter registerURL:@&quot;settings&quot; handler:^(NSDictionary *userInfo) &#123;</div><div class="line">trueUIViewController *sourceViewController = userInfo[@&quot;sourceViewController&quot;];</div><div class="line">true//获取其他参数</div><div class="line">trueid param = userInfo[@&quot;param&quot;];</div><div class="line">true//获取需要的界面</div><div class="line">trueUIViewController *settingViewController = [[SettingViewController alloc] init];</div><div class="line">true[sourceViewController.navigationController pushViewController: settingViewController animated:YES];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//调用路由</div><div class="line">[URLRouter openURL:@&quot;myapp://noteList/settings?debug=true&quot; userInfo:params completion:^(NSDictionary *info) &#123;</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>传递一串URL就能打开noteList界面的settings界面，用字典包裹需要传递的参数，有时候还会把UIKit的push、present等方法进行简单封装，提供给调用者。</p>
<p>这种方式的优点和缺点都很突出。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><h5 id="极高的动态性"><a href="#极高的动态性" class="headerlink" title="极高的动态性"></a>极高的动态性</h5><p>这是动态性最高的方案，甚至可以在运行时随时修改路由规则，指向不同的界面。也可以很轻松地支持多级页面的跳转。</p>
<p>如果你的app是电商类app，需要经常做活动，app内的跳转规则经常变动，那么就很适合使用URL的方案。</p>
<h5 id="统一多端路由规则"><a href="#统一多端路由规则" class="headerlink" title="统一多端路由规则"></a>统一多端路由规则</h5><p>URL的方案是最容易跨平台实现的，iOS、Andorid、web、PC都按照URL来进行路由时，也就可以统一管理多端的路由规则，降低多端各自维护和修改的成本，让不懂技术的运营人员也可以简单快速地修改路由。</p>
<p>和上一条一样，这也是一个和业务强相关的优点。如果你有统一多端的业务需求，使用URL也很合适。</p>
<h5 id="适配URL-scheme"><a href="#适配URL-scheme" class="headerlink" title="适配URL scheme"></a>适配URL scheme</h5><p>iOS中的URL scheme可以跨进程通信，从app外打开app内的某个指定页面。当app内的页面都能使用URL打开时，也就直接兼容了URL scheme，无需再做额外的工作。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="不适合通用模块"><a href="#不适合通用模块" class="headerlink" title="不适合通用模块"></a>不适合通用模块</h5><p>URL Router的设计只适合UI模块，不适合其他功能性模块的组件。功能性模块的调用并不需要如此强的动态特性，除非是有模块热更新的需求，否则一个模块的调用在一个版本里应该总是稳定不变的，即便要进行模块间解耦，也不应该用这种方式。</p>
<h5 id="安全性差"><a href="#安全性差" class="headerlink" title="安全性差"></a>安全性差</h5><p>字符串匹配的方式无法进行编译时检查，当页面配置出错时，只能在运行时才能发现。如果某个开发人员不小心在字符串里加了一个空格，编译时也无法发现。你可以用宏定义来减少这种出错的几率。</p>
<h5 id="维护困难"><a href="#维护困难" class="headerlink" title="维护困难"></a>维护困难</h5><p>没有高效地声明接口的方式，只能从文档里查找，编写时必须仔细对照字符串及其参数类型。</p>
<p>传参通过字典来进行，参数类型无法保证，而且也无法准确地知道所调用的接口需要哪些参数。当目的模块进行了接口升级，修改了参数类型和数量，那所有用到的地方都要一一修改，并且没有编译器的帮助，你无法知道是否遗漏了某些地方。这将会给维护和重构带来极大的成本。</p>
<p>针对这个问题，蘑菇街的选择是用另一个Router，用protocol来获取目的模块，再进行调用，增加安全性。</p>
<h3 id="Protocol-Router"><a href="#Protocol-Router" class="headerlink" title="Protocol Router"></a>Protocol Router</h3><p>这个方案也很容易理解。把之前的字符串匹配改成了protocol匹配，就能获取到一个实现了某个protocol的对象。</p>
<p>开源方案里只看到了<a href="https://github.com/alibaba/BeeHive" target="_blank" rel="external">BeeHive</a>实现了这样的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id&lt;ZIKLoginServiceInput&gt; loginService = [[BeeHive shareInstance] createService:@protocol(ZIKLoginServiceInput)];</div></pre></td></tr></table></figure>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><h5 id="安全性好，维护简单"><a href="#安全性好，维护简单" class="headerlink" title="安全性好，维护简单"></a>安全性好，维护简单</h5><p>再对这个对象调用protocol中的方法，就十分安全了。在重构和修改时，有了编译器的类型检查，效率更高。</p>
<h5 id="适用于所有模块"><a href="#适用于所有模块" class="headerlink" title="适用于所有模块"></a>适用于所有模块</h5><p>Protocol更加符合OC和Swift原生的设计思想，任何模块都可以使用，而不局限于UI模块。</p>
<h5 id="优雅地声明依赖"><a href="#优雅地声明依赖" class="headerlink" title="优雅地声明依赖"></a>优雅地声明依赖</h5><p>模块A需要用到登录模块，但是它要怎么才能声明这种依赖关系呢？如果使用Protocol Router，那就只需要在头文件里定义一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, string) id&lt;ZIKLoginServiceInput&gt; *loginService;</div></pre></td></tr></table></figure>
<p>如果这个依赖是必需依赖，而不是一个可选依赖，那就添加到初始化参数里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface ModuleA ()</div><div class="line">- (instancetype)initWithLoginService:(id&lt;ZIKLoginServiceInput&gt;)loginService;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>问题是，如果这样的依赖很多，那么初始化方法就会变得很长。因此更好的做法是由Builder进行固定的依赖注入，再提供给外部。目前BeeHive并没有提供依赖注入的功能。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><h5 id="动态性有限"><a href="#动态性有限" class="headerlink" title="动态性有限"></a>动态性有限</h5><p>你可以维护一份protocol和模块的对照表，使用动态的protocol来尝试动态地更改路由规则，也可以在Protocol Router之上封装一层URL Router专门用于动态性的需求。</p>
<h5 id="需要额外适配URL-Scheme"><a href="#需要额外适配URL-Scheme" class="headerlink" title="需要额外适配URL Scheme"></a>需要额外适配URL Scheme</h5><p>使用了Protocol Router就需要再额外处理URL Scheme了。不过这样也是正常的，解析URL Scheme本来就应该放到另一个单独的模块里。</p>
<h4 id="Protocol是否会导致耦合？"><a href="#Protocol是否会导致耦合？" class="headerlink" title="Protocol是否会导致耦合？"></a>Protocol是否会导致耦合？</h4><p>很多谈到这种方案的文章都会指出，和URL Router相比，Protocol Router会导致调用者引用目的模块的protocol，因此会产生”耦合”。我认为这是对”解耦”的错误理解。</p>
<p>要想避免耦合，首先要弄清楚，我们需要什么程度的解耦。我的定义是：模块A调用了模块B，模块B的接口或者实现在做出简单的修改时，或者模块B被替换为相同功能的模块C时，模块A不需要进行任何修改。这时候就可以认为模块A和模块B是解耦的。</p>
<h5 id="业务设计的互相关联"><a href="#业务设计的互相关联" class="headerlink" title="业务设计的互相关联"></a>业务设计的互相关联</h5><p>有些时候，表达出两个模块之间的关联是有意义的。</p>
<p>当一个界面A需要展示一个登录界面时，它可能需要向登录界面传递一个”提示语”参数，用于在登录界面显示一串提示。这时候，界面A在调用登录界面时，是要求登录界面能够显示这个自定义提示语的，在业务设计中就存在两个模块间的强关联性。这时候，URL Router和Protocol Router没有任何区别，包括下面将要提到的<code>Target-Action</code>路由方式，都存在耦合，但是Protocol Router通过简单地改善，是可以把这部分耦合去除的。</p>
<p>URL Router：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[URLRouter openURL:@&quot;login&quot; userInfo:@&#123;@&quot;message&quot;:@&quot;请登录查看笔记详情&quot;&#125;];</div></pre></td></tr></table></figure>
<p>Protocol Router:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@protocol LoginViewInput &lt;NSObject&gt;</div><div class="line">@property (nonatomic, copy) NSString *message;</div><div class="line">@end</div><div class="line"></div><div class="line">//获取登录界面进行设置</div><div class="line">UIViewController&lt;LoginViewInput&gt; *loginViewController = [ProtocolRouter destinationForProtocol:@protocol(LoginViewInput)];</div><div class="line">loginViewController.message = @&quot;请登录查看笔记详情&quot;;</div></pre></td></tr></table></figure>
<p>由于字典传参的原因，URL Router只不过是把这种接口上的关联隐藏到了字典key里，它在参数字典里使用<code>@&quot;message&quot;</code>时，就是在隐式地使用<code>LoginViewInput</code>的接口。</p>
<p>这种业务设计上导致的模块之间互相关联是不可避免的，也是不需要去隐藏的。隐藏了反而会引来麻烦。如果登录界面的属性名字变了，从<code>NSString *message</code>改成了<code>NSString *notifyString</code>，那么URL Router在register的时候也必须修改传参时的代码。如果register是由登录界面自己执行和处理的，而不是由App Context来处理的，那么此时参数key是固定为<code>@&quot;notifyString&quot;</code>的，那就会要求所有调用者的传参key也修改为<code>notifyString</code>，这种修改如果缺少编译器的帮助会很危险，目前是用宏来减少这种修改导致的工作量。而Protocol Router在修改时就能充分利用编译器进行检查，能够保证100%安全。</p>
<p>因此，URL Router并不能做到解耦，只是隐藏了接口关联而已。一旦遇到了需要修改或者重构的情况，麻烦就出现了，在替换宏的时候，你还必须仔细检查有没有哪里有直接使用字符串的key。只是简单地修改名字还是可控的，如果是需要增加参数呢？这时候就根本无法检查哪里遗漏了参数传递了。这就是字典传参的坏处。</p>
<p>关于这部分的讨论，也可以参考Peak大佬的文章：<a href="http://mrpeak.cn/blog/module/" target="_blank" rel="external">iOS组件化方案</a>。</p>
<p>Protocol Router在这种情况下也需要作出修改，但是它能帮助你安全高效地进行重构。而且只要稍加改进，也可以完全无需修改。解决方法就是把Protocol分离为<code>Required Interface</code>和<code>Provided Interface</code>。</p>
<h5 id="Required-Interface-和-Provided-Interface"><a href="#Required-Interface-和-Provided-Interface" class="headerlink" title="Required Interface 和 Provided Interface"></a><code>Required Interface</code> 和 <code>Provided Interface</code></h5><p>模块的接口其实是有<code>Required Interface</code>和<code>Provided Interface</code>的区别的。<code>Required Interface</code>就是调用者需要用到的接口，<code>Provided Interface</code>就是实际的被调用者提供的接口。</p>
<p>在UML的<a href="http://www.uml-diagrams.org/component-diagrams.html" target="_blank" rel="external">组件图</a>中，就很明确地表现出了这两者的概念。下图中的半圆就是<code>Required Interface</code>，框外的圆圈就是<code>Provided Interface</code>：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5879294-6309bffe07ebf178.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="组件图"></p>
<p>那么如何实施<code>Required Interface</code>和<code>Provided Interface</code>？上一篇文章里已经讨论过，应该由App Context在一个adapter里进行接口适配，从而使得调用者可以继续在内部使用<code>Required Interface</code>，adapter负责把<code>Required Interface</code>和修改后的<code>Provided Interface</code>进行适配。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@protocol ModuleARequiredLoginViewInput &lt;NSObject&gt;</div><div class="line">@property (nonatomic, copy) NSString *message;</div><div class="line">@end</div><div class="line"></div><div class="line">//Module A中的调用代码</div><div class="line">UIViewController&lt;ModuleARequiredLoginViewInput&gt; *loginViewController = [ProtocolRouter destinationForProtocol:@protocol(LoginViewInput)];</div><div class="line">loginViewController.message = @&quot;请登录查看笔记详情&quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//Login Module Provided Interface</div><div class="line">@protocol ProvidedLoginViewInput &lt;NSObject&gt;</div><div class="line">@property (nonatomic, copy) NSString *notifyString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//App Context 中的 Adapter，用Objective-C的category或者Swift的extension进行接口适配</div><div class="line">@interface LoginViewController (ModuleAAdapte) &lt;ModuleARequiredLoginViewInput&gt;</div><div class="line">@property (nonatomic, copy) NSString *message;</div><div class="line">@end</div><div class="line">@implementation LoginViewController (ModuleAAdapte)</div><div class="line">- (void)setMessage:(NSString *)message &#123;</div><div class="line">trueself.notifyString = message;</div><div class="line">&#125;</div><div class="line">- (NSString *)message &#123;</div><div class="line">truereturn self.notifyString;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>用category、extension、NSProxy等技术兼容新旧接口，工作全部由模块的使用和装配者<code>App Context</code>完成。如果<code>LoginViewController</code>已经有了自己的<code>message</code>属性，这时候就说明新的登录模块是不可兼容的，必须有某一方做出修改。当然，接口适配能做的事情是有限的，例如一个接口从同步变成了异步，那么这时候两个模块也是不能兼容的。</p>
<p>因此，如果模块需要进行解耦，那么它的接口在设计的时候就应该十分仔细，尽量不要在参数中引入太多其他的模块依赖。</p>
<p>只有存在<code>Required Interface</code>和<code>Provided Interface</code>概念的设计，才能做到彻底的解耦。目前的路由方案都缺失了这一部分。</p>
<h3 id="Target-Action"><a href="#Target-Action" class="headerlink" title="Target-Action"></a>Target-Action</h3><p><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="external">CTMediator</a>的方案，把对模块的调用封装到Target-Action中，利用了Objective-C的runtime特性，省略了Target-Action的注册和绑定工作，直接通过CTMediator中介者调用目的模块的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@implementation CTMediator (CTMediatorModuleAActions)</div><div class="line">- (UIViewController *)CTMediator_viewControllerForDetail</div><div class="line">&#123;</div><div class="line">    UIViewController *viewController = [self performTarget:kCTMediatorTargetA</div><div class="line">                                                    action:kCTMediatorActionNativFetchDetailViewController</div><div class="line">                                                    params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;</div><div class="line">                                         shouldCacheTarget:NO</div><div class="line">                                        ];</div><div class="line">    if ([viewController isKindOfClass:[UIViewController class]]) &#123;</div><div class="line">        // view controller 交付出去之后，可以由外界选择是push还是present</div><div class="line">        return viewController;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 这里处理异常场景，具体如何处理取决于产品</div><div class="line">        return [[UIViewController alloc] init];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>-performTarget:action:params:shouldCacheTarget:</code>方法通过<code>NSClassFromString</code>，获取目的模块提供的Target类，再调用Target提供的Action，实现了方法调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@implementation CTMediator</div><div class="line">- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    NSString *targetClassString = [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];</div><div class="line">    NSString *actionString = [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName];</div><div class="line">    Class targetClass;</div><div class="line">    </div><div class="line">    NSObject *target = self.cachedTarget[targetClassString];</div><div class="line">    if (target == nil) &#123;</div><div class="line">        targetClass = NSClassFromString(targetClassString);</div><div class="line">        target = [[targetClass alloc] init];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    SEL action = NSSelectorFromString(actionString);</div><div class="line">    </div><div class="line">    if (target == nil) &#123;</div><div class="line">        // 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (shouldCacheTarget) &#123;</div><div class="line">        self.cachedTarget[targetClassString] = target;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ([target respondsToSelector:action]) &#123;</div><div class="line">        return [self safePerformAction:action target:target params:params];</div><div class="line">    &#125; else &#123;</div><div class="line">        // 有可能target是Swift对象</div><div class="line">        actionString = [NSString stringWithFormat:@&quot;Action_%@WithParams:&quot;, actionName];</div><div class="line">        action = NSSelectorFromString(actionString);</div><div class="line">        if ([target respondsToSelector:action]) &#123;</div><div class="line">            return [self safePerformAction:action target:target params:params];</div><div class="line">        &#125; else &#123;</div><div class="line">            // 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理</div><div class="line">            SEL action = NSSelectorFromString(@&quot;notFound:&quot;);</div><div class="line">            if ([target respondsToSelector:action]) &#123;</div><div class="line">                return [self safePerformAction:action target:target params:params];</div><div class="line">            &#125; else &#123;</div><div class="line">                // 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。</div><div class="line">                [self.cachedTarget removeObjectForKey:targetClassString];</div><div class="line">                return nil;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>实现简洁，整个实现的代码量很少</li>
<li>省略了路由注册的步骤，可以减少一部分内存消耗和时间消耗，但是也略微降低了调用时的性能</li>
<li>使用场景不局限于界面模块，所有模块都可以通过中介者调用</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>在调用action时使用字典传参，无法保证类型安全，维护困难</li>
<li>直接使用runtime互相调用，难以明确地区分<code>Required Interface</code>和<code>Provided Interface</code>，因此其实无法实现完全解耦。和URL Router一样，在目的模块变化时，调用模块也必须做出修改</li>
<li>过于依赖runtime特性，和Swift的类型安全设计是不兼容的，也无法跨平台多端实现</li>
</ul>
<h3 id="UIStoryboardSegue"><a href="#UIStoryboardSegue" class="headerlink" title="UIStoryboardSegue"></a>UIStoryboardSegue</h3><p>苹果的storyboard其实也有一套路由API，只不过它的局限性很大。在这里简单介绍一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@implementation SourceViewController</div><div class="line"></div><div class="line">- (void)showLoginViewController &#123;</div><div class="line">true//调用在storyboard中定义好的segue identifier</div><div class="line">true[self performSegueWithIdentifier:@&quot;presentLoginViewController&quot; sender:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//perform segue时的回调</div><div class="line">- (BOOL)shouldPerformSegueWithIdentifier:(NSString *)identifier sender:(nullable id)sender &#123;</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//配置目的界面</div><div class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;</div><div class="line">    //用[segue destinationViewController]获取目的界面，再对目的界面进行传参</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>UIStoryboardSegue是和storyboard一起使用的，storyboard中定义好了一些界面跳转的参数，比如转场方式（push、present等），在执行路由前，执行路由的UIViewController会收到回调，让调用者配置目的界面的参数。</p>
<p>在storyboard中连接segue，其实是跳转到一个已经配置好界面的view controller，也就是和View相关的参数，都已经做好了依赖注入。但是自定义的依赖，却还是需要在代码中注入，所以又给了我们一个<code>-prepareForSegue:sender:</code>回调。</p>
<p>我不建议使用segue，因为它会导致强耦合。但是我们可以借鉴UIStoryboardSegue的sourceViewController、destinationViewController、封装跳转逻辑到segue子类、对页面执行依赖注入等设计。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结了几个路由工具之后，我的结论是：路由的选择还是以业务需求为先。当对动态性要求极高、或者需要多平台统一路由，则选择URL Router，其他情况下，我更倾向于使用Protocol Router。和Peak大大的结论一致。</p>
<p>Protocol Router目前并没有一个成熟的开源方案。因此我造了个轮子，增加了上面提到的一些需求。</p>
<h2 id="ZIKRouter的特性"><a href="#ZIKRouter的特性" class="headerlink" title="ZIKRouter的特性"></a>ZIKRouter的特性</h2><h3 id="离散式管理"><a href="#离散式管理" class="headerlink" title="离散式管理"></a>离散式管理</h3><p>每个模块都对应一个或者多个router子类，在子类中管理各自的路由过程，包括对象的生成、模块的初始化、路由状态管理、AOP等。路由时，需要使用对应的router子类，而不是一个单例router掌管所有的路由。如果想要避免引用子类带来的耦合，可以用protocol动态获取router子类，或者用父类+泛型在调用者中代替子类。</p>
<p>采用离散式的设计的原因是想让各个模块对路由拥有充分的控制权。</p>
<p>一个router子类的简单实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@interface ZIKLoginViewRouter : ZIKViewRouter</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKLoginViewRouter</div><div class="line">//app启动时，注册对应的模块和Router</div><div class="line">//不使用+load和+initialize方法，因为在Swift中已经不适用</div><div class="line">+ (void)registerRoutableDestination &#123;</div><div class="line">    [self registerView:[ZIKLoginViewController class]];</div><div class="line">    [self registerViewProtocol:ZIKRoutableProtocol(ZIKLoginViewProtocol)];</div><div class="line">&#125;</div><div class="line">//执行路由时，返回对应的viewController或者UIView</div><div class="line">- (id)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    UIStoryboard *sb = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil];</div><div class="line">    ZIKLoginViewController *destination = [sb instantiateViewControllerWithIdentifier:@&quot;ZIKLoginViewController&quot;];</div><div class="line">    return destination;</div><div class="line">&#125;</div><div class="line">//检查模块是否已经初始化完毕</div><div class="line">+ (BOOL)destinationPrepared:(UIViewController&lt;ZIKLoginViewProtocol&gt; *)destination &#123;</div><div class="line">    if (destination.loginService != nil) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line">//初始化工作</div><div class="line">- (void)prepareDestination:(UIViewController&lt;ZIKLoginViewProtocol&gt; *)destination configuration:(__kindof ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    if (destination.loginService == nil) &#123;</div><div class="line">        //ZIKLoginService也可以用ZIKServiceRouter动态获取</div><div class="line">        destination.loginService = [ZIKLoginService new];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//路由时的AOP回调</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router willPerformRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router didPerformRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router willRemoveRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router didRemoveRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>你甚至可以在不同情况下返回不同的destination，而调用者对此完全不知情。例如一个alertViewRouter为了兼容UIAlertView和UIAlertController，可以在router内部，iOS8以上使用UIAlertController，iOS8以下则使用UIAlertView。</p>
<p>一切路由的控制都在router类内部，不需要模块做出任何额外的修改。</p>
<h3 id="自由定义路由参数"><a href="#自由定义路由参数" class="headerlink" title="自由定义路由参数"></a>自由定义路由参数</h3><p>路由的配置信息都存储在configuration里，在调用者执行路由的时候传入。基本的跳转方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//跳转到Login界面</div><div class="line">[ZIKLoginViewRouter</div><div class="line">    performFromSource:self //界面跳转时的源界面</div><div class="line">    configuring:^(ZIKViewRouteConfiguration *config) &#123;</div><div class="line">        //跳转类型，支持push、presentModally、presentAsPopover、performSegue、show、showDetail、addChild、addSubview、custom、getDestination</div><div class="line">        config.routeType = ZIKViewRouteTypePush;</div><div class="line">        config.animated = NO;</div><div class="line">        config.prepareDestination = ^(id&lt;ZIKLoginViewProtocol&gt; destination) &#123;</div><div class="line">            //跳转前配置界面</div><div class="line">        &#125;;</div><div class="line">        config.routeCompletion = ^(id&lt;NoteEditorProtocol&gt; destination) &#123;</div><div class="line">         //跳转成功并结束处理</div><div class="line">      &#125;;</div><div class="line">      config.performerErrorHandler = ^(ZIKRouteAction routeAction, NSError * error) &#123;</div><div class="line">         //跳转失败处理，有失败的详细信息</div><div class="line">      &#125;;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>Configuration只能在初始化block里配置，出了block以后就无法修改。你也可以用一个configuration子类添加更多自定义信息。</p>
<p>如果不需要复杂的配置，也可以只用最简单的跳转：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ZIKLoginViewRouter performFromSource:self routeType:ZIKViewRouteTypePush];</div></pre></td></tr></table></figure>
<h3 id="移除已执行的路由"><a href="#移除已执行的路由" class="headerlink" title="移除已执行的路由"></a>移除已执行的路由</h3><p>你可以先初始化一个router，再交给其他角色执行路由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//初始化router</div><div class="line">self.loginRouter = [[ZIKLoginViewRouter alloc] initWithConfiguring:^(ZIKViewRouteConfiguration * _Nonnull config) &#123;</div><div class="line">                               config.source = self;</div><div class="line">                               config.routeType = ZIKViewRouteTypePush;</div><div class="line">                           &#125;];</div><div class="line">                           </div><div class="line">//执行路由</div><div class="line">if ([self.loginRouter canPerform] == NO) &#123;</div><div class="line">    NSLog(@&quot;此时无法执行路由:%@&quot;,self.loginRouter);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">[self.loginRouter performRouteWithSuccessHandler:^&#123;</div><div class="line">    NSLog(@&quot;performer: push success&quot;);</div><div class="line">&#125; performerErrorHandler:^(ZIKRouteAction routeAction, NSError * _Nonnull error) &#123;</div><div class="line">    NSLog(@&quot;performer: push failed: %@&quot;,error);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>当你需要消除已经展示的界面，或者销毁一个模块时，可以调用移除路由方法一键移除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if ([self.loginRouter canRemove] == NO) &#123;</div><div class="line">    NSLog(@&quot;此时无法移除路由:%@&quot;, self.loginRouter);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">[self.loginRouter removeRouteWithSuccessHandler:^&#123;</div><div class="line">    NSLog(@&quot;performer: pop success&quot;);</div><div class="line">&#125; performerErrorHandler:^(ZIKRouteAction routeAction, NSError * _Nonnull error) &#123;</div><div class="line">    NSLog(@&quot;performer: pop failed,error:%@&quot;,error);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>从而无需再区分调用pop、dismiss、removeFromParentViewController、removeFromSuperview等方法。</p>
<h3 id="通过protocol获取对应模块"><a href="#通过protocol获取对应模块" class="headerlink" title="通过protocol获取对应模块"></a>通过protocol获取对应模块</h3><h4 id="Protocol作为匹配标识"><a href="#Protocol作为匹配标识" class="headerlink" title="Protocol作为匹配标识"></a>Protocol作为匹配标识</h4><p>我们不想让外部引用<code>ZIKLoginViewRouter</code>头文件导致耦合，调用者只需要获取一个符合了<code>ZIKLoginViewProtocol</code>的view controller，因此只需要根据<code>ZIKLoginViewProtocol</code>获取到对应的router子类，然后在子类上调用父类<code>ZIKViewRouter</code>提供的路由方法即可，这样就可以做到隐藏子类。</p>
<p>使用<code>ZIKViewRouterToView</code>和<code>ZIKViewRouterToModule</code>宏，即可通过protocol获取到对应的router子类，并且子类返回的destination必定符合<code>ZIKLoginViewProtocol</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[ZIKViewRouterToView(ZIKLoginViewProtocol)</div><div class="line">    performFromSource:self</div><div class="line">    configuring:^(ZIKViewRouteConfiguration *config) &#123;</div><div class="line">         config.routeType = ZIKViewRouteTypePush;</div><div class="line">         config.prepareDestination = ^(id&lt;ZIKLoginViewProtocol&gt; destination) &#123;</div><div class="line">             //跳转前配置界面</div><div class="line">         &#125;;</div><div class="line">         config.routeCompletion = ^(id&lt;ZIKLoginViewProtocol&gt; destination) &#123;</div><div class="line">true         //跳转成功并结束处理</div><div class="line">true      &#125;;</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>这时候<code>ZIKLoginViewProtocol</code>就相当于LoginView模块的唯一identifier，不能再用到其他view controller上。你可以用多个protocol注册同一个router，用于区分<code>requiredProtocol</code>和<code>providedProtocol</code>。</p>
<h4 id="多对一匹配"><a href="#多对一匹配" class="headerlink" title="多对一匹配"></a>多对一匹配</h4><p>有时候，一些第三方的模块或者系统模块并没有提供自己的router，你可以为其封装一个router，此时可以有多个不同的router管理同一个UIViewController或者UIView类。这些router可能提供了不同的功能，比如同样是alertRouter，routerA可能是用于封装UIAlertController，routerB可能是用于兼容UIAlertView和UIAlertController，这时候要如何区分并获取两个不同的router？</p>
<p>像这种提供了独特功能的router，需要你使用configuration的子类，然后让子类conform对应功能的protocol。于是就可以根据configuration的protocol来获取对应的router：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[ZIKViewRouterToModule(ZIKCompatibleAlertConfigProtocol)</div><div class="line">    performFromSource:self</div><div class="line">    configuring:^(ZIKViewRouteConfiguration&lt;ZIKCompatibleAlertConfigProtocol&gt; * _Nonnull config) &#123;</div><div class="line"> 	config.routeType = ZIKViewRouteTypeCustom;</div><div class="line"> 	config.title = @&quot;Compatible Alert&quot;;</div><div class="line"> 	config.message = @&quot;Test custom route for alert with UIAlertView and UIAlertController&quot;;</div><div class="line"> 	[config addCancelButtonTitle:@&quot;Cancel&quot; handler:^&#123;</div><div class="line">true 	NSLog(@&quot;Tap cancel alert&quot;);</div><div class="line"> 	&#125;];</div><div class="line"> 	[config addOtherButtonTitle:@&quot;Hello&quot; handler:^&#123;</div><div class="line">true 	NSLog(@&quot;Tap hello button&quot;);</div><div class="line"> 	&#125;];</div><div class="line"> 	config.routeCompletion = ^(id _Nonnull destination) &#123;</div><div class="line">true 	NSLog(@&quot;show custom alert complete&quot;);</div><div class="line"> 	&#125;;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>如果模块自己提供了router，并且这个router用于依赖注入，不能被其他router替代，可以声明本router为本模块的唯一指定router，当有多个router尝试管理此模块时，启动时就会产生断言错误。</p>
<h3 id="依赖注入和依赖声明"><a href="#依赖注入和依赖声明" class="headerlink" title="依赖注入和依赖声明"></a>依赖注入和依赖声明</h3><h4 id="固定依赖和运行时依赖"><a href="#固定依赖和运行时依赖" class="headerlink" title="固定依赖和运行时依赖"></a>固定依赖和运行时依赖</h4><p>模块的依赖分为固定依赖和运行时参数依赖。</p>
<p>固定依赖就类似于VIPER各角色之间的依赖关系，是一个模块中固定不变的依赖。这种依赖只需要在router内部的<code>-prepareDestination:configuration:</code>固定配置即可。</p>
<p>运行时依赖就是外部传入的参数，由configuration负责传递，然后同样是在<code>-prepareDestination:configuration:</code>中，获取configuration并配置destination。你可以用一个configuration子类和router配对，这样就能添加更多自定义信息。</p>
<p>如果依赖参数很简单，也可以让router直接对destination进行配置，声明router的destination遵守<code>ZIKLoginViewProtocol</code>，让调用者在<code>prepareDestination</code>里设置destination。但是如果依赖涉及到了model对象的传递，并且由于需要隔离View和Model，destination不能接触到这些model对象，这时候还是需要让configuration传递依赖，在router内部再把model传给负责管理model的角色。</p>
<p>因此，configuration和destination的protocol就负责依赖声明和暴露接口。调用者只需要传入protocol里要求的参数或者调用一些初始化方法即可，至于router内部怎么使用和配置这些依赖，调用者就不用关心了。</p>
<h4 id="直接在头文件中声明"><a href="#直接在头文件中声明" class="headerlink" title="直接在头文件中声明"></a>直接在头文件中声明</h4><p>声明一个protocol是一个router的config protocol或者view protocol时，只需要让这个protocol继承自<code>ZIKViewConfigRoutable</code>或者<code>ZIKViewRoutable</code>即可。这样，所有的依赖声明都可以在头文件里明确表示，不必再从文档中查找。</p>
<h3 id="使用泛型指明特定router"><a href="#使用泛型指明特定router" class="headerlink" title="使用泛型指明特定router"></a>使用泛型指明特定router</h3><p>一个模块可以直接在内部用<code>ZIKViewRouterToModule</code>和<code>ZIKViewRouterToView</code>动态获取router，也可以在头文件里添加一个router属性，让builder注入。</p>
<p>那么一个模块怎么向builder声明自己需要某个特定功能的router呢？答案是父类+泛型。</p>
<p>ZIKRouter支持用泛型指定参数类型。在OC中可以这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//注意这个示例代码只是用于演示泛型的意思，实际运行时必须要用一个ZIKViewRouter子类才可以</div><div class="line">[ZIKViewRouter&lt;UIViewController *,ZIKViewRouteConfiguration&lt;ZIKLoginConfigProtocol&gt; *&gt;</div><div class="line">  performFromSource:self</div><div class="line">  configuring:^(ZIKViewRouteConfiguration&lt;ZIKLoginConfigProtocol&gt; *config) &#123;</div><div class="line">    config.routeType = ZIKViewRouteTypePerformSegue;</div><div class="line">    config.configureSegue(^(ZIKViewRouteSegueConfiguration *segueConfig) &#123;</div><div class="line">    	segueConfig.identifier = @&quot;showLoginViewController&quot;;</div><div class="line">    );</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>ZIKViewRouter&lt;UIViewController *, ZIKViewRouteConfiguration&lt;ZIKLoginConfigProtocol&gt; *&gt;</code>就是一个指定了泛型的类，尖括号中指定了router的destination和configuration类型。这一串说明相当于是在声明：这是一个destination为UIViewController类型，用<code>ZIKViewRouteConfiguration&lt;ZIKLoginConfigProtocol&gt; *</code>作为执行路由时的configuration的router类。你可以对configuration再添加protocol，表明这个configuration必须遵守指定的protocol。</p>
<p>这时你就可以用父类+泛型来声明一个router类，这个router类的configuration符合特定的config protocol。而且在写的时候Xcode会给你自动补全。这是一种很好的隐藏子类的方式，而且符合原生的语法。</p>
<p>但是由于OC中的类都是<code>Class</code>类型，因此只能这样声明一个实例属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) ZIKViewRouter&lt;UIViewController *,ZIKViewRouteConfiguration&lt;ZIKLoginConfigProtocol&gt; *&gt; *loginViewRouter;</div></pre></td></tr></table></figure>
<p>Builder只能注入一个router实例，而不是一个router class。因此在OC里一般不这么使用。</p>
<p>但是在Swift这种类型安全语言中这种模式就能更好地发挥作用了，你可以直接注入一个符合某个泛型的router：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//在Builder中注入alertRouter</div><div class="line">swiftSampleViewController.alertRouter = Router.to(RoutableViewModule&lt;ZIKCompatibleAlertConfigProtocol&gt;())</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class SwiftSampleViewController: UIViewController &#123;    </div><div class="line">    //在Builder里注入alertRouterClass后，就可以直接用这个routerClass执行路由</div><div class="line">    var alertRouter: ViewRouter&lt;Any, ZIKCompatibleAlertConfigProtocol&gt;!</div><div class="line">    </div><div class="line">    @IBAction func testInjectedRouter(_ sender: Any) &#123;</div><div class="line">        self.alertRouter.perform(</div><div class="line">            from: self,</div><div class="line">            configuring: &#123; (config, prepareDestination, prepareModule) in</div><div class="line">            prepareModule(&#123; moduleConfig in</div><div class="line">                //moduleConfig在类型推断时就是ZIKCompatibleAlertConfigProtocol，无需在判断后再强制转换</div><div class="line">                moduleConfig.title = &quot;Compatible Alert&quot;</div><div class="line">                moduleConfig.message = &quot;Test custom route for alert with UIAlertView and UIAlertController&quot;</div><div class="line">                moduleConfig.addCancelButtonTitle(&quot;Cancel&quot;, handler: &#123;</div><div class="line">                print(&quot;Tap cancel alert&quot;)</div><div class="line">                &#125;)</div><div class="line">                moduleConfig.addOtherButtonTitle(&quot;Hello&quot;, handler: &#123;</div><div class="line">                    print(&quot;Tap Hello alert&quot;)</div><div class="line">                &#125;)</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>声明了<code>ViewRouter&lt;Any, ZIKCompatibleAlertConfigProtocol&gt;</code>的属性后，外部就可以直接注入一个对应的router。可以用这种设计模式来转移、集中获取router的职责。</p>
<p>Router可以在定义的时候限制自己的泛型：</p>
<p>Objective-C:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface ZIKCompatibleAlertViewRouter : ZIKViewRouter&lt;UIViewController *, ZIKViewRouteConfiguration&lt;ZIKCompatibleAlertConfigProtocol&gt; *&gt;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>Swift:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class ZIKCompatibleAlertViewRouter: ZIKViewRouter&lt;UIViewController, ZIKViewRouteConfiguration &amp; ZIKCompatibleAlertConfigProtocol&gt; &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在传递的时候，就可以让编译器检查router是否正确。</p>
<h3 id="调用安全和类型安全"><a href="#调用安全和类型安全" class="headerlink" title="调用安全和类型安全"></a>调用安全和类型安全</h3><p>上面的演示已经展示了类型安全的处理，由protocol和泛型共同完成了这个类型安全的设计。不过有一些问题还需要特别注意。</p>
<h4 id="编译检查"><a href="#编译检查" class="headerlink" title="编译检查"></a>编译检查</h4><p>使用<code>ZIKViewRouterToModule</code>和<code>ZIKViewRouterToView</code>时，会对传入的protocol进行编译检查。保证传入的protocol是可路由的protocol，不能随意滥用。具体用到的方式有些复杂，而且在Objective-C和Swift上使用了两种方式来实现编译检查，具体实现可以看源代码。</p>
<h4 id="泛型的协变和逆变"><a href="#泛型的协变和逆变" class="headerlink" title="泛型的协变和逆变"></a>泛型的协变和逆变</h4><p>Swift的自定义泛型不支持协变，所以使用起来有点奇怪。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let alertRouterClass: ZIKViewRouter&lt;UIViewController, ZIKViewRouteConfiguration&gt;.Type</div><div class="line"> </div><div class="line"> //编译错误</div><div class="line"> //ZIKCompatibleAlertViewRouter.Type is ZIKViewRouter&lt;UIViewController, ZIKViewRouteConfiguration &amp; ZIKCompatibleAlertConfigProtocol&gt;.Type</div><div class="line"> alertRouterClass = ZIKCompatibleAlertViewRouter.self</div></pre></td></tr></table></figure>
<p>Swift的自定义泛型不支持子类型转为父类型，因此把<code>ZIKViewRouter&lt;UIViewController, ZIKViewRouteConfiguration &amp; ZIKCompatibleAlertConfigProtocol&gt;.Type</code>赋值给<code>ZIKViewRouter&lt;UIViewController, ZIKViewRouteConfiguration&gt;.Type</code>类型时就会出现编译错误。奇怪的是反过来逆变反而没有编译错误。而Swift原生的集合类型是支持协变的。从2015年开始就有人提议Swift对自定义泛型加入协变，到现在也没支持。在Objective-C里自定义泛型是可以正常协变的。</p>
<p>因此在swift里，使用了另一个类来包裹真正的router，而这个类是可以随意指定泛型的。</p>
<h3 id="用Adapter兼容接口"><a href="#用Adapter兼容接口" class="headerlink" title="用Adapter兼容接口"></a>用Adapter兼容接口</h3><p>可以用不同的protocol获取到相同的router。也就是<code>requiredProtocol</code>和<code>providedProtocol</code>只要有声明，都可以获取到同一个router。</p>
<p>首先检查<code>requiredProtocol</code>和<code>providedProtocol</code>，确定两个接口提供的功能是一致的。否则无法兼容。</p>
<h4 id="为Provided模块添加Required-Interface"><a href="#为Provided模块添加Required-Interface" class="headerlink" title="为Provided模块添加Required Interface"></a>为<code>Provided</code>模块添加<code>Required Interface</code></h4><p><code>requiredProtocol</code>是外部的要求目的模块额外兼容的，由App Context在ZIKViewAdapter的子类里进行接口兼容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@protocol ModuleARequiredLoginViewInput &lt;ZIKViewRoutable&gt;</div><div class="line">@property (nonatomic, copy) NSString *message;</div><div class="line">@end</div><div class="line"></div><div class="line">//Module A中的调用代码</div><div class="line">UIViewController&lt;ModuleARequiredLoginViewInput&gt; *loginViewController = [ZIKViewRouterToView(LoginViewInput) makeDestination];</div><div class="line">loginViewController.message = @&quot;请登录查看笔记详情&quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//Login Module Provided Interface</div><div class="line">@protocol ProvidedLoginViewInput &lt;NSObject&gt;</div><div class="line">@property (nonatomic, copy) NSString *notifyString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//ZIKEditorAdapter.h，ZIKViewAdapter子类</div><div class="line">@interface ZIKEditorAdapter : ZIKViewRouteAdapter</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//ZIKEditorAdapter.m</div><div class="line">//用Objective-C的category、Swift的extension进行接口适配</div><div class="line">@interface LoginViewController (ModuleAAdapte) &lt;ModuleARequiredLoginViewInput&gt;</div><div class="line">@property (nonatomic, copy) NSString *message;</div><div class="line">@end</div><div class="line">@implementation LoginViewController (ModuleAAdapte)</div><div class="line">- (void)setMessage:(NSString *)message &#123;</div><div class="line">trueself.notifyString = message;</div><div class="line">&#125;</div><div class="line">- (NSString *)message &#123;</div><div class="line">truereturn self.notifyString;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKEditorAdapter</div><div class="line"></div><div class="line">+ (void)registerRoutableDestination &#123;</div><div class="line">true//注册NoteListRequiredNoteEditorProtocol和ZIKEditorViewRouter匹配</div><div class="line">true[ZIKEditorViewRouter registerViewProtocol:ZIKRoutableProtocol(NoteListRequiredNoteEditorProtocol)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="用中介者转发接口"><a href="#用中介者转发接口" class="headerlink" title="用中介者转发接口"></a>用中介者转发接口</h4><p>如果遇到protocol里的一些delegate需要兼容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@protocol ModuleARequiredLoginViewDelegate &lt;NSObject&gt;</div><div class="line">- (void)didFinishLogin;</div><div class="line">@end</div><div class="line"></div><div class="line">@protocol ModuleARequiredLoginViewInput &lt;ZIKViewRoutable&gt;</div><div class="line">@property (nonatomic, copy) NSString *message;</div><div class="line">@property (nonatomic, weak) id&lt;ModuleARequiredLoginViewDelegate&gt; delegate;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@protocol LoginViewDelegate &lt;NSObject&gt;</div><div class="line">- (void)didLogin;</div><div class="line">@end</div><div class="line"></div><div class="line">@protocol ProvidedLoginViewInput &lt;NSObject&gt;</div><div class="line">@property (nonatomic, copy) NSString *notifyString;</div><div class="line">@property (nonatomic, weak) id&lt;LoginViewDelegate&gt; delegate;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这种情况在OC里可以hook<code>-setDelegate:</code>方法，用<code>NSProxy</code>来进行消息转发，把<code>LoginViewDelegate</code>的消息转发为对应的<code>ModuleARequiredLoginViewDelegate</code>中的消息。</p>
<p>不过Swift里就不适合这么干了，相同方法有不同参数类型时，可以用一个新的router代替真正的router，在新的router里插入一个中介者，负责转发接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@implementation ZIKEditorMediatorViewRouter</div><div class="line">+ (void)registerRoutableDestination &#123;</div><div class="line">true//注册NoteListRequiredNoteEditorProtocol，和新的ZIKEditorMediatorViewRouter配对，而不是目的模块中的ZIKEditorViewRouter</div><div class="line">true//新的ZIKEditorMediatorViewRouter负责调用ZIKEditorViewRouter，插入一个中介者</div><div class="line">true[self registerView:/* mediator的类*/];	</div><div class="line">true[self registerViewProtocol:ZIKRoutableProtocol(NoteListRequiredNoteEditorProtocol)];</div><div class="line">&#125;</div><div class="line">- (id)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">   //用ZIKEditorViewRouter获取真正的destination</div><div class="line">   id&lt;ProvidedLoginViewInput&gt; realDestination = [ZIKEditorViewRouter makeDestination];</div><div class="line">    //获取一个负责转发ProvidedLoginViewInput和ModuleARequiredLoginViewInput的mediator</div><div class="line">    id&lt;ModuleARequiredLoginViewInput&gt; mediator = MediatorForDestination(realDestination);</div><div class="line">    return mediator;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一般来说，并不需要立即把所有的protocol都分离为<code>requiredProtocol</code>和<code>providedProtocol</code>。调用模块和目的模块可以暂时共用protocol，或者只是简单地改个名字，在第一次需要替换模块的时候再对protocol进行分离。</p>
<h3 id="封装UIKit跳转和移除方法"><a href="#封装UIKit跳转和移除方法" class="headerlink" title="封装UIKit跳转和移除方法"></a>封装UIKit跳转和移除方法</h3><h4 id="封装iOS的路由方法"><a href="#封装iOS的路由方法" class="headerlink" title="封装iOS的路由方法"></a>封装iOS的路由方法</h4><p><code>ZIKViewRouter</code>把UIKit中路由相关的方法：</p>
<ul>
<li><code>-pushViewController:animated:</code></li>
<li><code>-presentViewController:animated:completion:</code></li>
<li><code>UIPopoverController</code>的<code>-presentPopoverFromRect:inView:permittedArrowDirections:animated:</code></li>
<li><code>UIPopoverPresentationController</code>的配置</li>
<li><code>-performSegueWithIdentifier:sender:</code></li>
<li><code>-showViewController:sender:</code></li>
<li><code>-showDetailViewController:sender:</code></li>
<li><code>-addChildViewController:</code></li>
<li><code>-addSubview:</code></li>
</ul>
<p>全都统一封装，可以用枚举一键切换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ZIKViewRouterToView(ZIKLoginViewProtocol)</div><div class="line">    performFromSource:self routeType::ZIKViewRouteTypePush];</div></pre></td></tr></table></figure>
<p>对应的枚举值：</p>
<ul>
<li><code>ZIKViewRouteTypePush</code></li>
<li><code>ZIKViewRouteTypePresentModally</code></li>
<li><code>ZIKViewRouteTypePresentAsPopover</code></li>
<li><code>ZIKViewRouteTypePerformSegue</code></li>
<li><code>ZIKViewRouteTypeShow</code></li>
<li><code>ZIKViewRouteTypeShowDetail</code></li>
<li><code>ZIKViewRouteTypeAddAsChildViewController</code></li>
<li><code>ZIKViewRouteTypeAddAsSubview</code></li>
<li><code>ZIKViewRouteTypeCustom</code></li>
<li><code>ZIKViewRouteTypeGetDestination</code></li>
</ul>
<p>移除路由时，也不必再判断不同情况分别调用<code>-popViewControllerAnimated:</code>、<code>-dismissViewControllerAnimated:completion:</code>、<code>-dismissPopoverAnimated:</code>、<code>-removeFromParentViewController</code>、<code>-removeFromSuperview</code>等方法。</p>
<p><code>ZIKViewRouter</code>会在内部自动调用对应的方法。</p>
<h4 id="识别adaptative类型的路由"><a href="#识别adaptative类型的路由" class="headerlink" title="识别adaptative类型的路由"></a>识别<code>adaptative</code>类型的路由</h4><p><code>-performSegueWithIdentifier:sender:</code>、<code>-showViewController:sender:</code>、<code>-showDetailViewController:sender:</code>这些<code>adaptative</code>的路由方法，系统会根据不同的情况适配<code>UINavigationController</code>和<code>UISplitViewController</code>，选择调用<code>push</code>、<code>present</code>或者其他方式。直接调用时无法明确知道最终调用的是哪个方法，也就无法移除界面。</p>
<p><code>ZIKViewRouter</code>可以识别这些路由方法在调用后真正执行的路由操作，所以你现在也可以在使用这些方法后移除界面。</p>
<h4 id="支持自定义路由"><a href="#支持自定义路由" class="headerlink" title="支持自定义路由"></a>支持自定义路由</h4><p><code>ZIKViewRouter</code>也支持在子类中提供自定义的路由和移除路由方法。只要写好对应的协议即可。</p>
<h4 id="关于extension里的跳转方法"><a href="#关于extension里的跳转方法" class="headerlink" title="关于extension里的跳转方法"></a>关于extension里的跳转方法</h4><p>App extension里还有一些特有的跳转方法，比如<code>Watch</code>扩展里<code>WKInterfaceController</code>的<code>-pushControllerWithName:context:</code>和<code>-popController</code>，<code>Share</code>扩展里<code>SLComposeServiceViewController</code>的<code>-pushConfigurationViewController:</code>和<code>-popConfigurationViewController</code>。</p>
<p>看了一下extension的种类有十几个，懒得一个个去适配了。而且extension里的界面不会特别复杂，不是特别需要路由工具。如果你需要适配extension，可以自己增加，也可以用<code>ZIKViewRouteTypeCustom</code>来适配。</p>
<h3 id="支持storyboard"><a href="#支持storyboard" class="headerlink" title="支持storyboard"></a>支持storyboard</h3><p><code>ZIKViewRouter</code>支持storyboard，这也是和其他Router相比更强的地方。毕竟storyboard有时候也是很好用的，当使用了storyboard的项目中途使用router的时候，总不能为了适配router，把所有使用storyboard的界面都重构吧？</p>
<p>适配storyboard的原理是hook了所有UIViewController的<code>-prepareForSegue:sender:</code>方法，检查destinationViewController是否遵守<code>ZIKRoutableView</code>协议，如果遵守，就说明是一个由router管理的界面，获取注册的对应router类，生成router实例，对其进行依赖注入。如果destination需要传入动态参数，就会调用sourceViewController的<code>-prepareDestinationFromExternal:configuration:</code>方法，让sourceViewController传参。如果有多个router类注册了同一个view controller，则取随机的一个router。</p>
<p>你不需要对现有的模块做任何修改，就可以直接兼容。而且原来view controller中的<code>-prepareForSegue:sender:</code>也能照常使用。</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><code>ZIKViewRouter</code>会在一个界面执行路由和移除路由的时候，对所有注册了此界面的router回调4个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (void)router:(nullable ZIKViewRouter *)router willPerformRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router didPerformRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router willRemoveRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router didRemoveRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以在这些方法中检查界面是否配置正确。也可以用于AOP记录。</p>
<p>例如，你可以为<code>UIViewController</code>这个所有view controller的父类注册一个router，这样就可以监控所有的<code>UIViewController</code>子类的路由事件。</p>
<h3 id="路由错误检查"><a href="#路由错误检查" class="headerlink" title="路由错误检查"></a>路由错误检查</h3><p><code>ZIKRouter</code>会在启动时进行所有router的注册，这样就能检测出router是否有冲突、protocol是否和router正确匹配，保证所有router都能正确工作。当检测到错误时，断言将会失败。</p>
<p><code>ZIKViewRouter</code>在执行界面路由时，会检测并报告路由时的错误。例如：</p>
<ul>
<li>使用了错误的protocol执行路由</li>
<li>执行路由时configuration配置错误</li>
<li>不支持的路由方式（router可以限制界面只能使用push、present等有限的跳转方式）</li>
<li>在其他界面的跳转过程中，执行了另一个界面的跳转（<code>unbalanced transition</code>错误，会导致<code>-viewWillAppear:</code>、<code>-viewDidAppear:</code>、<code>-viewWillDisAppear:</code>、<code>-viewDidDisappear:</code>等事件的顺序发生错乱）</li>
<li>Source view controller此时的状态无法执行当前路由</li>
<li>路由时container view controller配置错误</li>
<li>segue在代理方法中被取消，导致路由未执行</li>
<li>重复执行路由</li>
</ul>
<p>基本上包含了界面跳转时会发生的大部分错误事件。</p>
<h3 id="支持任意模块"><a href="#支持任意模块" class="headerlink" title="支持任意模块"></a>支持任意模块</h3><p><code>ZIKRouter</code>包含<code>ZIKViewRouter</code>和<code>ZIKServiceRouter</code>。<code>ZIKViewRouter</code>专门用于界面跳转，<code>ZIKServiceRouter</code>则可以添加任意类进行实例获取。</p>
<p>你可以用<code>ZIKServiceRouter</code>管理需要的类，并且<code>ZIKServiceRouter</code>增添了和<code>ZIKViewRouter</code>相同的动态性和泛型支持。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>为了错误检查、支持storyboard和注册，<code>ZIKViewRouter</code>和<code>ZIKServiceRouter</code>会在app启动时遍历所有类，进行hook和注册的工作。注册时只是把view class、protocol和router class的地址加入字典，不会对内存有影响。</p>
<p>在release模式下，iPhone6s机型上，测试了5000个UIViewController以及5000个对应的router，遍历所有类并且hook的耗时大约为15ms，注册router的耗时大约为50ms。基本上不会遇到性能问题。</p>
<p>如果你不需要支持storyboard，可以去掉view class和router class配对的注册，去掉以后就无法自动为storyboard里的view controller创建router。至于protocol和router的注册，目前似乎是无法避免的。</p>
<h2 id="项目地址和Demo"><a href="#项目地址和Demo" class="headerlink" title="项目地址和Demo"></a>项目地址和Demo</h2><p>简单来说，ZIKRouter就是一个用于模块间路由，基于接口进行模块发现和依赖注入的Router。它以原生的语法执行路由，在OC和Swift中都能使用。</p>
<p>项目地址在：<a href="https://github.com/Zuikyo/ZIKRouter" target="_blank" rel="external">ZIKRouter</a>。里面包含了一个demo，用于演示iOS中大部分的界面路由场景，建议在横屏iPad上运行。</p>
<p>最后记得点个star~</p>
<p>Demo截图，控制台的输出就是界面路由时的AOP回调：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-f1eef5831de2a8ce.gif?imageMogr2/auto-orient/strip" alt="demo"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://mrpeak.cn/blog/module/" target="_blank" rel="external">iOS组件化方案</a></li>
<li><a href="http://www.jianshu.com/p/76da56b3bd55" target="_blank" rel="external">iOS 组件化 —— 路由设计思路分析</a></li>
<li><a href="http://www.uml-diagrams.org/component-diagrams.html" target="_blank" rel="external">component-diagrams</a></li>
<li><a href="https://github.com/alibaba/BeeHive" target="_blank" rel="external">BeeHive</a></li>
<li><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="external">CTMediator</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;路由是实现模块间解耦的一个有效工具。如果要进行组件化开发，路由是必不可少的一部分。目前iOS上绝大部分的路由工具都是基于URL匹配的，优缺点都很明显。这篇文章里将会给出一个更加原生和安全的设计，这个设计的特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由时用protocol寻找模块&lt;
    
    </summary>
    
      <category term="代码架构" scheme="http://zuikyo.github.io/categories/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS VIPER架构实践(二)：VIPER详解与实现</title>
    <link href="http://zuikyo.github.io/2017/08/11/iOS%20VIPER%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5(%E4%BA%8C)%EF%BC%9AVIPER%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://zuikyo.github.io/2017/08/11/iOS VIPER架构实践(二)：VIPER详解与实现/</id>
    <published>2017-08-11T08:55:29.000Z</published>
    <updated>2018-01-24T01:45:41.320Z</updated>
    
    <content type="html"><![CDATA[<p>第一篇文章对VIPER进行了简单的介绍，这篇文章将从VIPER的源头开始，比较现有的几种VIPER实现，对VIPER进行进一步的职责剖析，并对各种细节实现问题进行挖掘和探讨。最后给出两个完整的VIPER实现，并且提供快速生成VIPER代码的模板。</p>
<p>Demo和轮子的github地址是：<a href="https://github.com/Zuikyo/ZIKViper" target="_blank" rel="external">ZIKViper</a>，路由工具：<a href="https://github.com/Zuikyo/ZIKRouter" target="_blank" rel="external">ZIKRouter</a>。有用请点个star~</p>
<p>两个实现展示了以下问题的解决方案：</p>
<ul>
<li>如何彻底地解决不同模块之间的耦合</li>
<li>如何在一个模块里引入子模块</li>
<li>子模块和父模块之间如何通信</li>
<li>如何对模块进行依赖注入</li>
<li>面向接口的路由工具</li>
</ul>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>VIPER架构，最初是2013年在MutualMobile的技术博客上，由Jeff Gilbert 和 Conrad Stoll 提出的。他们的博客网站有过一次迁移，原文地址已经失效，这是迁移后的博文：<a href="https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework" target="_blank" rel="external">MEET VIPER: MUTUAL MOBILE’S APPLICATION OF CLEAN ARCHITECTURE FOR IOS APPS</a>。</p>
<p>这是文章中提出的架构示意图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-13daad61ed8db39c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="viper_mutualmobile"></p>
<p>Wireframe可以看作是Router的另一种表达。可以看到，VIPER之间的关系已经很明确了。之后，作者在2014年在objc.io上发表了另一篇更详细的介绍文章：<a href="https://www.objc.io/issues/13-architecture/viper/" target="_blank" rel="external">Architecting iOS Apps with VIPER</a>。</p>
<p>在作者的第一篇文章里，阐述了VIPER是在接触到了Uncle Bob的<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">Clean Architecture</a>后，对Clean Architecture的一次实践。因此，VIPER真正的源头应该是Clean Architecture。</p>
<h2 id="Clean-Architecture"><a href="#Clean-Architecture" class="headerlink" title="Clean Architecture"></a>Clean Architecture</h2><p>由Uncle Bob在2011年提出的<code>Clean Architecture</code>，是一个平台无关的抽象架构。想要详细学习的，可以阅读作者的原文：<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">Clean Architecture</a>，翻译：<a href="http://www.jdon.com/artichect/the-clean-architecture.html" target="_blank" rel="external">干净的架构The Clean Architecture</a>。</p>
<p>它通过梳理软件中不同层之间的依赖关系，提出了一个自外向内，单向依赖的架构，如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-dda97ce26c973609.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Clean Architecture"></p>
<p>越靠近内层，越变得抽象，越接近设计的核心。越靠近外层，越和具体的平台和实现技术相关。内层的部分完全不知道外层的存在和实现方式，代码只能从外层向内层引用，目的是为了实现层与层之间的隔离。将不同抽象程度的层进行隔离，做到了把业务规则和具体实现分离开。你可以把外层看作是内层的delegate，外层只能通过内层提供的delegate接口来使用内层。</p>
<h3 id="Enterprise-Business-Rules"><a href="#Enterprise-Business-Rules" class="headerlink" title="Enterprise Business Rules"></a>Enterprise Business Rules</h3><p>代表了这个软件项目的业务规则。由数据实体体现，是一些可以在不同的程序应用之间共享的数据结构。</p>
<h3 id="Application-Business-Rules"><a href="#Application-Business-Rules" class="headerlink" title="Application Business Rules"></a>Application Business Rules</h3><p>代表了本应用所使用的一些业务规则。封装和实现了用到的业务功能，会将各种实体的数据结构转为在用例中传递的实体类，但是和具体的数据库技术或者UI无关。</p>
<h3 id="Interface-Adapters"><a href="#Interface-Adapters" class="headerlink" title="Interface Adapters"></a>Interface Adapters</h3><p>接口适配层。将用例的规则和具体的实现技术进行抽象地对接，将用例中用到的实体类转为供数据库存储的格式或者供View展示的格式。类似于MVVM中把Model的数据传递给ViewModel供View显示。</p>
<p>右下角表示了接口适配层中不同模块间的通信方式。不同的模块在业务用例中产生关联和数据传递。Input、Output就是Use Case提供给外层的数据流动接口。</p>
<h3 id="Frameworks-amp-Drivers"><a href="#Frameworks-amp-Drivers" class="headerlink" title="Frameworks &amp; Drivers"></a>Frameworks &amp; Drivers</h3><p>库和驱动层，代表了选用的各种具体的实现技术，例如持久层使用SQLite还是Core Data，网络层使用NSURLSession、NSURLConnection还是AFNetworking等。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到，Clean Architecture里已经出现了Use Case、Interactor、Presenter等概念，它为VIPER的工程实现提供了设计思想，VIPER将它的设计转化成了具体的实现。VIPER里的各部分正是存在着由外向内的依赖，从外向内表现为：<code>View -&gt; Presenter -&gt; Interactor -&gt; Entity</code>，<code>Wireframe</code>严格来说也是一类特殊的Use Case，用于不同模块之间通信，连接了不同的<code>Presenter</code>。</p>
<p>必须要记住的是，<strong>VIPER架构是根据由外向内的依赖关系来设计的</strong>。这句话是指导我们进行进一步设计和优化的关键。</p>
<h2 id="现有的各种VIPER实现"><a href="#现有的各种VIPER实现" class="headerlink" title="现有的各种VIPER实现"></a>现有的各种VIPER实现</h2><p>MutualMobile的那两篇文章虽然已经明确了VIPER各部分之间的职责，并且给出了简单的Demo，但是对Wireframe部分的实现有些争议，解耦做得不够彻底，并且对各层之间如何交互还处在最简单的实现上。之后出现了挺多文章来将VIPER进一步细化，不过某些细节的实现上有些差别，在给出我自己的VIPER之前，我将先对这些实现进行一次综合的比较分析，看看他们都使用了哪些技术，遇到了哪些争议点。不同实现之间已经公认的地方我就不再单独列出了。</p>
<h3 id="Brigade团队的实现"><a href="#Brigade团队的实现" class="headerlink" title="Brigade团队的实现"></a>Brigade团队的实现</h3><p>原文地址：<a href="https://brigade.engineering/brigades-experience-using-an-mvc-alternative-36ef1601a41f" target="_blank" rel="external">Brigade’s Experience Using an MVC Alternative: VIPER architecture for iOS applications</a>。</p>
<p>文章把VIPER的优点总结了一下，提出了这样的架构图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-76a4f532c58da061.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Brigade’s VIPER"></p>
<p>他们对VIPER的各部分都没有异议，只是对Interactor的实现进行了进一步细化。用一个Data Manager提供给各个Use Case管理Entity，比如获取、存储功能。在Service中调用网络层去获取服务端的数据。</p>
<p>文章中还认为应该由Wireframe负责初始化整个VIPER，生成各部分的类，并设置依赖关系，并且引用另一个模块的Wireframe，负责跳转到另一个界面。</p>
<p>和这个实现类似的还有：</p>
<ul>
<li><a href="https://swifting.io/blog/2016/03/07/8-viper-to-be-or-not-to-be/" target="_blank" rel="external">VIPER to be or not to be?</a>。这篇文章里给出了一个Unit Test的例子，还探讨了应该在什么情况下开始应用VIPER。</li>
<li><a href="https://cheesecakelabs.com/blog/best-practices-viper-architecture/" target="_blank" rel="external">VIPER architecture: Our best practices to build an app like a boss</a>。Demo地址：<a href="https://github.com/CheesecakeLabs/Boilerplate_iOS_VIPER" target="_blank" rel="external">Boilerplate_iOS_VIPER</a>。</li>
</ul>
<p>针对VIPER需要编写太多初始化代码的麻烦，可以使用Xcode自带的Template解决。而很多作者都提到了一个代码生成工具：<a href="https://github.com/rambler-digital-solutions/Generamba" target="_blank" rel="external">Generamba</a>。</p>
<h4 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h4><p>文章并没有对VIPER进行修改，只是进一步细化了。这应该是一个最简单的实现。如果你要实施VIPER，参照这篇文章来没有什么大问题。但是它没有探讨的问题是：</p>
<ul>
<li>如何解决不同Wrieframe之间的耦合？</li>
<li>Wrieframe如何知道其他模块需要的初始化参数？</li>
<li>在模块间通信时，Interactor的数据如何传递给另一个模块？</li>
<li>父模块和子模块之间是怎样的关系？</li>
</ul>
<h3 id="Rambler-amp-Co团队的实现"><a href="#Rambler-amp-Co团队的实现" class="headerlink" title="Rambler&amp;Co团队的实现"></a>Rambler&amp;Co团队的实现</h3><p>一个对VIPER十分感兴趣的俄国团队，编写了一本关于VIPER的书：<a href="https://github.com/strongself/The-Book-of-VIPER" target="_blank" rel="external">The-Book-of-VIPER</a>。并且给出了一个目前网络上实现完成度最高的开源Demo：<a href="https://github.com/rambler-digital-solutions/rambler-it-ios" target="_blank" rel="external">rambler-it-ios</a>，以及他们用于实施VIPER的库：<a href="https://github.com/rambler-digital-solutions/ViperMcFlurry" target="_blank" rel="external">ViperMcFlurry</a>。</p>
<p>他们整理的VIPER架构图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-9f35c09e9c9b0f12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Rambler&amp;Co&#39;s VIPER"></p>
<p>和其他实现不同的是，他们把VIPER的初始化和装配工作单独放到了一个Assembly里，Router只做界面跳转的工作。并且把VIPER内不同部分之间的通信统一用Input和Output来表示。Input表示外部主动调用模块提供的接口，Output表示模块通过外部实现所要求的接口，将事件传递到外部。</p>
<p>之所以将模块初始化单独放到Assembly里，是因为Router如果负责初始化本模块，会违背单一职责原则。</p>
<h4 id="争议-1"><a href="#争议-1" class="headerlink" title="争议"></a>争议</h4><p>这个实现的愿景很好，只是在转变为具体实现的时候不够完美，有很多问题尚待解决。具体可以参见Demo。</p>
<ul>
<li>Assembly使用了<a href="https://github.com/appsquickly/Typhoon" target="_blank" rel="external">Typhoon</a>这个依赖注入工具，通过Method Swizzling自动初始化VIPER的各个部分</li>
</ul>
<p>我对Typhoon这个依赖注入工具不是特别感冒，它使用了十分复杂的run time技术，想要追踪一个对象的注入过程时，会看得晕头转向。而且它无法实现运行时由调用方动态注入，只能实现预定义好的静态注入。也就是不能动态传参。</p>
<ul>
<li>使用storyboard进行路由</li>
</ul>
<p>在Demo中实现了在执行segue时用block来使用<code>-prepareForSegue:sender:</code>，实现向目的界面传参，实现了动态注入。但是这样就把路由限定在了storyboard的segue技术上，那么对于那些没有使用storyboard的项目应该怎么办呢？Demo并没有给出答案。而且<code>-prepareForSegue:sender:</code>只能向View传参，但是有一些参数是View不应该接触到的，而是应该直接传给Presenter或者Interactor的。</p>
<ul>
<li>有时候模块需要从Output中获取数据，例如Presenter主动获取View中的文字，传递给Interactor，此时<code>Output</code>并不能完整描述它的职责，还可以再进一步划分</li>
</ul>
<p>也就是说，他们的方案在设计上是不错的，但在技术上还有很多改进空间。</p>
<h3 id="Uber团队的实现"><a href="#Uber团队的实现" class="headerlink" title="Uber团队的实现"></a>Uber团队的实现</h3><p>Uber由于业务越来越复杂，旧项目的架构已经无法满足当前的需求，因此在2016年完全重构了他们的 rider app。他们借鉴VIPER，并且设计出了一个VIPER的变种架构：Riblets。文章地址：<a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="external">ENGINEERING THE ARCHITECTURE BEHIND UBER’S NEW RIDER APP</a>。</p>
<p>架构图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-ad4602f11ed62094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="riblets"></p>
<p>数据流向图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-bdb29d6717472b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="riblets_数据流向"></p>
<p>父模块和子模块之间通信：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-e71eed65c555ddc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="riblet_父子模块间通信"></p>
<h4 id="各部分职责"><a href="#各部分职责" class="headerlink" title="各部分职责"></a>各部分职责</h4><p>这里只列出一些和VIPER有差异的地方：</p>
<ul>
<li>Builder负责初始化Riblets模块内的各个部分，定义了模块的依赖参数</li>
<li>Component负责获取和初始化那些不是Riblets模块内的部分，例如services，并注入到Interactor中</li>
<li>Router负责管理子模块，持有子模块的Router，并把子模块的View添加到视图树上</li>
<li>Interactor通过调用Service管理Model，而不是在Interactor中直接管理</li>
<li>Interactor和子模块的Interactor通过监听者模式和delegate互相通信</li>
</ul>
<h4 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h4><p>最大的改变是将Router从Presenter移到了Interactor，改变了模块的主从关系，整个模块的生命周期现在由Interactor来管理。而之前的VIPER模块是依赖于View的生命周期的。这样一来，整个架构就从View驱动变成了业务驱动，或者数据驱动。</p>
<p>关于这个改变，Uber给出了两个原因：</p>
<ul>
<li>想要统一iOS和Andorid的软件架构，以及更好地互相借鉴开发经验和教训，因而需要改变iOS中视图驱动的设计</li>
<li>想要创建一个没有View，只有业务逻辑的模块，因此生命周期需要由Interactor管理</li>
</ul>
<h4 id="争议-2"><a href="#争议-2" class="headerlink" title="争议"></a>争议</h4><p>Uber团队的确很有想法。在对他们的这个方案进行深入实践之前，我无法评论这个方案是好是坏，我只在这里提出一些实践中可能会遇到的问题。</p>
<p>关于Uber给出的第一个原因，这是Uber团队基于协调两个开发团队的情况而做出的选择，如果我们没有他们这样统一开发的需求，并没有必要借鉴。iOS的UIKit是一个视图驱动的框架，很难做到100%数据驱动，在实践中将会遇到许多需要解决的问题，除非有足够的开发时间，否则不要草率地投入其中。是否要使用数据驱动的设计，还是应该由项目的业务设计来决定。当数据变化大部分是由后端的Service和网络数据引起时，再去考虑数据驱动吧。例如Uber的地图路线由定位模块不断计算，自动更新，就比较适合使用数据驱动。</p>
<p>关于第二个原因，一个没有View和Presenter的VIPER，就只剩下Router、Interactor、Model，这时这个模块可以看做是一个可以通过Router调用的Service或者Manager，这个Service有自己的状态和生命周期，Service也可以在View销毁后继续完成剩余的业务工作，只要业务需要，可以进行自持有，自释放。而且这个Service最终还是会表现在某个View上。这么看来，Router的层级已经升高了，成为了整个app内的模块间通信工具，可以连接任意模块，不仅仅是VIPER，因此Router由谁持有，就完全由模块内部自由管理了。</p>
<p>只是，在iOS中的VIPER里，实际的路由API都是存在于UIViewController上的，Router会直接和View产生引用，把Router放到和View隔离的Interactor里会破坏隔离。而且从Clean架构的分层来看，层级升高后的Router应该是处在Interface Adapter层和Framework &amp; Driver层之间，而Interactor则是在Application Business Rules层，由Interactor来管理其他角色，会破坏了Clean Architecture里的依赖关系。</p>
<p>比如一个没有View的、用于管理语音通话数据的Interactor，收到了通话异常中断的事件，在处理事件时，它不应该通过Router将自己移除，或者结束整个语音通话业务，或者自动调用重新拨号的业务，这样很容易会让不同的Use Case之间产生耦合，这些都应该由更上层的Service去选择执行，如果有页面跳转的设计，则应该把事件转发给一个存在Presenter层的Parent VIPER模块，由parent来决定是退出通话界面还是弹窗提示。当一个Interactor没有Presenter和View时，它一定是另一个VIPER的子模块。这么看来，在没有View时，或许让Service来持有Router才是正确的。</p>
<p>因此，如果真的有把VIPER变成数据驱动的需求，主要还是源于Uber给出的第一个基于团队统一的理由。</p>
<h4 id="其他设计"><a href="#其他设计" class="headerlink" title="其他设计"></a>其他设计</h4><p>文章里还给出了一些很有参考价值的内容，比如：</p>
<ul>
<li>对Interactor进行注入的Component</li>
<li>视图树变成了Router树</li>
<li>Interactor不直接维护Model，而是通过对应的Service来维护Model</li>
<li>父模块和子模块之间通过Interactor来通信</li>
</ul>
<p>Uber的这个方案讲了很多其他方案没有提到的方面，比如依赖注入、如何引入子模块等问题。不过这个方案并没有开源。</p>
<h2 id="方案一：最完整的VIPER"><a href="#方案一：最完整的VIPER" class="headerlink" title="方案一：最完整的VIPER"></a>方案一：最完整的VIPER</h2><p>各种实现方案都分析了一遍，接下来就开始进行一个总结。首先总结出一个绝对标准的VIPER，各部分遵循隔离关系，同时考虑到依赖注入、子模块通信、模块间解耦等问题，将VIPER的各部分的职责变得更加明确，也新增了几个角色。示例图如下，各角色的颜色和Clean Architecture图中各层的颜色对应：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-a204e884cdb08f63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="thorough_viper"></p>
<p>示例代码将用一个笔记应用作为演示。</p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View可以是一个UIView + UIViewController，也可以只是一个custom UIView，也可以是一个自定义的用于管理UIView的Manager，只要它实现了View的接口就可以。</p>
<p>View层的职责：</p>
<ul>
<li>展示界面，组合各种UIView，并在UIViewController内管理各种控件的布局、更新</li>
<li>View对外暴露各种用于更新UI的接口，而自己不主动更新UI</li>
<li>View持有一个由外部注入的eventHandler对象，将View层的事件发送给eventHandler</li>
<li>View持有一个由外部注入的viewDataSource对象，在View的渲染过程中，会从viewDataSource获取一些用于展示的数据，viewDataSource的接口命名应该尽量和具体业务无关</li>
<li>View向Presenter提供routeSource，也就是用于界面跳转的源界面</li>
</ul>
<p>View层会引入各种自定义控件，这些控件有许多delegate，都在View层实现，统一包装后，再交给Presenter层实现。因为Presenter层并不知道View的实现细节，因此也就不知道这些控件的接口，Presenter层只知道View层统一暴露出来的接口。而且这些控件的接口在定义时可能会将数据获取、事件回调、控件渲染接口混杂起来，最具代表性的就是<code>UITableViewDataSource</code>里的<code>-tableView:cellForRowAtIndexPath:</code>。这个接口同时涉及到了<code>UITableViewCell</code>和渲染cell所需要的Model，是非常容易产生耦合的地方，因此需要做一次分解。应该在View的dataSource里定义一个从外部获取所需要的简单类型数据的方法，在<code>-tableView:cellForRowAtIndexPath:</code>里用获取到的数据渲染cell。示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@protocol ZIKNoteListViewEventHandler &lt;NSObject&gt;</div><div class="line">- (void)handleDidSelectRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@protocol ZIKNoteListViewDataSource &lt;NSObject&gt;</div><div class="line">- (NSInteger)numberOfRowsInSection:(NSInteger)section;</div><div class="line">- (NSString *)textOfCellForRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class="line">- (NSString *)detailTextOfCellForRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">@interface ZIKNoteListViewController () &lt;UITableViewDelegate,UITableViewDataSource&gt;</div><div class="line">@property (nonatomic, strong) id&lt;ZIKNoteListViewEventHandler&gt; eventHandler;</div><div class="line">@property (nonatomic, strong) id&lt;ZIKNoteListViewDataSource&gt; viewDataSource;</div><div class="line">@property (weak, nonatomic) IBOutlet UITableView *noteListTableView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKNoteListViewController</div><div class="line"></div><div class="line">- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">                                      text:(NSString *)text</div><div class="line">                                detailText:(NSString *)detailText &#123;</div><div class="line">    UITableViewCell *cell = [self.noteListTableView dequeueReusableCellWithIdentifier:@&quot;noteListCell&quot; forIndexPath:indexPath];</div><div class="line">    cell.textLabel.text = text;</div><div class="line">    cell.detailTextLabel.text = detailText;</div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark UITableViewDataSource</div><div class="line"></div><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class="line">    return [self.viewDataSource numberOfRowsInSection:section];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSString *text = [self.viewDataSource textOfCellForRowAtIndexPath:indexPath];</div><div class="line">    NSString *detailText = [self.viewDataSource detailTextOfCellForRowAtIndexPath:indexPath];</div><div class="line">    UITableViewCell *cell = [self cellForRowAtIndexPath:indexPath</div><div class="line">                                                   text:text</div><div class="line">                                             detailText:detailText];</div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark UITableViewDelegate</div><div class="line"></div><div class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</div><div class="line">    </div><div class="line">    [self.eventHandler handleDidSelectRowAtIndexPath:indexPath];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一般来说，viewDataSource和eventHandler都是由Presenter来担任的，Presenter接收到dataSource请求时，从Interactor里获取并返回对应的数据。你也可以选择在View和Presenter之间用ViewModel来进行交互。</p>
<h3 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h3><p>Presenter由View持有，它的职责有：</p>
<ul>
<li>接收并处理来自View的事件</li>
<li>维护和View相关的各种状态和配置，比如界面是否使用夜间模式等</li>
<li>调用Interactor提供的Use Case执行业务逻辑</li>
<li>向Interactor提供View中的数据，让Interactor生成需要的Model</li>
<li>接收并处理来自Interactor的业务事件回调事件</li>
<li>通知View进行更新操作</li>
<li>通过Wireframe跳转到其他View</li>
</ul>
<p>Presenter是View和业务之间的中转站，它不包含业务实现代码，而是负责调用现成的各种Use Case，将具体事件转化为具体业务。Presenter里不应该导入UIKit，否则就有可能入侵View层的渲染工作。Presenter里也不应该出现Model类，当数据从Interactor传递到Presenter里时，应该转变为简单的数据结构。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@interface ZIKNoteListViewPresenter () &lt;ZIKNoteListViewDataSource, ZIKNoteListViewEventHandler&gt;</div><div class="line">@property (nonatomic, strong) id&lt;ZIKNoteListWireframeProtocol&gt; wireframe;</div><div class="line">@property (nonatomic, weak) id&lt;ZIKViperView,ZIKNoteListViewProtocol&gt; view;</div><div class="line">@property (nonatomic, strong) id&lt;ZIKNoteListInteractorInput&gt; interactor;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKNoteListViewPresenter</div><div class="line"></div><div class="line">#pragma mark ZIKNoteListViewDataSource</div><div class="line"></div><div class="line">- (NSInteger)numberOfRowsInSection:(NSInteger)section &#123;</div><div class="line">    return self.interactor.noteCount;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)textOfCellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSString *title = [self.interactor titleForNoteAtIndex:indexPath.row];</div><div class="line">    return title;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)detailTextOfCellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSString *content = [self.interactor contentForNoteAtIndex:indexPath.row];</div><div class="line">    return content;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark ZIKNoteListViewEventHandler</div><div class="line"></div><div class="line">- (void)handleDidSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSString *uuid = [self.interactor noteUUIDAtIndex:indexPath.row];</div><div class="line">    NSString *title = [self.interactor noteTitleAtIndex:indexPath.row];</div><div class="line">    NSString *content = [self.interactor noteContentAtIndex:indexPath.row];</div><div class="line">    </div><div class="line">    [self.wireframe pushEditorViewForEditingNoteWithUUID:uuid title:title content:content delegate:self];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="Interactor"><a href="#Interactor" class="headerlink" title="Interactor"></a>Interactor</h3><p>Ineractor的职责：</p>
<ul>
<li>实现和封装各种业务的Use Case，供外部调用</li>
<li>维护和业务相关的各种状态，比如是否正在编辑笔记</li>
<li>Interactor可以获取各种Manager和Service，用于组合实现业务逻辑，这些Manager和Service应该是由外部注入的依赖，而不是直接引用具体的类</li>
<li>通过DataManager维护Model</li>
<li>监听各种外部的业务事件并处理，必要时将事件发送给eventHandler</li>
<li>Interactor持有一个由外部注入的eventHandler对象，将需要外部处理的业务事件发送给eventHandler，或者通过eventHandler接口对某些数据操作的过程进行回调</li>
<li>Interactor持有一个由外部注入的dataSource对象，用于获取View上的数据，以更新Model</li>
</ul>
<p>Interactor是业务的实现者和维护者，它会调用各种Service来实现业务逻辑，封装成明确的用例。而这些Service在使用时，也都是基于接口的，因为Interactor的实现不和具体的类绑定，而是由Application注入Interactor需要的Service。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@protocol ZIKNoteListInteractorInput &lt;NSObject&gt;</div><div class="line">- (void)loadAllNotes;</div><div class="line">- (NSInteger)noteCount;</div><div class="line">- (NSString *)titleForNoteAtIndex:(NSUInteger)idx;</div><div class="line">- (NSString *)contentForNoteAtIndex:(NSUInteger)idx;</div><div class="line">- (NSString *)noteUUIDAtIndex:(NSUInteger)idx;</div><div class="line">- (NSString *)noteTitleAtIndex:(NSUInteger)idx;</div><div class="line">- (NSString *)noteContentAtIndex:(NSUInteger)idx;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">@interface ZIKNoteListInteractor : NSObject &lt;ZIKNoteListInteractorInput&gt;</div><div class="line">@property (nonatomic, weak) id dataSource;</div><div class="line">@property (nonatomic, weak) id eventHandler;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKNoteListInteractor</div><div class="line"></div><div class="line">- (void)loadAllNotes &#123;</div><div class="line">    [[ZIKNoteDataManager sharedInsatnce] fetchAllNotesWithCompletion:^(NSArray *notes) &#123;</div><div class="line">        [self.eventHandler didFinishLoadAllNotes];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSArray&lt;ZIKNoteModel *&gt; *)noteList &#123;</div><div class="line">    return [ZIKNoteDataManager sharedInsatnce].noteList;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)noteCount &#123;</div><div class="line">    return self.noteList.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)titleForNoteAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] title];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)contentForNoteAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] content];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)noteUUIDAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] uuid];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)noteTitleAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] title];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)noteContentAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] content];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>向Interactor提供各种封装好的服务，例如数据库的访问、存储，调用定位功能等。Service由Application在执行路由时注入到Builder里，再由Buidler注入到Interactor里。也可以只注入一个Service Router，在运行时再通过这个Service Router懒加载需要的Service，相当于注入了一个提供Router功能的Service。</p>
<p>Service可以看作是没有View的VIPER，也有自己的路由和Builder。</p>
<h3 id="Wireframe"><a href="#Wireframe" class="headerlink" title="Wireframe"></a>Wireframe</h3><p>翻译成中文叫线框，用于表达从一个Module到另一个Module的过程。虽然也是扮演者执行路由的角色，但是其实它和Router是有区别的。</p>
<p>Wireframe和storyboard中连接好的一个个segue类似，负责提供一系列具体的路由用例，这个用例里已经配置好了源界面和目的界面的一些依赖，包括转场动画、模块间传参等。Wireframe的接口是提供给模块内部使用的，它通过调用Router来执行真正的路由操作。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface ZIKTNoteListWireframe : NSObject &lt;ZIKTViperWireframe&gt;</div><div class="line">- (void)presentLoginViewWithMessage:(NSString *)message delegate:(id&lt;ZIKTLoginViewDelegate&gt;)delegate completion:(void (^ __nullable)(void))completion;</div><div class="line">- (void)dismissLoginView:(UIViewController *)viewController animated:(BOOL)animated completion:(void (^ __nullable)(void))completion;</div><div class="line">- (void)presentEditorForCreatingNewNoteWithDelegate:(id&lt;ZIKTEditorDelegate&gt;)delegate completion:(void (^ __nullable)(void))completion;</div><div class="line">- (void)pushEditorViewForEditingNoteWithUUID:(NSString *)uuid title:(NSString *)title content:(NSString *)content delegate:(id&lt;ZIKTEditorDelegate&gt;)delegate;</div><div class="line">- (UIViewController *)editorViewForEditingNoteWithUUID:(NSString *)uuid title:(NSString *)title content:(NSString *)content delegate:(id&lt;ZIKTEditorDelegate&gt;)delegate;</div><div class="line">- (void)pushEditorViewController:(UIViewController *)destination fromViewController:(UIViewController *)source animated:(BOOL)animated;</div><div class="line">- (void)quitEditorViewWithAnimated:(BOOL)animated;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>Router则是由Application提供的具体路由技术，可以简单封装UIKit里的那些跳转方法，也可以用URL Router来执行路由。但是一个模块是不需要知道app使用的是什么具体技术的。Router才是真正连接各个模块的地方。它也负责寻找对应的目的模块，并且通过Buidler进行依赖注入。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@interface ZIKTRouter : NSObject &lt;ZIKTViperRouter&gt;</div><div class="line">///封装UIKit的跳转方法</div><div class="line">+ (void)pushViewController:(UIViewController *)destination fromViewController:(UIViewController *)source animated:(BOOL)animated;</div><div class="line">+ (void)popViewController:(UIViewController *)viewController animated:(BOOL)animated;</div><div class="line">+ (void)presentViewController:(UIViewController *)viewControllerToPresent fromViewController:(UIViewController *)source animated:(BOOL)animated completion:(void (^ __nullable)(void))completion;</div><div class="line">+ (void)dismissViewController:(UIViewController *)viewController animated:(BOOL)animated completion:(void (^ __nullable)(void))completion;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKTRouter (ZIKTEditor)</div><div class="line"></div><div class="line">+ (UIViewController *)viewForCreatingNoteWithDelegate:(id&lt;ZIKTEditorDelegate&gt;)delegate &#123;</div><div class="line">    return [ZIKTEditorBuilder viewForCreatingNoteWithDelegate:delegate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (UIViewController *)viewForEditingNoteWithUUID:(NSString *)uuid title:(NSString *)title content:(NSString *)content delegate:(id&lt;ZIKTEditorDelegate&gt;)delegate &#123;</div><div class="line">    return [ZIKTEditorBuilder viewForEditingNoteWithUUID:uuid title:title content:content delegate:delegate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>由Application实现，负责在模块通信时进行一些接口的转换，例如两个模块使用了相同业务功能的某个Service，使用的protocol实现一样，但是protocol名字不一样，就可以在路由时，在Adapter里进行一次转换。甚至只要定义的逻辑一样，依赖参数的名字和数据类型也可以允许不同。这样就能让模块不依赖于某个具体的protocol，而是依赖于protocol实际定义的依赖和接口。</p>
<p>注意这里的Adapter和Clean Architecture里的<code>Interface Adapter</code>是不一样的。这里的Adapter就是字面意义上的接口转换，而Clean Architecture里的<code>Interface Adapter</code>层更加抽象，是Use Case层与具体实现技术之间的转换，囊括了更多的角色。</p>
<h3 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h3><p>负责初始化整个模块，配置VIPER之间的关系，并对外声明模块需要的依赖，让外部执行注入。</p>
<h2 id="模块间解耦"><a href="#模块间解耦" class="headerlink" title="模块间解耦"></a>模块间解耦</h2><p>一个VIPER模块可以看做是一个独立的组件，可以被单独封装成一个库，被app引用。这时候，app就负责将各个模块连接起来，也就是图中灰色的<code>Application Context</code>部分。一个模块，肯定是存在于一个上下文环境中才能运行起来的。</p>
<p><code>Wireframe</code> -&gt; <code>Router</code> -&gt; <code>Adapter</code> -&gt; <code>Builder</code> 实现了一个完整的模块间路由，并且实现了模块间的解耦。</p>
<p>其中Wireframe和Builder是分别由引用者模块和被引用模块提供的，是两个模块的出口和入口，而Router和Adapter则是由模块的使用者——Application实现的。</p>
<p>当两个模块之间存在引用关系时，说明存在业务逻辑上的耦合，这种耦合是业务的一部分，是不可能消除的。我们能做的就是把耦合尽量交给模块调用者，由Application来提供具体的类，注入到各个模块之中，而模块内部只面向protocol即可。这样的话，被引用模块只要实现了相同的接口，就可以随时替换，甚至接口有一些差异时，只要被引用模块提供了相同功能的接口，也可以通过Adapter来做接口兼容转换，让引用者模块无需做任何修改。</p>
<p>Wireframe相当于插头，Builder相当于插座，而Router和Adapter相当于电路和转接头，将不同规格的插座和插头连接起来。把这些连接和适配的工作交给Application层，就能让两个模块实现各自独立。</p>
<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p>大部分方案都没有讨论子模块存在的情况。在VIPER里如何引入另一个VIPER模块？多个模块之间如何交互？子模块由谁初始化、由谁管理？</p>
<p>其他几个实现中，只有Uber较为详细地讨论了子模块的问题。在Uber的Riblets架构里，子模块的Router被添加到父模块的Router，模块之间通过delegate和监听的方式进行通信。这样做会让模块间产生一定的耦合。如果子模块是由于父View使用了一个子View控件而被引入的，那么父Interactor就会在代码里多出一个子Interactor，这样就导致了View的实现方式影响了Interactor的实现。</p>
<h3 id="子模块的来源"><a href="#子模块的来源" class="headerlink" title="子模块的来源"></a>子模块的来源</h3><p>子模块的来源有：</p>
<ul>
<li>View引用了一个封装好的子View控件，连带着引入了子View的整个VIPER</li>
<li>Interactor使用了一个Service</li>
</ul>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><p>子View可能是一个UIView，也可能是一个Child UIViewController。因此子View有可能需要向外部请求数据，也可能独立完成所有任务，不需要依赖父模块。</p>
<p>如果子View可以独立，那在子模块里不会出现和父模块交互的逻辑，只有把一些事件通过Output传递出去的接口。这时只需要把子View的接口封装在父View的接口里即可，父Presenter和父Interactor是不知道父View提供的这几个接口是通过子View实现的。这样父模块就能接收到子模块的事件了，而且能够保持Interactor和Presenter、View之间从低到高的依赖关系。</p>
<p>如果父模块需要调用子模块的某些功能，或者从子模块获取数据，可以选择封装到父View的接口里，不过如果涉及到数据模型，并且不想让数据模型出现在View的接口中，可以把子Interactor作为父Interactor的一个Service，在引入子模块时，通过父Builder注入到父Interactor里，或者根据依赖关系解耦地再彻底一点，注入到父Presenter里，让父Presenter再把接口转发给父Interactor。这样子模块和父模块就能通过Service的形式进行通信了，而这时，父Interactor也不知道这个Service是来自子模块里的。</p>
<p>在这样的设计下，子模块和父模块是不知道彼此的存在的，只是通过接口进行交互。好处是父View如果想要更换为另一个相同功能的子View控件，就只需要在父View里修改，不会影响Presenter和Interactor。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>这个VIPER的设计是通过接口将各个部分组合在一起的，一个类需要设置很多依赖，例如Interactor需要依赖许多Service。这就涉及到了两个问题：</p>
<ul>
<li>在哪里配置依赖</li>
<li>一个类怎么声明自己的依赖</li>
</ul>
<p>在这个方案中，由Builder声明整个模块的依赖，然后在Builder内部为不同的类设置依赖，外部在注入依赖时，就不必知道内部是怎么使用这些依赖参数的。一个类如果有必需的依赖参数，可以直接在init方法里体现，对于那些非必需的依赖，可以通过暴露接口来声明。</p>
<p>如果需要动态注入，而不是在模块初始化时就配置所有的依赖，Builder也可以提供动态注入的接口。</p>
<h2 id="映射到MVC"><a href="#映射到MVC" class="headerlink" title="映射到MVC"></a>映射到MVC</h2><p>如果你需要把一个模块从MVC重构到VIPER，可以先按照这个步骤：</p>
<ul>
<li>整理Controller中的代码，把不同职责的代码用pragma mark分隔好</li>
<li>整理好后，按照各部分的职责，将代码分散到VIPER的各个角色中，此时View、Presenter、Interactor之间可以直接互相引用</li>
<li>把View、Presenter、Interactor进行解耦，抽出接口，互相之间依赖接口进行交互</li>
</ul>
<p>下面就是第一步里在Controller中可以分隔出的职责：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">//------View-------</div><div class="line"></div><div class="line">//View的生命周期</div><div class="line">#pragma mark View life</div><div class="line"></div><div class="line">//View的配置，包括布局设置</div><div class="line">#pragma mark View config</div><div class="line"></div><div class="line">//更新View的接口</div><div class="line">#pragma mark Update view</div><div class="line"></div><div class="line">//View需要从model中获取的数据</div><div class="line">#pragma mark Request view data source</div><div class="line"></div><div class="line">//监控、接收View的事件</div><div class="line">#pragma mark Send view event</div><div class="line"></div><div class="line">//------Presenter-------</div><div class="line"></div><div class="line">//处理View的事件</div><div class="line">#pragma mark Handle view event</div><div class="line"></div><div class="line">//界面跳转</div><div class="line">#pragma mark Wireframe</div><div class="line"></div><div class="line">//向View提供配置用的数据</div><div class="line">#pragma mark Provide view data source</div><div class="line"></div><div class="line">//提供生成model需要的数据</div><div class="line">#pragma mark Provide model data source</div><div class="line"></div><div class="line">//处理业务事件，调用业务用例</div><div class="line">#pragma mark Handle business event</div><div class="line"></div><div class="line">//------Interactor-------</div><div class="line"></div><div class="line">//监控、接收业务事件</div><div class="line">#pragma mark Send business event</div><div class="line"></div><div class="line">//业务用例</div><div class="line">#pragma mark Business use case</div><div class="line"></div><div class="line">//获取生成model需要的数据</div><div class="line">#pragma mark Request data for model</div><div class="line"></div><div class="line">//维护model</div><div class="line">#pragma mark Manage model</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里缺少了View状态管理、业务状态管理等职责，因为这些状态一般都是@property，用pragma mark不能分隔它们，只能在@interface里声明的时候进行隔离。</p>
<h2 id="方案二：允许适当耦合"><a href="#方案二：允许适当耦合" class="headerlink" title="方案二：允许适当耦合"></a>方案二：允许适当耦合</h2><p>上面的方案是以最彻底的解耦为目标设计的，在实践中，如果真的完全按照这个设计，代码量的确不小。其实一些地方的耦合并不会引起多大问题，除非你的模块需要封装成通用组件供多个app使用，否则并不需要按照100%的解耦要求来编写。因此接下来我再总结一个稍微简化的方案，总结一下各部分可以在哪些地方出现耦合，哪些耦合不能出现。</p>
<p>在这个方案里，我使用了一个中介者来减少一部分代码，Router就是一个很适合成为中介者的角色。</p>
<p>架构图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-2a5e4eaf6275caba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="final_viper"></p>
<h3 id="View-1"><a href="#View-1" class="headerlink" title="View"></a>View</h3><ul>
<li>View可以直接通过Router引入另一个子View，不需要通过Presenter的路由来引入</li>
<li>View中的一些delegate如果变化的可能性不大，可以直接让Presenter实现（例如<code>UITableViewDataSource</code>），不用再封装一遍后交给Presenter</li>
<li>View不能出现Model类</li>
</ul>
<h3 id="Presenter-1"><a href="#Presenter-1" class="headerlink" title="Presenter"></a>Presenter</h3><ul>
<li>Presenter可以直接调用Router执行路由，不用再通过Wireframe封装一遍</li>
<li>Presenter的接口参数中可以出现Model类，但是不能导入Model类的头文件并且使用Model类，只能用于参数传递</li>
<li>Presenter中不建议导入UIKit，除非能保证不会使用那些会影响控件渲染的方法</li>
</ul>
<h3 id="Interactor-1"><a href="#Interactor-1" class="headerlink" title="Interactor"></a>Interactor</h3><ul>
<li>一些app中常用的Service可以直接引入，不需要通过外部注入的方式来使用</li>
<li>Interactor可以用一个Service Router来动态获取Service</li>
</ul>
<h3 id="路由和依赖注入"><a href="#路由和依赖注入" class="headerlink" title="路由和依赖注入"></a>路由和依赖注入</h3><p>改变得最多的就是路由部分。View、Presenter和Interactor都可以使用路由来获取一些模块。View可以通过路由获取子View，Presenter可以通过路由获取其他View模块，Interactor可以通过路由获取Service。</p>
<p>在实现时，可以把Wireframe、Router、Builder整合到一起，全都放到Router里，Router由模块实现并提供给外部使用。类似于Brigade团队和Rambler&amp;Co团队的实现。但是他们的实现都是直接在Router里引入其他模块的Router，这样会导致依赖混乱，更好的方式是通过一个中间人统一提供其他模块的接口。</p>
<p>我在这里造了个轮子，通过protocol来寻找需要的模块并执行路由，不用直接导入目的模块中的类，并且提供了Adapter的支持，可以让多个protocol指向同一个模块。这样就能避免模块间的直接依赖。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">///editor模块的依赖声明</div><div class="line">@protocol NoteEditorProtocol &lt;NSObject&gt;</div><div class="line">@property (nonatomic, weak) id&lt;ZIKEditorDelegate&gt; delegate;</div><div class="line">- (void)constructForCreatingNewNote;</div><div class="line">- (void)constructForEditingNote:(ZIKNoteModel *)note;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKNoteListViewPresenter</div><div class="line"></div><div class="line">- (void)handleDidSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSAssert([[self.view routeSource] isKindOfClass:[UIViewController class]], nil);</div><div class="line">    </div><div class="line">    //跳转到编辑器界面；通过protocol获取对应的router类，再通过protocol注入依赖</div><div class="line">    //App可以用Adapter把NoteEditorProtocol和真正的protocol进行匹配和转接</div><div class="line">    [ZIKViewRouterToModule(NoteEditorProtocol)</div><div class="line">true     performWithConfigure:^(ZIKViewRouteConfiguration&lt;NoteEditorProtocol&gt; *config) &#123;</div><div class="line">true         //路由配置</div><div class="line">true         //跳转的源界面</div><div class="line">true         config.source = [self.view routeSource];</div><div class="line">true         //设置跳转方式，支持所有界面跳转类型</div><div class="line">true         config.routeType = ZIKViewRouteTypePush;</div><div class="line">true         //Router内部负责用获取到的参数初始化editor模块</div><div class="line">true         config.delegate = self;</div><div class="line">true         [config constructForEditingNote:[self.interactor noteAtIndex:indexPath.row]];</div><div class="line">true         config.prepareForRoute = ^(id destination) &#123;</div><div class="line">true             //跳转前配置目的界面</div><div class="line">true         &#125;;</div><div class="line">true         config.routeCompletion = ^(id destination) &#123;</div><div class="line">true             //跳转结束处理</div><div class="line">true         &#125;;</div><div class="line">true         config.performerErrorHandler = ^(SEL routeAction, NSError * error) &#123;</div><div class="line">true             //跳转失败处理</div><div class="line">true         &#125;;</div><div class="line">true     &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这个方案依赖于一个统一的中间人，也就是路由工具，在我的实现里就是<a href="https://github.com/Zuikyo/ZIKRouter" target="_blank" rel="external">ZIKRouter</a>。View、Presenter、Interactor都可以使用对应功能的Router获取子模块。而由于ZIKRouter仍然是通过protocol的方式来和子模块进行交互，因此仍然可保持模块间解耦。唯一的耦合就是各部分都引用了ZIKRouter这个工具。如果你想把模块和ZIKRouter的耦合也去除，可以让Router也变成面向接口，由外部注入。</p>
<h2 id="Demo和代码模板"><a href="#Demo和代码模板" class="headerlink" title="Demo和代码模板"></a>Demo和代码模板</h2><p>针对两个方案，同时写了两个相同功能的Demo，可以比较一下代码上的区别。地址在：<a href="https://github.com/Zuikyo/ZIKViper" target="_blank" rel="external">ZIKViper</a></p>
<p>项目里也提供了Xcode File Template用于快速生成VIPER代码模板。把<code>.xctemplate</code>后缀的文件夹拷贝到<code>~/Library/Developer/Xcode/Templates/</code>目录下，就可以在Xcode的<code>New-&gt;File-&gt;Template</code>里选择代码模板快速生成代码。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>VIPER是按照Clean Architecture中由外向内的依赖进行设计的，各部分职责十分明确。并且由于引入了路由部分，更容易支持组件化开发。</p>
<p>下一篇文章将讨论基于接口的路由设计，总结UIKit中的各种视图转场，并讲解ZIKRouter的实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework" target="_blank" rel="external">MEET VIPER: MUTUAL MOBILE’S APPLICATION OF CLEAN ARCHITECTURE FOR IOS APPS</a></li>
<li><a href="https://www.objc.io/issues/13-architecture/viper/" target="_blank" rel="external">Architecting iOS Apps with VIPER</a></li>
<li><a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">Clean Architecture</a></li>
<li><a href="https://brigade.engineering/brigades-experience-using-an-mvc-alternative-36ef1601a41f" target="_blank" rel="external">Brigade’s Experience Using an MVC Alternative: VIPER architecture for iOS applications</a></li>
<li><a href="https://swifting.io/blog/2016/03/07/8-viper-to-be-or-not-to-be/" target="_blank" rel="external">VIPER to be or not to be?</a></li>
<li><a href="https://cheesecakelabs.com/blog/best-practices-viper-architecture/" target="_blank" rel="external">VIPER architecture: Our best practices to build an app like a boss</a></li>
<li><a href="https://github.com/strongself/The-Book-of-VIPER" target="_blank" rel="external">The-Book-of-VIPER</a></li>
<li><a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="external">ENGINEERING THE ARCHITECTURE BEHIND UBER’S NEW RIDER APP</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一篇文章对VIPER进行了简单的介绍，这篇文章将从VIPER的源头开始，比较现有的几种VIPER实现，对VIPER进行进一步的职责剖析，并对各种细节实现问题进行挖掘和探讨。最后给出两个完整的VIPER实现，并且提供快速生成VIPER代码的模板。&lt;/p&gt;
&lt;p&gt;Demo和轮
    
    </summary>
    
      <category term="代码架构" scheme="http://zuikyo.github.io/categories/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS VIPER架构实践(一)：从MVC到MVVM到VIPER</title>
    <link href="http://zuikyo.github.io/2017/07/21/iOS%20VIPER%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5(%E4%B8%80)%EF%BC%9A%E4%BB%8EMVC%E5%88%B0MVVM%E5%88%B0VIPER/"/>
    <id>http://zuikyo.github.io/2017/07/21/iOS VIPER架构实践(一)：从MVC到MVVM到VIPER/</id>
    <published>2017-07-21T12:58:29.000Z</published>
    <updated>2017-09-27T15:36:01.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近半年在写app的时候，研究了一下各种iOS代码架构，最后选择了VIPER进行实践，在此对实践中遇到的各种设计问题做一番总结，并分享造出的轮子。</p>
<p>对代码风格和架构有兴趣的同学，肯定都已经在很多地方见过各种架构的介绍。MVC、MVP、MVVM、VIPER，细分程度逐渐上升。这些架构设计都是来自MVC，只是各自用不同的方式对MVC进行了细分，在此只对MVC、MVP和MVVM作精简介绍，想要详细了解可以参考这些文章：</p>
<p><a href="http://ios.jobbole.com/83727/" target="_blank" rel="external">iOS 架构模式–解密 MVC，MVP，MVVM以及VIPER架构</a>,</p>
<p><a href="http://draveness.me/mvx.html" target="_blank" rel="external">浅谈 MVC、MVP 和 MVVM 架构模式</a>。</p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p><code>Model-View-Controller</code>。MVC简单地将一个模块分为3部分：</p>
<ul>
<li>View是展示给外部的界面</li>
<li>Model是Controller内部管理的数据模型</li>
<li>Controller负责将Model的变化更新到View</li>
<li>Controller负责处理来自View的事件</li>
</ul>
<p>MVC的划分粒度很粗，因此有很多种具体实现，各个实现有差异，因此并没有一个十分明确的标准定义。</p>
<h2 id="苹果的MVC"><a href="#苹果的MVC" class="headerlink" title="苹果的MVC"></a>苹果的MVC</h2><p>苹果的Cocoa Touch就遵照了MVC的设计，一个界面分为UIView和UIViewController，UIView负责渲染和接收触摸事件，UIViewController负责子view之间的布局、组合、更新以及事件处理。</p>
<p>尽管苹果已经给我们提供了简单的MVC支持，但是在实践中我们却常常没有遵守MVC。原因在于Cocoa Touch中的Model部分是由我们自己负责管理的，并没有提供原生的设计支持。所以有时候会出现这样的情况：一个UIView为了方便，提供了一个从某个model进行配置的方法。乍一看十分合理，但是仔细想想就会发现，这么做已经将View和Model耦合，不符合苹果官方的MVC规范(<a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1" target="_blank" rel="external">The Role of View Controllers</a>)。</p>
<p>另外，UIViewController存在的一些问题，导致了它很容易变得臃肿和耦合。</p>
<p>首先，UIViewController和UIView耦合得十分紧密，导致UIViewController经常和某些具体的UIView耦合，几乎无法重用。而且在测试的时候，很难做到单独测试没有View的那部分代码，因为在写的时候就很容易将View的逻辑入侵到各处，Controller会受到View的状态的影响，无法稳定测试。因此，应该尽量把和View无关的代码放到UIViewController之外。</p>
<p>第二，UIViewController负责了界面跳转的操作，界面跳转的相关配置是直接在对应的UIViewController实例上设置的，这样就很容易把源界面和目的界面耦合起来，简单地把界面跳转的部分单独抽离为一个封装好的跳转方法可以一定程度上减少这部分耦合，但也不可避免地会多写许多代码。</p>
<p>因此，苹果的MVC，实际上是<code>Model-View-ViewController</code>。它是一个视图驱动的设计，Controller只是为了管理View而存在的。苹果把UIViewController和Model的关系设计交给了我们自己。所以，如何把一个UIViewController进行更明确的分工，就是这些架构要做的事。</p>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p><code>Model-View-Presenter</code>用一个Presenter，把Controller中View的部分剔除，实现了View和Model的隔绝。各部分分工如下：</p>
<ul>
<li>View负责界面展示和布局管理，向Presenter暴露视图更新和数据获取的接口</li>
<li>Presenter负责接收来自View的事件，通过View提供的接口更新视图，并管理Model</li>
<li>Model和MVC中的一样，提供数据模型</li>
</ul>
<p>在iOS里，UIView和UIViewController共同组合成了MVP中的View。UIView负责元素的展示，UIViewController负责界面布局和组合，并把事件转发给Presenter。<br>因此在MVP里，业务逻辑被放到了Presenter中，由它负责协调View和Model。而由于View的抽离，Presenter的状态是可控的，在测试时更不容易受外部影响。</p>
<p>在iOS中使用MVP很简单，在View和Presenter之间用protocol做好事件传递就可以。缺点就是多了一层用于隔离的接口，会导致代码数量增大。</p>
<p>但是随着界面越来越复杂，Presenter中的业务代码也会越来越庞大，总有一天会遇到一个新的问题：如何再细分Presenter。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><code>Model-View-ViewModel-Controller</code>模式，它也和MVP一样，目的是解决View和Model的耦合。各部分分工如下：</p>
<ul>
<li>Model提供数据模型</li>
<li>View负责视图展示</li>
<li>ViewModel用于描述View的状态，例如View的颜色、显示的文字等属性类的信息，将View抽象成了一个特殊的模型</li>
<li>Controller(Presenter)通过修改ViewModel来更新View，并且负责事件处理，维护Model</li>
</ul>
<p>在MVP中，View通过接口的方式来描述自己，在MVVM中，则通过ViewModel来描述自己的特征。那么ViewModel如何将自己的变化更新到View上呢？MVVM经常和数据绑定一起出现，在Controller中，将View和ViewModel的属性用类似KVO的方式进行绑定，这样ViewModel的变化就能立即传输到View上。注意，这里的Controller不是UIViewController，而是负责模块业务逻辑的一个角色，类似于Presenter。</p>
<p>但是数据绑定的缺点也很明显：调试困难，数据来源难以回溯，在线上出bug的时候就很难追踪了。</p>
<p>其实数据绑定只是一种为了减少胶水代码的技术实现方式，MVVM的设计并没有要求必须要使用数据绑定，你也完全可以使用protocol的方式来将ViewModel的变化传递给View，让数据流向更清晰。MVVM的关键是将View进行了抽象，并且这个抽象很容易在其他Controller中复用。</p>
<p>Controller在绑定完View和ViewModel之后，就不应该在其他地方使用View了。你也可以单独用一个ViewModelManager来负责设置ViewModel和View之间的数据传递。而其他的业务代码，还是放在Controller中，ViewModel应该只负责管理View相关的状态、传递View的事件，不应该存在本属于Controller中的其他业务。当然如果你不打算重用这个ViewModel的话，也可以在ViewModel里加入一些和Model相关的业务逻辑，维护Model，只不过基于单一职责原则，这么做是不好的。</p>
<p>和MVP相比，MVVM用了一种更优雅的方式来抽象View。但它和MVP其实是类似的，仍然没有对Controller进行进一步的细分。</p>
<p>那么如何对Controller进行进一步的职责细分呢？答案就是VIPER。</p>
<h2 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h2><p>VIPER的全称是<code>View-Interactor-Presenter-Entity-Router</code>。示意图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-580872920986b640.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VIPER"></p>
<p>相比之前的MVX架构，VIPER多出了两个东西：Interactor（交互器）和Router（路由）。</p>
<p>各部分职责如下：</p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><ul>
<li>提供完整的视图，负责视图的组合、布局、更新</li>
<li>向Presenter提供更新视图的接口</li>
<li>将View相关的事件发送给Presenter</li>
</ul>
<h3 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h3><ul>
<li>接收并处理来自View的事件</li>
<li>向Interactor请求调用业务逻辑</li>
<li>向Interactor提供View中的数据</li>
<li>接收并处理来自Interactor的数据回调事件</li>
<li>通知View进行更新操作</li>
<li>通过Router跳转到其他View</li>
</ul>
<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><ul>
<li>提供View之间的跳转功能，减少了模块间的耦合</li>
<li>初始化VIPER的各个模块</li>
</ul>
<h3 id="Interactor"><a href="#Interactor" class="headerlink" title="Interactor"></a>Interactor</h3><ul>
<li>维护主要的业务逻辑功能，向Presenter提供现有的业务用例</li>
<li>维护、获取、更新Entity</li>
<li>当有业务相关的事件发生时，处理事件，并通知Presenter</li>
</ul>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><ul>
<li>和Model一样的数据模型</li>
</ul>
<h3 id="和MVX的区别"><a href="#和MVX的区别" class="headerlink" title="和MVX的区别"></a>和MVX的区别</h3><p>VIPER把MVC中的Controller进一步拆分成了Presenter、Router和Interactor。和MVP中负责业务逻辑的Presenter不同，VIPER的Presenter的主要工作是在View和Interactor之间传递事件，并管理一些View的展示逻辑，主要的业务逻辑实现代码都放在了Interactor里。Interactor的设计里提出了”用例”的概念，也就是把每一个会出现的业务流程封装好，这样可测试性会大大提高。而Router则进一步解决了不同模块之间的耦合。所以，VIPER和上面几个MVX相比，多总结出了几个需要维护的东西：</p>
<ul>
<li>View事件管理</li>
<li>数据事件管理</li>
<li>事件和业务的转化</li>
<li>总结每个业务用例</li>
<li>模块内分层隔离</li>
<li>模块间通信</li>
</ul>
<p>而这里面，还可以进一步细分一些职责。VIPER实际上已经把Controller的概念淡化了，这拆分出来的几个部分，都有很明确的单一职责，有些部分之间是完全隔绝的，在开发时就应该清晰地区分它们各自的职责，而不是将它们视为一个Controller。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>VIPER的特色就是职责明确，粒度细，隔离关系明确，这样能带来很多优点：</p>
<ul>
<li>可测试性好。UI测试和业务逻辑测试可以各自单独进行。</li>
<li>易于迭代。各部分遵循单一职责，可以很明确地知道新的代码应该放在哪里。</li>
<li>隔离程度高，耦合程度低。一个模块的代码不容易影响到另一个模块。</li>
<li>易于团队合作。各部分分工明确，团队合作时易于统一代码风格，可以快速接手别人的代码。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>一个模块内的类数量增大，代码量增大，在层与层之间需要花更多时间设计接口。</li>
</ul>
<p>使用代码模板来自动生成文件和模板代码可以减少很多重复劳动，而花费时间设计和编写接口是减少耦合的路上不可避免的，你也可以使用数据绑定这样的技术来减少一些传递的层次。</p>
<ul>
<li>模块的初始化较为复杂，打开一个新的界面需要生成View、Presenter、Interactor，并且设置互相之间的依赖关系。而iOS中缺少这种设置复杂初始化的原生方式。</li>
</ul>
<p>简单来说，就是Cocoa框架缺少一个强大的自定义依赖注入工具。这个问题影响不是特别大，可以选用一些第三方工具来实现，也可以在Router的界面跳转方法里，对模块进行初始化，只不过总是不够完美。针对这个问题，我实现了一个基于protocol声明依赖的界面跳转Router，将会在之后的文章中进行详解。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有人可能会觉得，一个界面模块真的有必要使用这么复杂的架构吗？这样是不是过度设计？</p>
<p>我反对这种观点。不要被VIPER的组织图吓到，VIPER并不复杂，它是将原来MVC中的Controller中的各种任务进行了清晰的分解，在写代码时，你会很清楚你正在做什么。事实上，它比使用了数据绑定技术的MVVM更加简单，就是因为它职责明确。从MVC转到VIPER的过程同样是很清晰的，它甚至把重构的思路都体现出来了。而MVVM则留下了许多尚未明确的责任，导致不同的人会在某些地方有不同的实现。即便你还在使用MVC，你也应该在Controller中分离出VIPER总结出的那些专项职责，既然如此，为何不彻底地明确这些职责，把它们分散到不同的文件中呢？一旦开始这样的工作，你就已经向VIPER靠拢了。</p>
<p>有人可能会觉得，VIPER适合大型app，中小型app没必要过早使用。</p>
<p>我反对这种观点。VIPER是单个界面模块内的架构设计，并不是整个app架构层面的设计，和app的整体架构没有多大的关系，也不存在过早使用VIPER的情况。你是愿意1天开发，3天修bug，还是更愿意1.5天开发，1天修bug呢？</p>
<p>至此，我的结论就是，快点拥抱VIPER的怀抱吧。</p>
<h3 id="开始实践"><a href="#开始实践" class="headerlink" title="开始实践"></a>开始实践</h3><p>VIPER是2013年首次在iOS平台上提出的设计，十分年轻，因此缺少大量参与者，以总结出更多最佳实践。下一篇文章将会从VIPER的源头开始，比较现有的各种VIPER实现，总结出一个我认为较好的实施方案。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://ios.jobbole.com/83727/" target="_blank" rel="external">iOS 架构模式–解密 MVC，MVP，MVVM以及VIPER架构</a></li>
<li><a href="http://draveness.me/mvx.html" target="_blank" rel="external">浅谈 MVC、MVP 和 MVVM 架构模式</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近半年在写app的时候，研究了一下各种iOS代码架构，最后选择了VIPER进行实践，在此对实践中遇到的各种设计问题做一番总结，并分享造出的
    
    </summary>
    
      <category term="代码架构" scheme="http://zuikyo.github.io/categories/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>CFRunloop的多线程隐患</title>
    <link href="http://zuikyo.github.io/2017/05/22/CFRunloop%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9A%90%E6%82%A3/"/>
    <id>http://zuikyo.github.io/2017/05/22/CFRunloop的多线程隐患/</id>
    <published>2017-05-22T08:29:29.000Z</published>
    <updated>2017-08-13T07:25:24.120Z</updated>
    
    <content type="html"><![CDATA[<p>如果你还不了解什么是runloop，可以看这里的详解<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>。</p>
<p>苹果<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW26" target="_blank" rel="external">官方文档</a>中，声明了CFRunloop是线程安全的：</p>
<blockquote>
<p>Thread safety varies depending on which API you are using to manipulate your run loop. The functions in Core Foundation are <strong><em>generally</em></strong> thread-safe and can be called from any thread. If you are performing operations that alter the configuration of the run loop, however, it is still good practice to do so from the thread that owns the run loop whenever possible.</p>
</blockquote>
<p>但是需要注意的是，狡猾的苹果使用了<code>generally</code>这个模糊的词。</p>
<p>从实践中来看，CFRunloop在停止runloop的阶段的某些操作是存在多线程隐患的。</p>
<h2 id="不安全的CFRunloopSource"><a href="#不安全的CFRunloopSource" class="headerlink" title="不安全的CFRunloopSource"></a>不安全的CFRunloopSource</h2><p>CFRunloop是线程安全的，但是加上CFRunloopSource就不一定了。比如CFSocket。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>看这样一段自定义线程的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">@interface MyThread()</div><div class="line">@property (nonatomic, strong) NSThread *currentThread;</div><div class="line">@property (nonatomic, assign) CFRunLoopSourceRef socketSource;</div><div class="line">@property (nonatomic, assign) CFSocketRef socket;</div><div class="line">@property (nonatomic, assign) CFRunLoopRef currentRunloop;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyThread</div><div class="line"></div><div class="line">//初始化线程</div><div class="line">- (instancetype)init &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        _currentThread = [[NSThread alloc] initWithTarget:self selector:@selector(runThread) object:nil];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//开启线程；此方法在使用时没有多线程调用</div><div class="line">- (void)startThread &#123;</div><div class="line">    [self.currentThread start];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//线程入口</div><div class="line">- (void)runThread &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">    //返回runloop，可以让其他线程停止此线程</div><div class="line">        self.currentRunloop = CFRunLoopGetCurrent();</div><div class="line">        [self addSocketSource];</div><div class="line">        </div><div class="line">        CFRunLoopRun();</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;线程退出&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//此方法在使用时没有多线程调用</div><div class="line">- (void)stopThread &#123;</div><div class="line">true [self removeSocketSource];</div><div class="line">true @synchronized (_currentRunloop) &#123;</div><div class="line">        if (_currentRunloop) &#123;</div><div class="line">true        CFRunLoopStop(_currentRunloop);</div><div class="line">true        self.currentRunloop = NULL;</div><div class="line">true    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//此方法在使用时没有多线程调用</div><div class="line">- (void)addSocketSource &#123;</div><div class="line">    int sock;</div><div class="line">    sock = socket(AF_INET6, SOCK_STREAM, 0);</div><div class="line">    CFSocketContext context = &#123;0, (__bridge void *)(self), NULL, NULL, NULL&#125;;</div><div class="line">    self.socket = CFSocketCreateWithNative(NULL, sock, kCFSocketReadCallBack, socketCallBack, &amp;context);</div><div class="line">    self.socketSource = CFSocketCreateRunLoopSource(NULL, self.socket, 0);</div><div class="line">    CFRunLoopAddSource(_currentRunloop, _socketSource, kCFRunLoopDefaultMode);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeSocketSource &#123;</div><div class="line">true@synchronized (_socket) &#123;</div><div class="line">truetrueif (_socket) &#123;</div><div class="line">truetruetrue//CFSocketInvalidate可能被抛到另一个线程去执行，因此 CFSocketInvalidate 和 CFRunLoopStop可能有多线程同时调用的情况       </div><div class="line">true        CFSocketInvalidate(_socket);</div><div class="line">true        CFRelease(_socket);</div><div class="line">true        self.socket = NULL;</div><div class="line">true    &#125;</div><div class="line">true&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实践中，CFSocket是被另一个socket类管理的，所以<code>addSocketSource</code>和<code>removeSocketSource</code>都是在另一个类中的，也就有可能出现<code>CFSocketInvalidate</code>和 <code>CFRunLoopStop</code>多线程同时调用的情况。</p>
<h3 id="crash实例分析"><a href="#crash实例分析" class="headerlink" title="crash实例分析"></a>crash实例分析</h3><p>看上去并没有什么问题，该加锁的地方都加锁了，而且CF开头的那几个方法都是线程安全的。但是这时候，如果出现<code>CFSocketInvalidate</code>和 <code>CFRunLoopStop</code>多线程同时调用的情况，就有crash的可能。例如我们项目里收到的某个crash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</div><div class="line">Thread 0 Crashed:</div><div class="line">0   CoreFoundation                  0x000000018e6a9144 CFRunLoopWakeUp + 92</div><div class="line">1   CoreFoundation                  0x000000018e6a9140 CFRunLoopWakeUp + 88</div><div class="line">2   CoreFoundation                  0x000000018e6d71e8 CFSocketInvalidate + 712</div><div class="line">3   MyApp                           0x00000001000fe424 (-[MySocket stop] + 136)</div><div class="line">4   MyApp                           0x00000001000fcd50 (-[MySocket dealloc] + 56)</div><div class="line">5   libsystem_blocks.dylib          0x000000018d6afa28 _Block_release + 144</div><div class="line">6   libdispatch.dylib               0x000000018d65a1bc _dispatch_client_callout + 16</div><div class="line">7   libdispatch.dylib               0x000000018d65ed68 _dispatch_main_queue_callback_4CF + 1000</div><div class="line">8   CoreFoundation                  0x000000018e77e810 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 12</div><div class="line">9   CoreFoundation                  0x000000018e77c3fc __CFRunLoopRun + 1660</div><div class="line">10  CoreFoundation                  0x000000018e6aa2b8 CFRunLoopRunSpecific + 444</div><div class="line">11  GraphicsServices                0x000000019015e198 GSEventRunModal + 180</div><div class="line">12  UIKit                           0x00000001946f17fc -[UIApplication _run] + 684</div><div class="line">13  UIKit                           0x00000001946ec534 UIApplicationMain + 208</div><div class="line">14  DuoYiIM                         0x000000010003ca58 0x100024000 + 100952 (main + 132)</div><div class="line">15  libdyld.dylib                   0x000000018d68d5b8 start + 4</div><div class="line"></div><div class="line">Thread 0 crashed with ARM-64 Thread State:</div><div class="line">  cpsr: 0x0000000020000000     fp: 0x000000016fddab30     lr: 0x000000018e6a9140     pc: 0x000000018e6a9144 </div><div class="line">    sp: 0x000000016fddaa00     x0: 0x0000000000000000     x1: 0x0000000000000000    x10: 0x0000000000000000 </div><div class="line">   x11: 0x0000000000000000    x12: 0x0000000000000000    x13: 0x0000000000000000    x14: 0x0000000000000000 </div><div class="line">   x15: 0x0000000000001203    x16: 0x000000000000012d    x17: 0x000000018f1eef74    x18: 0x0000000000000000 </div><div class="line">   x19: 0x000000017056cb50     x2: 0x0000000000001000    x20: 0x000000017056cb40    x21: 0x96e73914144e0055 </div><div class="line">   x22: 0x0000000174452990    x23: 0x000000017048bae0    x24: 0x0000000000000000    x25: 0x00000000ffffffff </div><div class="line">   x26: 0xffffffffffffffff    x27: 0x000000017426f1c0    x28: 0x0000000002ffffff    x29: 0x000000016fddab30 </div><div class="line">    x3: 0x000000000017e4a6     x4: 0x0000000000012068     x5: 0x0000000000000000     x6: 0x0000000000000036 </div><div class="line">    x7: 0xffffffffffffffec     x8: 0x8c8c8c8c8c8c8c8c     x9: 0x000000000000000c</div></pre></td></tr></table></figure>
<p><code>CFSocketInvalidate</code>在主线程被调用了。看堆栈，在<code>CFSocketInvalidate</code>内部调用<code>CFRunLoopWakeUp</code>时，出现了crash。</p>
<p>看不出具体是什么原因crash，所以需要看看是在<code>CFRunLoopWakeUp</code>的哪里挂的。查看对应版本的<code>CoreFoundation</code>的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">_CFRunLoopWakeUp:</div><div class="line">0x0000000181521b9c FF0305D1               sub        sp, sp, #0x140             ; CODE XREF=_CFRunLoopAddTimer+696, _CFRunLoopTimerSetNextFireDate+592, _CFSocketInvalidate+708, __wakeUpRunLoop+276, __CFXRegistrationPost+344, -[CFPrefsSearchListSource asynchronouslyNotifyOfChangesFromDictionary:toDictionary:]+172, ___CFSocketPerformV0+1408, ___CFSocketManager+2004, ___CFSocketManager+4248, _boundPairRead+604, _boundPairReadClose+124, …</div><div class="line">0x0000000181521ba0 FC6F11A9               stp        x28, x27, [sp, #0x110]</div><div class="line">0x0000000181521ba4 F44F12A9               stp        x20, x19, [sp, #0x120]</div><div class="line">0x0000000181521ba8 FD7B13A9               stp        x29, x30, [sp, #0x130]</div><div class="line">0x0000000181521bac FDC30491               add        x29, sp, #0x130</div><div class="line">0x0000000181521bb0 F40300AA               mov        x20, x0</div><div class="line">0x0000000181521bb4 C80C10F0               adrp       x8, #0x1a16bc000</div><div class="line">0x0000000181521bb8 084140F9               ldr        x8, [x8, #0x80]            ; -[_CFXPreferences init]_1a16bc080</div><div class="line">0x0000000181521bbc 080140F9               ldr        x8, [x8]</div><div class="line">0x0000000181521bc0 292013F0               adrp       x9, #0x1a7928000</div><div class="line">0x0000000181521bc4 29E90791               add        x9, x9, #0x1fa             ; ___CF120290</div><div class="line">0x0000000181521bc8 A8831DF8               stur       x8, [x29, #-0x28]</div><div class="line">0x0000000181521bcc E8030032               orr        w8, wzr, #0x1</div><div class="line">0x0000000181521bd0 28010039               strb       w8, [x9]                   ; ___CF120290</div><div class="line">0x0000000181521bd4 E8731290               adrp       x8, #0x1a639d000</div><div class="line">0x0000000181521bd8 08F13F91               add        x8, x8, #0xffc             ; ___CF120293</div><div class="line">0x0000000181521bdc 08014039               ldrb       w8, [x8]                   ; ___CF120293</div><div class="line">0x0000000181521be0 48000034               cbz        w8, loc_181521be8</div><div class="line"></div><div class="line">0x0000000181521be4 E3560394               bl         ___THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__</div><div class="line"></div><div class="line">                                      loc_181521be8:</div><div class="line">0x0000000181521be8 93420091               add        x19, x20, #0x10            ; CODE XREF=_CFRunLoopWakeUp+68</div><div class="line">0x0000000181521bec E00313AA               mov        x0, x19</div><div class="line">0x0000000181521bf0 70300694               bl         imp___stubs_-[NSOrderedSet sortedArrayFromRange:options:usingComparator:]//真机的系统库做了混淆，这里其实是__CFRunLoopLock</div><div class="line">0x0000000181521bf4 882E40F9               ldr        x8, [x20, #0x58]</div><div class="line">0x0000000181521bf8 080D40B9               ldr        w8, [x8, #0xc]</div><div class="line">0x0000000181521bfc A8010034               cbz        w8, loc_181521c30</div></pre></td></tr></table></figure>
<p>crash日志中，崩溃在<code>CFRunLoopWakeUp + 92</code>，对应汇编地址为<code>0x0000000181521b9c + 92</code>=<code>0x0000000181521bf8</code>，在<code>ldr        w8, [x8, #0xc]</code>的时候挂了。查看crash时寄存器的值，<code>x8: 0x8c8c8c8c8c8c8c8c</code>，很明显<code>x8</code>指向的内存已经被释放了。<code>x8</code>是从<code>ldr        x8, [x20, #0x58]</code>得来的（也就是<code>x20</code>的地址偏移<code>0x58</code>后的值），而<code>x20</code>则是从<code>mov        x20, x0</code>得来的，<code>x0</code>就是<code>CFRunloopWakeUp</code>的第一个参数，<code>CFRunLoopRef</code>结构体，所以<code>x8</code>就是<code>CFRunLoopRef</code>偏移<code>0x58</code>后的值。</p>
<p><code>CoreFoundation</code>的代码是开源的，可以在这里下载：<a href="https://opensource.apple.com/tarballs/CF/CF-1153.18.tar.gz" target="_blank" rel="external">CF-1153.18</a>。</p>
<p>对应<code>CFRunloopWakeUp</code>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void CFRunLoopWakeUp(CFRunLoopRef rl) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    if (__CFRunLoopIsIgnoringWakeUps(rl)) &#123;</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    kern_return_t ret;</div><div class="line">    ret = __CFSendTrivialMachMessage(rl-&gt;_wakeUpPort, 0, MACH_SEND_TIMEOUT, 0);</div><div class="line">    if (ret != MACH_MSG_SUCCESS &amp;&amp; ret != MACH_SEND_TIMED_OUT) CRASH(&quot;*** Unable to send message to wake up port. (%d) ***&quot;, ret);</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">&#125;</div><div class="line"></div><div class="line">CF_INLINE Boolean __CFRunLoopIsIgnoringWakeUps(CFRunLoopRef rl) &#123;</div><div class="line">    return (rl-&gt;_perRunData-&gt;ignoreWakeUps) ? true : false;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CFRunloop结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFRuntimeBase _base;	//16 byte</div><div class="line">    pthread_mutex_t _lock;	//64 byte</div><div class="line">    __CFPort _wakeUpPort; //mach_port_t (unsign int), 4 byte</div><div class="line">    Boolean _unused;	//bool变量占用1 byte，但是需要和4字节对齐，所以也是4 byte</div><div class="line">    volatile _per_run_data *_perRunData;</div><div class="line">    pthread_t _pthread;</div><div class="line">    uint32_t _winthread;</div><div class="line">    CFMutableSetRef _commonModes;</div><div class="line">    CFMutableSetRef _commonModeItems;</div><div class="line">    CFRunLoopModeRef _currentMode;</div><div class="line">    CFMutableSetRef _modes;</div><div class="line">    struct _block_item *_blocks_head;</div><div class="line">    struct _block_item *_blocks_tail;</div><div class="line">    CFAbsoluteTime _runTime;</div><div class="line">    CFAbsoluteTime _sleepTime;</div><div class="line">    CFTypeRef _counterpart;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef struct __CFRuntimeBase &#123;</div><div class="line">    uintptr_t _cfisa;	//unsigned long 8 byte</div><div class="line">    uint8_t _cfinfo[4];	//unsigned char 4 byte</div><div class="line">#if __LP64__</div><div class="line">    uint32_t _rc;	//unsigned int 4 byte</div><div class="line">#endif</div><div class="line">&#125; CFRuntimeBase;</div><div class="line"></div><div class="line">struct pthread_mutex_t &#123;</div><div class="line">truelong __sig;	//8 byte</div><div class="line">truechar __opaque[56]; //56 byte</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>计算结构体size后，得出<code>ldr        x8, [x20, #0x58]</code>就是<code>runloop-&gt; _perRunData</code>。也就是在调用<code>__CFRunLoopIsIgnoringWakeUps</code>的时候，<code>CFRunLoopRef</code>已经被释放了。</p>
<h3 id="分析CFSocket源码"><a href="#分析CFSocket源码" class="headerlink" title="分析CFSocket源码"></a>分析<code>CFSocket</code>源码</h3><p>查看<code>CFSocketInvalidate</code>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">void CFSocketInvalidate(CFSocketRef s) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRetain(s);</div><div class="line">    __CFLock(&amp;__CFAllSocketsLock);</div><div class="line">    __CFSocketLock(s);</div><div class="line">    if (__CFSocketIsValid(s)) &#123;</div><div class="line">    </div><div class="line">        //省略部分代码...</div><div class="line"></div><div class="line">truetrue //取出socket中的runloop数组</div><div class="line">        CFArrayRef runLoops = (CFArrayRef)CFRetain(s-&gt;_runLoops);</div><div class="line">       //CFRunloop释放操作1       </div><div class="line">        CFRelease(s-&gt;_runLoops);</div><div class="line">        </div><div class="line">        s-&gt;_runLoops = NULL;</div><div class="line">        </div><div class="line">        //省略部分代码...</div><div class="line">        </div><div class="line">        __CFSocketUnlock(s);</div><div class="line">        </div><div class="line">        // Do this after the socket unlock to avoid deadlock (10462525)</div><div class="line">        for (idx = CFArrayGetCount(runLoops); idx--;) &#123;</div><div class="line">            CFRunLoopWakeUp((CFRunLoopRef)CFArrayGetValueAtIndex(runLoops, idx));</div><div class="line">        &#125;</div><div class="line">        //CFRunloop释放操作3</div><div class="line">        CFRelease(runLoops);</div><div class="line"></div><div class="line">        //省略部分代码...</div><div class="line">    &#125; else &#123;</div><div class="line">        __CFSocketUnlock(s);</div><div class="line">    &#125;</div><div class="line">    __CFUnlock(&amp;__CFAllSocketsLock);</div><div class="line">    CFRelease(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>CFSocketInvalidate</code>中唯一使用到<code>CFRunLoopWakeUp</code>的地方，就是最后遍历runloops的操作。<br>但是此时<code>CFRunLoopRef</code>还在数组里，正在被数组强引用，到了<code>CFRunLoopWakeUp</code>里怎么就被释放了呢？</p>
<p>注意，<code>CFSocketInvalidate</code>里遍历runloops的操作是在锁外面进行的，说明CFSocket很有可能没有管理好它的runloops数组，导致数组在遍历时被释放了。从<code>Do this after the socket unlock to avoid deadlock (10462525)</code>这一行注释猜测，这部分遍历操作之前应该也是在锁内的，但是会出现死锁，所以放到了锁外。苹果的bug report是不对外公开的，只在这里找到了可能相关的讨论：<a href="https://bugreports.qt.io/browse/QTBUG-22789" target="_blank" rel="external">bug #10462525</a>。</p>
<p>最大的可能是出现在<code>__CFSocketCancel</code>里。在runloop停止的时候，也会执行remove source操作，在<code>CFRunLoopRemoveSource</code>里，会执行source0的cancel函数，也就是<code>__CFSocketCancel</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) \</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    Boolean doVer0Callout = false, doRLSRelease = false;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">true//省略代码...</div><div class="line">    &#125; else &#123;</div><div class="line">trueCFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, false);</div><div class="line">trueif (NULL != rlm &amp;&amp; ((NULL != rlm-&gt;_sources0 &amp;&amp; CFSetContainsValue(rlm-&gt;_sources0, rls)) || (NULL != rlm-&gt;_sources1 &amp;&amp; CFSetContainsValue(rlm-&gt;_sources1, rls)))) &#123;</div><div class="line">true    CFRetain(rls);</div><div class="line">true    //省略代码...</div><div class="line">true    if (0 == rls-&gt;_context.version0.version) &#123;</div><div class="line">true        if (NULL != rls-&gt;_context.version0.cancel) &#123;</div><div class="line">true            doVer0Callout = true;</div><div class="line">true        &#125;</div><div class="line">true    &#125;</div><div class="line">true    doRLSRelease = true;</div><div class="line">true&#125;</div><div class="line">        //省略代码...</div><div class="line">true&#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    if (doVer0Callout) &#123;</div><div class="line">        // although it looses some protection for the source, we have no choice but</div><div class="line">        // to do this after unlocking the run loop and mode locks, to avoid deadlocks</div><div class="line">        // where the source wants to take a lock which is already held in another</div><div class="line">        // thread which is itself waiting for a run loop/mode lock</div><div class="line">        rls-&gt;_context.version0.cancel(rls-&gt;_context.version0.info, rl, modeName);	/* CALLOUT */</div><div class="line">    &#125;</div><div class="line">    if (doRLSRelease) CFRelease(rls);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>__CFSocketCancel</code>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">static void __CFSocketCancel(void *info, CFRunLoopRef rl, CFStringRef mode) &#123;</div><div class="line">    CFSocketRef s = (CFSocketRef)info;</div><div class="line">    __CFSocketLock(s);</div><div class="line">    if (0 == s-&gt;_socketSetCount) &#123;</div><div class="line">        //省略代码...</div><div class="line">    if (NULL != s-&gt;_runLoops) &#123;</div><div class="line">    //从runloops数组中移除此runloop；对原数组执行拷贝后，释放原数组</div><div class="line">        CFMutableArrayRef runLoopsOrig = s-&gt;_runLoops;</div><div class="line">        CFMutableArrayRef runLoopsCopy = CFArrayCreateMutableCopy(kCFAllocatorSystemDefault, 0, s-&gt;_runLoops);</div><div class="line">        idx = CFArrayGetFirstIndexOfValue(runLoopsCopy, CFRangeMake(0, CFArrayGetCount(runLoopsCopy)), rl);</div><div class="line">        if (0 &lt;= idx) CFArrayRemoveValueAtIndex(runLoopsCopy, idx);</div><div class="line">        s-&gt;_runLoops = runLoopsCopy;</div><div class="line">        //CFRunloop释放操作2</div><div class="line">        CFRelease(runLoopsOrig);</div><div class="line">    &#125;</div><div class="line">    __CFSocketUnlock(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>__CFSocketCancel</code>也有一次对<code>CFRunloopRef</code>的释放操作，加上<code>CFSocketInvalidate</code>里的2个，总共有3个释放操作。</p>
<p>所以，如果<code>__CFSocketCancel</code>和<code>CFSocketInvalidate</code>在多线程同时执行，就有可能出现对CFSocket中的runloops数组过度释放，因此在遍历runloops的时候就会出现<code>CFRunLoopRef</code>被释放的情况。虽然这个crash出现的概率比较低，但是在项目里隔一段时间就会稳定出现。</p>
<p>所以，不是加了锁就万事大吉了，<code>CFSocketInvalidate</code>里在遍历数组前应该再加一个retain才能保证安全。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>既然是CFSocket里的bug，那就只能避免不要出现<code>CFSocketInvalidate</code>和<code>CFRunloopStop</code>多线程执行的代码。</li>
<li>如果你的socket只在这个线程里运行，那直接调用<code>CFRunloopStop</code>即可，runloop会自动清理所有source。</li>
<li>如果这个线程需要重用，那就不需要stop，而是停止socket后，在同一个线程里新建socket。</li>
</ul>
<h2 id="自动停止的Runloop"><a href="#自动停止的Runloop" class="headerlink" title="自动停止的Runloop"></a>自动停止的Runloop</h2><p>那么，如果把stop代码改成这样，应该就没问题了吧？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)runThread &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        self.currentRunloop = CFRunLoopGetCurrent();</div><div class="line">        [self addRunloopSource];</div><div class="line">        [self addSocketSource];</div><div class="line">        </div><div class="line">        CFRunLoopRun();</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;线程退出&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)stopThread &#123;</div><div class="line">    if (_currentRunloop) &#123;</div><div class="line">true    //保证removeSocketSource的操作只会在这里执行，没有多线程的情况</div><div class="line">        [self removeSocketSource];</div><div class="line">        CFRunLoopStop(_currentRunloop);</div><div class="line">        self.currentRunloop = NULL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很遗憾，这样写还是不安全的。</p>
<p>原因在于<code>removeSocketSource</code>之后，runloop里source就全部为空了，runloop如果检测到了source为空，就会自动停止runloop循环，销毁线程。</p>
<p>因此如果你在另一个线程调用<code>stopThread</code>，在<code>removeSocketSource</code>之后线程就会随时停止，runloop在调用<code>CFRunLoopStop</code>时可能已经被释放了。</p>
<p>上面的写法出现crash的概率太低，但是稍微改一下就能必现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)stopThread &#123;</div><div class="line">    if (_currentRunloop) &#123;</div><div class="line">        [self removeSocketSource];</div><div class="line">        </div><div class="line">        //插入一个耗时操作</div><div class="line">        sleep(2);</div><div class="line">        //必定crash</div><div class="line">        CFRunLoopStop(_currentRunloop);</div><div class="line">        self.currentRunloop = NULL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种情况下crash的原因其实是没做好内存管理，只要对runloop增加一次retain操作就没问题了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)runThread &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">true    //做一次retain操作</div><div class="line">        self.currentRunloop = CFRetain(CFRunLoopGetCurrent());</div><div class="line">        [self addRunloopSource];</div><div class="line">        [self addSocketSource];</div><div class="line">        </div><div class="line">        CFRunLoopRun();</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;线程退出&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)stopThread &#123;</div><div class="line">    if (_currentRunloop) &#123;</div><div class="line">        [self removeSocketSource];</div><div class="line">        CFRunLoopStop(_currentRunloop);</div><div class="line">        CFRelease(_currentRunloop);</div><div class="line">        self.currentRunloop = NULL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在使用runloop source的时候要谨慎，尤其在处理stop的阶段。其他source可能也存在类似的问题。</p>
<p>一个变量有多线程操作的时候，在锁外的操作即使是只读也是不安全的，在读取之前最好再做一次retain操作，防止在读取的过程中被释放。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你还不了解什么是runloop，可以看这里的详解&lt;a href=&quot;http://blog.ibireme.com/2015/05/18/runloop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;深入理解RunLoop&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;苹果
    
    </summary>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向：在任意app上开启malloc stack追踪内存来源</title>
    <link href="http://zuikyo.github.io/2017/05/04/iOS%E9%80%86%E5%90%91%EF%BC%9A%E5%9C%A8%E4%BB%BB%E6%84%8Fapp%E4%B8%8A%E5%BC%80%E5%90%AFmalloc%20stack%E8%BF%BD%E8%B8%AA%E5%86%85%E5%AD%98%E6%9D%A5%E6%BA%90/"/>
    <id>http://zuikyo.github.io/2017/05/04/iOS逆向：在任意app上开启malloc stack追踪内存来源/</id>
    <published>2017-05-04T12:49:00.000Z</published>
    <updated>2017-10-20T08:02:51.370Z</updated>
    
    <content type="html"><![CDATA[<p>lldb有一个内存调试工具malloc stack，开启以后就可以查看某个内存地址的malloc和free记录，追踪对象是在哪里创建的。</p>
<p>这个工具可以打印出对象创建的堆栈，而在逆向时，也经常需要追踪某些方法的调用栈，如果可以随时打印出某个对象的创建记录，也就能直接找到其所在的类和方法，不用再花费大量的时间去打log和动态调试追踪了。</p>
<h2 id="malloc-stack"><a href="#malloc-stack" class="headerlink" title="malloc stack"></a>malloc stack</h2><p>在自己的项目中，要开启malloc stack，需要在<code>Product-&gt;Scheme-&gt;Edit Scheme-&gt;Diagnistic</code>里勾选<code>Malloc Stack</code>选项。</p>
<p>效果如下：</p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (IBAction)create:(id)sender &#123;</div><div class="line">    NSString *testString = [NSString stringWithFormat:@&quot;string created by %@&quot;,self];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>断点后在lldb中使用<code>lldb.macosx.heap</code>里的<code>malloc_info</code>命令，虽然官网上说是Mac app才能用的命令，但是经测试现在在iOS上也能用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">(lldb) p/x testString</div><div class="line">(__NSCFString *) $3 = 0x16eac000 @&quot;string created by &lt;ViewController: 0x16e9d7c0&gt;&quot;</div><div class="line">(lldb) command script import lldb.macosx.heap //加载lldb.macosx.heap</div><div class="line">&quot;malloc_info&quot;, &quot;ptr_refs&quot;, &quot;cstr_refs&quot;, &quot;find_variable&quot;, and &quot;objc_refs&quot; commands have been installed, use the &quot;--help&quot; options on these commands for detailed help.</div><div class="line">(lldb) malloc_info -s 0x16eac000</div><div class="line">0x0000000016eac000: malloc(    64) -&gt; 0x16eac000 __NSCFString.NSMutableString.NSString.NSObject.isa</div><div class="line">stack[0]: addr = 0x16eac000, type=malloc, frames:</div><div class="line">     [0] 0x00000000242948ab libsystem_malloc.dylib`malloc_zone_malloc + 123</div><div class="line">     [1] 0x00000000244e3bc1 CoreFoundation`_CFRuntimeCreateInstance + 237</div><div class="line">     [2] 0x00000000245a6ffd CoreFoundation`__CFStringCreateImmutableFunnel3 + 1657</div><div class="line">     [3] 0x00000000244ee0f7 CoreFoundation`CFStringCreateCopy + 359</div><div class="line">     [4] 0x00000000245a725d CoreFoundation`_CFStringCreateWithFormatAndArgumentsAux2 + 89</div><div class="line">     [5] 0x0000000024d17dd3 Foundation`-[NSPlaceholderString initWithFormat:locale:arguments:] + 139</div><div class="line">     [6] 0x0000000024d17cd1 Foundation`+[NSString stringWithFormat:] + 61</div><div class="line">     [7] 0x00000000000d7343 testMallocStack`-[ViewController create:] + 97 at ViewController.m:23:28</div><div class="line">     [8] 0x00000000287a5771 UIKit`-[UIApplication sendAction:to:from:forEvent:] + 81</div><div class="line">     [9] 0x00000000287a5701 UIKit`-[UIControl sendAction:to:forEvent:] + 65</div><div class="line">     [10] 0x000000002878d61f UIKit`-[UIControl _sendActionsForEvents:withEvent:] + 447</div><div class="line">     [11] 0x00000000287a5051 UIKit`-[UIControl touchesEnded:withEvent:] + 617</div><div class="line">     [12] 0x00000000287a4cbf UIKit`-[UIWindow _sendTouchesForEvent:] + 647</div><div class="line">     [13] 0x000000002879d5d7 UIKit`-[UIWindow sendEvent:] + 643</div><div class="line">     [14] 0x000000002876e119 UIKit`-[UIApplication sendEvent:] + 205</div><div class="line">     [15] 0x000000002876c757 UIKit`_UIApplicationHandleEventQueue + 5135</div><div class="line">     [16] 0x0000000024599257 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 15</div><div class="line">     [17] 0x0000000024598e47 CoreFoundation`__CFRunLoopDoSources0 + 455</div><div class="line">     [18] 0x00000000245971af CoreFoundation`__CFRunLoopRun + 807</div><div class="line">     [19] 0x00000000244e9bb9 CoreFoundation`CFRunLoopRunSpecific + 517</div><div class="line">     [20] 0x00000000244e99ad CoreFoundation`CFRunLoopRunInMode + 109</div><div class="line">     [21] 0x0000000025763af9 GraphicsServices`GSEventRunModal + 161</div><div class="line">     [22] 0x00000000287d5fb5 UIKit`UIApplicationMain + 145</div><div class="line">     [23] 0x00000000000d7587 testMallocStack`main + 107 at main.m:14:9</div><div class="line">     [24] 0x000000002419c873 libdyld.dylib`start + 3</div><div class="line">     [25] 0x000000003a9c0001 libsystem_pthread.dylib`_thread + 1</div></pre></td></tr></table></figure>
<p>这个工具是继承自gdb的<code>malloc_history</code>，不过<code>malloc_history</code>只能用在模拟器上，而<code>malloc_info</code>在模拟器和真机上都可以使用。另外，新版Xcode又增加了一个新的lldb工具<code>memory history</code>，在<code>Product-&gt;Scheme-&gt;Edit Scheme-&gt;Diagnistic</code>里勾选<code>Address Sanitizer</code>即可，效果类似。</p>
<h2 id="使用非官方版的heap-py"><a href="#使用非官方版的heap-py" class="headerlink" title="使用非官方版的heap.py"></a>使用非官方版的heap.py</h2><p>注意，在Xcode8.3以后使用<code>malloc_info</code>会crash，似乎是出bug了，一直没修复。在Xcode8.2上可以正常使用。</p>
<p>所以我们需要替换一下lldb自带的lldb.macosx.heap模块。使用这个非官方的版本：<a href="https://github.com/llvm-mirror/lldb/blob/master/examples/darwin/heap_find/heap.py" target="_blank" rel="external">heap.py</a>。</p>
<p>lldb可以加载自定义的pthon脚本。只需要在lldb中输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">command script import python脚本的地址</div></pre></td></tr></table></figure>
<p>因此把上面的<code>heap.py</code>下载到本地后，输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">command script import /你的路径/lldb/examples/darwin/heap_find/heap.py</div></pre></td></tr></table></figure>
<p>即可。</p>
<h2 id="在任意app上开启malloc-stack"><a href="#在任意app上开启malloc-stack" class="headerlink" title="在任意app上开启malloc stack"></a>在任意app上开启malloc stack</h2><p><code>Address Sanitizer</code>的<code>memory history</code>需要重新编译app，但是<code>malloc stack</code>只需要在app启动前设置环境变量<code>MallocStackLogging</code>和<code>MallocStackLoggingNoCompact</code>即可。开启后会在系统的<code>/tmp</code>目录下生成一个<code>.index</code>文件，这个文件里的内容是依赖于app的运行时环境的，进程退出以后这个文件也就没用处了。</p>
<p>那么，现在的问题就变成了如何给app设置启动环境变量。</p>
<h3 id="方法一：execve"><a href="#方法一：execve" class="headerlink" title="方法一：execve"></a>方法一：execve</h3><p>这是我一开始使用的方法。使用<code>execve</code>函数来运行app的二进制文件。</p>
<p>由于沙盒的限制，需要让app拥有root权限才能使用<code>execve</code>。步骤如下。</p>
<h4 id="1-重签名ipa"><a href="#1-重签名ipa" class="headerlink" title="1.重签名ipa"></a>1.重签名ipa</h4><p>重签名需要逆向的app。因为需要对app内容作出修改。重签名后安装到越狱设备上。</p>
<h4 id="2-移动app到系统app目录下，修改权限"><a href="#2-移动app到系统app目录下，修改权限" class="headerlink" title="2.移动app到系统app目录下，修改权限"></a>2.移动app到系统app目录下，修改权限</h4><p>只有系统目录下的app才有root权限。</p>
<p>假设需要逆向的app是<code>YOUR_APP.app</code>。把app移动到系统app目录下：<code>mv -f /var/containers/Bundle/Application/xxxxxxxxxxxxx/YOUR_APP.app /Applications/YOUR_APP.app</code>。</p>
<p>然后修改文件权限：</p>
<p><code>cd /Applications</code></p>
<p><code>chown -R root:wheel YOUR_APP.app</code></p>
<p><code>chmod 4755 YOUR_APP.app/YOUR_APP</code></p>
<p>移动后，用<code>uicache</code>刷新app图标，用<code>killall SpringBoard</code>重启<code>SpringBoard</code>。</p>
<h4 id="3-使用引导程序启动app"><a href="#3-使用引导程序启动app" class="headerlink" title="3.使用引导程序启动app"></a>3.使用引导程序启动app</h4><p>最终的目的就是使用引导程序用<code>execve</code>启动app，在启动前设置环境变量。</p>
<p>首先重命名原来的二进制文件：<code>mv YOUR_APP.app/YOUR_APP   YOUR_APP.app/YOUR_APP_Orig</code>。</p>
<p>然后制作引导程序，随便创建一个iOS工程，替换main.m里的内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        NSString* string = [[NSBundle mainBundle] pathForResource:@&quot;YOUR_APP_Orig&quot; ofType:nil];//YOUR_APP_Orig是所要启动的二进制文件名</div><div class="line">        argv[0] = (char*)[string UTF8String];</div><div class="line">        char *envp[] =</div><div class="line">        &#123;</div><div class="line">            &quot;HOME=/var/root&quot;,</div><div class="line">            &quot;LOGNAME=root&quot;,</div><div class="line">            &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11:/usr/games&quot;,</div><div class="line">            &quot;USER=root&quot;,</div><div class="line">            &quot;MallocStackLogging=1&quot;,</div><div class="line">            &quot;MallocStackLoggingNoCompact=1&quot;</div><div class="line">            0</div><div class="line">        &#125;;</div><div class="line">        execve([string UTF8String], argv, envp);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后，取出二进制文件，重命名为<code>YOUR_APP</code>，复制到越狱设备的<code>/Application/YOUR_APP.app/</code>目录下。</p>
<p>给引导程序设置执行权限：<code>chmod +x /Application/YOUR_APP.app/YOUR_APP</code>。</p>
<p>最后重启SpringBoard：<code>killall SpringBoard</code>。</p>
<p>这样，每次启动app就都会使用引导程序间接启动app。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>步骤繁琐。</li>
<li>有些app重签名很麻烦。</li>
<li>越狱后的系统分区容量很小，很容易就被占满了，想要测试大一点的app就麻烦了。</li>
<li>无法使用<code>debugserver</code>唤醒app，调试启动过程。因为<code>YOUR_APP</code>和<code>YOUR_APP_Orig</code>是两个进程，第一个在<code>execve</code>执行完就退出了。</li>
<li>把app放到系统目录下有时候会引起crash。</li>
</ul>
<h3 id="方法2：debugserver参数"><a href="#方法2：debugserver参数" class="headerlink" title="方法2：debugserver参数"></a>方法2：debugserver参数</h3><p>方法1实在是太麻烦了，有时候遇上重签名失败的app就更麻烦了。但其实还有另一个更直接的方法。就是使用debugserver的命令。</p>
<p>debugserver是动态调试工具，参考：<a href="http://gslab.qq.com/article-159-1.html" target="_blank" rel="external">IOS平台lldb动态调试介绍</a>。</p>
<p>安装好后，在越狱设备上输入<code>debugserver *:1234 /var/containers/Bundle/Application/589822B6-BFDA-4A3D-A71C-AD0D30BA6077/WeChat.app/WeChat</code>就能唤醒app进行调试。</p>
<p>但是网上的教程都没有提到，其实debugserver还有一个隐藏的参数<code>--env</code>(<code>-env</code>,<code>-e</code>都可以)，就是用来设置进程的环境变量的：</p>
<p><code>debugserver *:1234 /var/containers/Bundle/Application/589822B6-BFDA-4A3D-A71C-AD0D30BA6077/WeChat.app/WeChat -env MallocStackLogging=1 -env MallocStackLoggingNoCompact=1</code></p>
<p>当时我想debugserver会不会有设置环境变量的功能，没想到随便试了个<code>-env</code>就成功了。后来在debugserver的源码里也发现了它的存在：<a href="https://llvm.org/svn/llvm-project/lldb/trunk/tools/debugserver/source/debugserver.cpp" target="_blank" rel="external">debugserver.cpp</a>（搜索<code>g_long_options</code>可以找到<code>env</code>）。</p>
<p>这样，即使app没有重签名，也可以直接调试了。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p><code>debugserver</code>无法启动调试extension app，因为extension app是依赖于宿主app而存在的，不能单独运行。这种情况就只能使用方法1了。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这里使用一个重签名，并且恢复了符号表的微信进行测试。</p>
<p>比如找到微信查看表情的界面，打印出内存地址为<code>0x108795c20</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;MMEmoticonView: 0x108795c20; frame = (276.25 404.25; 215.5 215.5); autoresize = LM+RM+TM+BM; layer = &lt;CALayer: 0x170828700&gt;&gt;</div></pre></td></tr></table></figure>
<p>第一次使用<code>malloc_info</code>需要在lldb里导入<code>lldb.macosx.heap</code>，这里需要导入非官方版本的<code>heap.py</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) command script import heap.py的路径</div><div class="line">&quot;malloc_info&quot;, &quot;ptr_refs&quot;, &quot;cstr_refs&quot;, &quot;find_variable&quot;, and &quot;objc_refs&quot; commands have been installed, use the &quot;--help&quot; options on these commands for detailed help.</div></pre></td></tr></table></figure>
<p>使用<code>malloc_info</code>打印创建堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">(lldb) malloc_info -s 0x108795c20</div><div class="line">0x0000000108795c20: malloc(   480) -&gt; 0x108795c20 MMEmoticonView.UIView.UIResponder.NSObject.isa</div><div class="line">stack[0]: addr = 0x108795c20, type=malloc, frames:</div><div class="line">     [0] 0x000000018374e0ac libsystem_malloc.dylib`calloc + 40</div><div class="line">     [1] 0x000000018318b624 libobjc.A.dylib`class_createInstance + 76</div><div class="line">     [2] 0x0000000183199ae4 libobjc.A.dylib`_objc_rootAlloc + 52</div><div class="line">     [3] 0x00000001026d8fd4 WeChat`-[MMImageBrowseView InitEmoticonView:] + 432</div><div class="line">     [4] 0x000000010245e950 WeChat`-[MMEmotionMsgBrowseViewController initImageViewWithFrame:] + 404</div><div class="line">     [5] 0x000000010245ea74 WeChat`-[MMEmotionMsgBrowseViewController setupImageView] + 156</div><div class="line">     [6] 0x000000010245e024 WeChat`-[MMEmotionMsgBrowseViewController initView] + 224</div><div class="line">     [7] 0x000000010245d76c WeChat`-[MMEmotionMsgBrowseViewController viewDidLoad] + 112</div><div class="line">     [8] 0x000000018a5f7924 UIKit`-[UIViewController loadViewIfRequired] + 1056</div><div class="line">     [9] 0x000000018a60f4b4 UIKit`-[UIViewController __viewWillAppear:] + 132</div><div class="line">     [10] 0x00000001026e05f8 WeChat`-[MMUIViewController beginAppearanceTransition:animated:] + 92</div><div class="line">     [11] 0x000000018a7975b4 UIKit`-[UINavigationController _startCustomTransition:] + 1136</div><div class="line">     [12] 0x000000018a6afe74 UIKit`-[UINavigationController _startDeferredTransitionIfNeeded:] + 676</div><div class="line">     [13] 0x000000018a6afadc UIKit`-[UINavigationController __viewWillLayoutSubviews] + 64</div><div class="line">     [14] 0x000000018a6afa40 UIKit`-[UILayoutContainerView layoutSubviews] + 188</div><div class="line">     [15] 0x000000018a5f4a80 UIKit`-[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 1196</div><div class="line">     [16] 0x0000000187aa29d8 QuartzCore`-[CALayer layoutSublayers] + 148</div><div class="line">     [17] 0x0000000187a974cc QuartzCore`CA::Layer::layout_if_needed(CA::Transaction*) + 292</div><div class="line">     [18] 0x0000000187a9738c QuartzCore`CA::Layer::layout_and_display_if_needed(CA::Transaction*) + 32</div><div class="line">     [19] 0x0000000187a143e0 QuartzCore`CA::Context::commit_transaction(CA::Transaction*) + 252</div><div class="line">     [20] 0x0000000187a3ba68 QuartzCore`CA::Transaction::commit() + 512</div><div class="line">     [21] 0x0000000187a3c488 QuartzCore`CA::Transaction::observer_callback(__CFRunLoopObserver*, unsigned long, void*) + 120</div><div class="line">     [22] 0x00000001846f60c0 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 32</div><div class="line">     [23] 0x00000001846f3cf0 CoreFoundation`__CFRunLoopDoObservers + 372</div><div class="line">     [24] 0x00000001846f4180 CoreFoundation`__CFRunLoopRun + 1024</div><div class="line">     [25] 0x00000001846222b8 CoreFoundation`CFRunLoopRunSpecific + 444</div><div class="line">     [26] 0x00000001860d6198 GraphicsServices`GSEventRunModal + 180</div><div class="line">     [27] 0x000000018a6627fc UIKit`-[UIApplication _run] + 684</div><div class="line">     [28] 0x000000018a65d534 UIKit`UIApplicationMain + 208</div><div class="line">     [29] 0x00000001000ebea4 WeChat`-[WATemplateMsgMngSwitchCell .cxx_destruct] + 372</div><div class="line">     [30] 0x00000001836055b8 libdyld.dylib`start + 4</div></pre></td></tr></table></figure>
<p>这样就直接找到表情界面所在的类，以及在哪里初始化了。</p>
<p>这样的话，只要能找到一个对象，就能快速定位到其所在模块。比原来打log，打断点一步步回溯高效多了。</p>
<h2 id="恢复符号表"><a href="#恢复符号表" class="headerlink" title="恢复符号表"></a>恢复符号表</h2><p>建议在对app重签名时恢复符号表。恢复符号表后，就能直接在堆栈中看到方法名，免去了计算偏移量然后在hopper里查找的麻烦。</p>
<p>参考：<a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">iOS符号表恢复&amp;逆向支付宝</a>, <a href="https://github.com/tobefuturer/restore-symbol" target="_blank" rel="external">restore-symbol</a>。</p>
<h2 id="其他几个调试命令"><a href="#其他几个调试命令" class="headerlink" title="其他几个调试命令"></a>其他几个调试命令</h2><h3 id="ptr-refs"><a href="#ptr-refs" class="headerlink" title="ptr_refs"></a>ptr_refs</h3><p>可以在内存中找出哪些地址引用了某个指针，也就相当于查看某个变量在哪里被引用。</p>
<h3 id="cstr-refs"><a href="#cstr-refs" class="headerlink" title="cstr_refs"></a>cstr_refs</h3><p>在内存中寻找某个C String在哪里被引用。</p>
<h3 id="find-variable"><a href="#find-variable" class="headerlink" title="find_variable"></a>find_variable</h3><p>在当前栈帧上寻找某个局部变量在哪里被引用。</p>
<h3 id="objc-refs"><a href="#objc-refs" class="headerlink" title="objc_refs"></a>objc_refs</h3><p>在内存中寻找某个类的实例。</p>
<h2 id="转到Xcode中调试"><a href="#转到Xcode中调试" class="headerlink" title="转到Xcode中调试"></a>转到Xcode中调试</h2><p>如果想要在Xcode中调试并开启<code>malloc stack</code>，则需要先用<code>debugserver</code>启动app，在终端的lldb里连接上以后，再用<code>process detach</code>断开连接。接下来用Xcode的<code>Attach to Process</code>就可以了，参考：<a href="https://zuikyo.github.io/2017/05/04/iOS逆向：用Xcode直接调试第三方app/">iOS逆向：用Xcode直接调试第三方app</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;lldb有一个内存调试工具malloc stack，开启以后就可以查看某个内存地址的malloc和free记录，追踪对象是在哪里创建的。&lt;/p&gt;
&lt;p&gt;这个工具可以打印出对象创建的堆栈，而在逆向时，也经常需要追踪某些方法的调用栈，如果可以随时打印出某个对象的创建记录，也就能
    
    </summary>
    
      <category term="逆向工程" scheme="http://zuikyo.github.io/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向：用Xcode直接调试第三方app</title>
    <link href="http://zuikyo.github.io/2017/05/04/iOS%E9%80%86%E5%90%91%EF%BC%9A%E7%94%A8Xcode%E7%9B%B4%E6%8E%A5%E8%B0%83%E8%AF%95%E7%AC%AC%E4%B8%89%E6%96%B9app/"/>
    <id>http://zuikyo.github.io/2017/05/04/iOS逆向：用Xcode直接调试第三方app/</id>
    <published>2017-05-04T12:48:00.000Z</published>
    <updated>2017-05-05T02:19:48.950Z</updated>
    
    <content type="html"><![CDATA[<p>一般动态调试app时，都是在终端里用lldb直接调试，但是用Xcode的<code>Attach to Process</code>也可以连接到真机上的进程进行调试。但是只能调试用自己的证书签名的app。</p>
<p>在Xcode上调试的优点：</p>
<ul>
<li>有UI界面，查看堆栈更直接，可以用Xcode打断点。</li>
<li>可以使用<code>debug gauges</code>里的Disk和Network等工具。</li>
<li>输入lldb命令时有自动补全。</li>
<li>可以使用Xcode的<code>Debug UI Hierarchy</code>功能，直接查看app的界面布局。</li>
<li>可以使用Xcode的<code>Debug Memory Graph</code>功能，查看当前内存中存在的所有对象，以及对象之间的引用关系。</li>
</ul>
<p>步骤如下。</p>
<h2 id="1-重签名需要逆向的app"><a href="#1-重签名需要逆向的app" class="headerlink" title="1.重签名需要逆向的app"></a>1.重签名需要逆向的app</h2><p>重签名后才能用Xcode attach。而重签名前需要对app进行砸壳。这些步骤就不再重复了。</p>
<p>额外说一句，在砸壳后建议进行一下恢复符号表的操作。恢复符号表后，在调试时就能直接在堆栈中看到方法名，免去了计算偏移量然后在hopper里查找的麻烦。参考：<a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">iOS符号表恢复&amp;逆向支付宝</a>, <a href="https://github.com/tobefuturer/restore-symbol" target="_blank" rel="external">restore-symbol</a>。</p>
<h2 id="2-Attach-to-Process"><a href="#2-Attach-to-Process" class="headerlink" title="2.Attach to Process"></a>2.Attach to Process</h2><p>重签名后安装到越狱设备上，启动app，在Xcode中随便打开一个工程，选择越狱设备，就可以在<code>Debug-&gt;Attach to Process</code>中找到正在运行的进程名和进程id，点击后就会开始连接。大概过1分钟就会连接上。</p>
<h2 id="3-查看UI"><a href="#3-查看UI" class="headerlink" title="3.查看UI"></a>3.查看UI</h2><p>连接上后，就可以点击使用Xcode的<code>Debug UI Hierarchy</code>来查看界面布局：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-b3652b738ff07228.jpg" alt="UI Hierarchy"></p>
<p>注意，<code>Debug UI Hierarchy</code>对Xcode版本似乎有要求，在调试重签名app时，Xcode8.3.2可以，而Xcode8.2就没有这个功能按钮。</p>
<h2 id="4-查看内存信息"><a href="#4-查看内存信息" class="headerlink" title="4.查看内存信息"></a>4.查看内存信息</h2><p>点击<code>Debug Memory Graph</code>按钮，可以查看当前内存中存在的数据。打印地址，查看引用关系，可以配合<code>malloc stack</code>进行追踪。如果打开了<code>malloc stack</code>，就可以直接在右边显示这个对象的创建堆栈。参考：<a href="https://zuikyo.github.io/2017/05/04/iOS逆向：在任意app上开启malloc%20stack追踪内存来源/">iOS逆向：在任意app上开启malloc%20stack追踪内存来源</a>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-d599a5233b28e245.jpg" alt="Memory Graph"></p>
<h2 id="5-查看正在使用的文件"><a href="#5-查看正在使用的文件" class="headerlink" title="5.查看正在使用的文件"></a>5.查看正在使用的文件</h2><p><code>debug gauges</code>中的Disk工具可以查看app当前打开的文件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-80d24111380e2e44.jpg" alt="Open Files"></p>
<h2 id="5-instrument调试"><a href="#5-instrument调试" class="headerlink" title="5.instrument调试"></a>5.instrument调试</h2><p>类似的，也可以用instrument调试重签名后的app，不过并不是所有工具都可以使用，对逆向的帮助不大。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般动态调试app时，都是在终端里用lldb直接调试，但是用Xcode的&lt;code&gt;Attach to Process&lt;/code&gt;也可以连接到真机上的进程进行调试。但是只能调试用自己的证书签名的app。&lt;/p&gt;
&lt;p&gt;在Xcode上调试的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="逆向工程" scheme="http://zuikyo.github.io/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>私有API-修复iOS10不弹出&quot;是否允许xxx访问数据&quot;导致app无法联网的bug</title>
    <link href="http://zuikyo.github.io/2017/02/05/%E7%A7%81%E6%9C%89API-%E4%BF%AE%E5%A4%8DiOS%2010%E4%B8%8D%E5%BC%B9%E5%87%BA%E6%98%AF%E5%90%A6%E5%85%81%E8%AE%B8xxx%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%87%B4app%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84bug/"/>
    <id>http://zuikyo.github.io/2017/02/05/私有API-修复iOS 10不弹出是否允许xxx访问数据导致app无法联网的bug/</id>
    <published>2017-02-05T15:38:00.000Z</published>
    <updated>2017-05-03T08:32:26.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>iOS 10有一个系统bug：app在第一次安装时，第一次联网操作会弹出一个授权框，提示”是否允许xxx访问数据？”。而有时候系统并不会弹出授权框，导致app无法联网。</p>
<p>详细情况见：</p>
<p><a href="http://www.jianshu.com/p/6cbde1b8b922" target="_blank" rel="external">iOS 10 的坑：新机首次安装 app，请求网络权限“是否允许使用数据”</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22738261" target="_blank" rel="external">iOS 10 不提示「是否允许应用访问数据」，导致应用无法使用的解决方案</a></p>
<p>关键点总结：</p>
<ul>
<li>只有iOS 10以上、国行机型、有蜂窝网络功能的设备存在这个授权问题，WiFi版的iPad没有这个问题；</li>
<li>由于授权框是在有网络操作时才弹出的，这就导致app第一次网络访问必定失败；</li>
<li>当出现不弹出授权框的bug时，去设置里更改任意app的蜂窝网络权限，或者打开无线局域网助理，让系统更新一下蜂窝网络相关的数据，可以解决这个bug。</li>
</ul>
<p>这个系统bug出现时，对用户来说是很麻烦的，app也需要提供详细的提示语来应对这种情况，十分不优雅。</p>
<h1 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h1><p>春节有点空，找到了几个相关的私有API来修复这个bug。</p>
<h2 id="弹出授权框"><a href="#弹出授权框" class="headerlink" title="弹出授权框"></a>弹出授权框</h2><p>首先找到的是一个能直接弹出授权框的API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Image: /System/Library/PrivateFrameworks/FTServices.framework/FTServices</div><div class="line"></div><div class="line">@interface FTNetworkSupport : NSObject</div><div class="line">+ (id)sharedInstance;</div><div class="line">- (bool)dataActiveAndReachable;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>头文件参考：<a href="https://github.com/JaviSoto/iOS10-Runtime-Headers/blob/master/PrivateFrameworks/FTServices.framework/FTNetworkSupport.h" target="_blank" rel="external">FTNetworkSupport.h</a></p>
<p>当app之前没有请求过网络权限时，调用<code>dataActiveAndReachable</code>会弹出”是否允许xxx访问数据？”的授权框，如果网络权限已经确定，则不会弹出。</p>
<h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p>由于<code>FTNetworkSupport</code>是在<code>PrivateFrameworks</code>目录下，app并没有加载这个库，所以要使用里面的类前，需要用<code>dlopen</code>加载<code>FTServices.framework</code>,简单示意如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;dlfcn.h&gt;</div><div class="line"></div><div class="line">//加载FTServices.framework</div><div class="line">void * FTServicesHandle = dlopen(&quot;/System/Library/PrivateFrameworks/FTServices.framework/FTServices&quot;, RTLD_LAZY);</div><div class="line">Class NetworkSupport = NSClassFromString(@&quot;FTNetworkSupport&quot;);</div><div class="line">id networkSupport = [NetworkSupport performSelector:NSSelectorFromString(@&quot;sharedInstance&quot;)];</div><div class="line">[networkSupport performSelector:NSSelectorFromString(@&quot;dataActiveAndReachable&quot;)];</div><div class="line">//卸载FTServices.framework</div><div class="line">dlclose(FTServicesHandle);</div></pre></td></tr></table></figure>
<p>这个API能解决网络权限导致第一个联网操作失败的问题，但是它还是存在有时候不会弹出授权框的bug。</p>
<h2 id="让系统更新蜂窝网络权限数据"><a href="#让系统更新蜂窝网络权限数据" class="headerlink" title="让系统更新蜂窝网络权限数据"></a>让系统更新蜂窝网络权限数据</h2><p>既然更改任意app的蜂窝网络权限后，能让app弹出授权框，那么只要找到一个方法，能让系统更新一下网络权限相关的数据就可以了。</p>
<p>用<code>hopper</code>反编译一下系统的设置app用到的库<code>PreferencesUI.framework</code>，找到了里面修改app网络权限的API。用到的是<code>CoreTelephony.framework</code>里的两个私有C函数：</p>
<p><code>CTServerConnection* _CTServerConnectionCreateOnTargetQueue(CFAllocatorRef, NSString *, dispatch_queue_t, void*/*一个block类型的参数*/)</code></p>
<p><code>void _CTServerConnectionSetCellularUsagePolicy(CTServerConnection *, NSString *, NSDictionary *)</code></p>
<p>大部分时间都花在测试这两个函数上了。几个月前我也研究过这两个函数尝试修复这个bug，但是那时候发现没什么作用，就不了了之了。</p>
<h3 id="调用方式-1"><a href="#调用方式-1" class="headerlink" title="调用方式"></a>调用方式</h3><p>要调用私有C函数，需要用<code>dlsym</code>，简单示意如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void *CoreTelephonyHandle = dlopen(&quot;/System/Library/Frameworks/CoreTelephony.framework/CoreTelephony&quot;, RTLD_LAZY);</div><div class="line"></div><div class="line">//用函数指针来调用私有C函数，用符号名从库里寻找函数地址</div><div class="line">CFTypeRef (*connectionCreateOnTargetQueue)(CFAllocatorRef, NSString *, dispatch_queue_t, void*) = dlsym(CoreTelephonyHandle, &quot;_CTServerConnectionCreateOnTargetQueue&quot;);</div><div class="line">int (*changeCellularPolicy)(CFTypeRef, NSString *, NSDictionary *) = dlsym(CoreTelephonyHandle, &quot;_CTServerConnectionSetCellularUsagePolicy&quot;);</div><div class="line"></div><div class="line">//使用设置app的bundle id进行伪装</div><div class="line">CFTypeRef connection = connectionCreateOnTargetQueue(kCFAllocatorDefault,@&quot;com.apple.Preferences&quot;,dispatch_get_main_queue(),NULL);</div><div class="line">//请求修改本app的网络权限为allowed，不会真的修改，只能触发系统更新一下相关的数据</div><div class="line">changeCellularPolicy(connection, @&quot;需要授权的app的bundle id&quot;, @&#123;@&quot;kCTCellularUsagePolicyDataAllowed&quot;:@YES&#125;);</div><div class="line"></div><div class="line">dlclose(CoreTelephonyHandle);</div></pre></td></tr></table></figure>
<p>注意，在声明connectionCreateOnTargetQueue和changeCellularPolicy函数指针时，参数类型要严格对应，如果类型错误，可能会导致系统对参数执行错误的内存管理，出现crash。<code>CTServerConnection</code>是私有的，是<code>CFTypeRef</code>的子类，所以这里可以用<code>CFTypeRef</code>来代替。</p>
<h3 id="出现了玄学"><a href="#出现了玄学" class="headerlink" title="出现了玄学"></a>出现了玄学</h3><p><code>_CTServerConnectionSetCellularUsagePolicy</code>函数的第二个参数是需要修改的app的bundle id。在测试时，发现传入这个参数时，对象必须是用字面量语法创建的<code>NSString</code>，例如<code>@&quot;com.who.testDemo&quot;</code>，当传入<code>[NSBundle mainBundle].bundleIdentifier</code>这种动态生成的<code>NSString</code>时，仍然会出现不弹出授权框的bug，也就是并没有修复成功。连续测试5-10次就能重现。</p>
<p>不过，用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSMutableString *bundleIdentifier = [NSMutableString stringWithString:@&quot;com.who&quot;];</div><div class="line">[bundleIdentifier appendString:@&quot;.testDemo&quot;];</div></pre></td></tr></table></figure>
<p>这样的字符串也没问题。相同点是最终都是来自字面量语法创建的<code>NSString</code>。</p>
<p>这个玄学问题目前还没有找到原因。</p>
<p>研究了一下字面量创建出的<code>NSString</code>，的确是有些特殊的。参考：<a href="http://bou.io/ConstantStringsInObjC.html" target="_blank" rel="external">Constant Strings in Objective-C</a>。它是一个<code>__NSCFConstantString</code>类型的字符串，在app的整个生命周期内，这个对象的内存都不会被释放。难道iOS的XPC对使用到的字符串还有要求？</p>
<p>时间有限，这个问题以后再研究吧。</p>
<h2 id="用控制台跟踪进程间通信"><a href="#用控制台跟踪进程间通信" class="headerlink" title="用控制台跟踪进程间通信"></a><a name="debug-trace"></a>用控制台跟踪进程间通信</h2><p>这几个私有API都用了进程间通信，要进行调试跟踪有点麻烦。</p>
<p>可以使用Mac上的控制台查看设备的实时log，寻找通信行为。打开控制台app，在左侧选择连接到Mac的iOS设备，就可以看到设备log了。</p>
<p>下面是调用了<code>_CTServerConnectionSetCellularUsagePolicy</code>之后的log，传入bundle id时用的是字面量创建的字符串：<br><img src="http://upload-images.jianshu.io/upload_images/1865432-e5eec32d03c2fa7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用字面量字符串传入bundle id"><br>高亮的那行是测试demo打的log，可以认为就是在这里调用了<code>_CTServerConnectionSetCellularUsagePolicy</code>，<br>可以看到，调用之后系统更新了本app的权限状态。<code>CommCenter</code>就是这几个私有API通信的对应进程，用于管理设备的网络。参考<a href="https://www.theiphonewiki.com/wiki//System/Library/Frameworks/CoreTelephony.Framework/Support/CommCenter" target="_blank" rel="external">CommCenter - The iPhone Wiki</a>。</p>
<p>下面是用<code>[NSBundle mainBundle].bundleIdentifier</code>传入<code>_CTServerConnectionSetCellularUsagePolicy</code>的第二个参数时的log：<br><img src="http://upload-images.jianshu.io/upload_images/1865432-87dfca01425cbad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用动态创建的字符串传入bundle id"><br>没有看到系统更新app权限的相关log，进程间通信可能失败了。因此可以确定，使用<code>_CTServerConnectionSetCellularUsagePolicy</code>时必须传入字面量语法创建的字符串。</p>
<h1 id="检查网络权限情况"><a href="#检查网络权限情况" class="headerlink" title="检查网络权限情况"></a>检查网络权限情况</h1><p>由于<code>dataActiveAndReachable</code>里面有异步操作，所以不能立即用<code>dlclose</code>卸载<code>FTServices.framework</code>。解决方法是监听到蜂窝权限开启时再卸载。</p>
<p><code>CoreTelephony</code>里的<code>CTCellularData</code>可以用来监测app的蜂窝网络权限，并且这不是个私有API。你也可以用它来帮助用户检测蜂窝权限是否被关闭，并给出提示，防止出现用户关了网络权限导致app无法联网的情况。</p>
<p><code>CTCellularData</code>的头文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, CTCellularDataRestrictedState) &#123;</div><div class="line">truekCTCellularDataRestrictedStateUnknown,//权限未知</div><div class="line">truekCTCellularDataRestricted,//蜂窝权限被关闭，有 网络权限完全关闭 or 只有WiFi权限 两种情况</div><div class="line">truekCTCellularDataNotRestricted//蜂窝权限开启</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface CTCellularData : NSObject</div><div class="line">///权限更改时的回调</div><div class="line">@property (copy, nullable) CellularDataRestrictionDidUpdateNotifier cellularDataRestrictionDidUpdateNotifier;</div><div class="line">///当前的蜂窝权限</div><div class="line">@property (nonatomic, readonly) CTCellularDataRestrictedState restrictedState;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &lt;CoreTelephony/CTCellularData.h&gt;</div><div class="line"></div><div class="line">CTCellularData *cellularDataHandle = [[CTCellularData alloc] init];</div><div class="line">cellularDataHandle.cellularDataRestrictionDidUpdateNotifier = ^(CTCellularDataRestrictedState state) &#123;</div><div class="line">        //蜂窝权限更改时的回调</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>使用时需要注意的关键点：</p>
<ul>
<li><code>CTCellularData</code>只能检测蜂窝权限，不能检测WiFi权限。</li>
<li>一个<code>CTCellularData</code>实例新建时，<code>restrictedState</code>是<code>kCTCellularDataRestrictedStateUnknown</code>，之后在<code>cellularDataRestrictionDidUpdateNotifier</code>里会有一次回调，此时才能获取到正确的权限状态。</li>
<li>当用户在设置里更改了app的权限时，<code>cellularDataRestrictionDidUpdateNotifier</code>会收到回调，如果要停止监听，必须将<code>cellularDataRestrictionDidUpdateNotifier</code>设置为<code>nil</code>。</li>
<li>赋值给<code>cellularDataRestrictionDidUpdateNotifier</code>的block并不会自动释放，即便你给一个局部变量的<code>CTCellularData</code>实例设置监听，当权限更改时，还是会收到回调，所以记得将block置<code>nil</code>。</li>
</ul>
<h1 id="检测国行机型和是否有蜂窝功能"><a href="#检测国行机型和是否有蜂窝功能" class="headerlink" title="检测国行机型和是否有蜂窝功能"></a>检测国行机型和是否有蜂窝功能</h1><p>非国行机型，以及没有蜂窝功能的设备是不需要进行修复的。因此也要寻找相关的私有API进行检测。</p>
<p>用到的私有API如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//Image: /System/Library/PrivateFrameworks/AppleAccount.framework/AppleAccount</div><div class="line"></div><div class="line">@interface AADeviceInfo : NSObject</div><div class="line">///是否有蜂窝功能</div><div class="line">- (bool)hasCellularCapability;</div><div class="line">///设备的区域代码，例如国行机就是CH</div><div class="line">- (id)regionCode;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>头文件参考：<a href="https://github.com/JaviSoto/iOS10-Runtime-Headers/blob/master/PrivateFrameworks/AppleAccount.framework/AADeviceInfo.h" target="_blank" rel="external">AADeviceInfo.h</a></p>
<p>使用方式和<code>FTServices.framework</code>类似，不再重复。</p>
<h1 id="测试修复是否成功的方法"><a href="#测试修复是否成功的方法" class="headerlink" title="测试修复是否成功的方法"></a>测试修复是否成功的方法</h1><p>我的测试方式是每次运行都修改项目的<code>bundle identifier</code>和<code>display name</code>，让系统每次都把它当做一个新app，使用<code>Release</code>模式，测试是否每次都能够弹出授权框。由于需要不断修改<code>bundle identifier</code>，写了个脚本在每次build时自动运行，会自动累加几个地方的<code>bundle identifier</code>后面的数字。demo里已经附带了这个脚本。</p>
<p>你也可以测试一下不执行修复时，进行联网操作是否会弹出授权框。我的测试结果是大约运行5-10次时，就会出现不弹出授权框的bug。需要把项目改为<code>Release</code>模式才能出现，<code>Debug</code>模式下不会出bug。</p>
<p>注意，由于build后自动累加的关系，<code>ZIKCellularAuthorization.h</code>里的<code>AppBundleIdentifier</code>是下一次app运行时的值。如果你觉得这个脚本把你搞晕了，可以在<code>Build Phases/Run Script</code>里关掉，在<code>sh ${PROJECT_DIR}/IncreaseBundleId.sh</code>前面加个<code>#</code>注释掉就行了。</p>
<p>没有测试覆盖安装同一个<code>bundle identifier</code>的app，或者更新了版本号的app是否也会出现这个bug，现在是认为只有第一次安装时才会出现bug。</p>
<h1 id="工具代码和Demo"><a href="#工具代码和Demo" class="headerlink" title="工具代码和Demo"></a>工具代码和Demo</h1><p>地址在<a href="https://github.com/Zuikyo/ZIKCellularAuthorization" target="_blank" rel="external">ZIKCellularAuthorization</a>，用到的私有API已经经过混淆。测试前记得先把<code>Build Configuration</code>改为<code>Release</code>模式。有帮助请点个Star~</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.jianshu.com/p/6cbde1b8b922" target="_blank" rel="external">iOS 10 的坑：新机首次安装 app，请求网络权限“是否允许使用数据”</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22738261" target="_blank" rel="external">iOS 10 不提示「是否允许应用访问数据」，导致应用无法使用的解决方案</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;iOS 10有一个系统bug：app在第一次安装时，第一次联网操作会弹出一个授权框，提示”是否允许xxx访问数据？”。而有时
    
    </summary>
    
      <category term="私有API" scheme="http://zuikyo.github.io/categories/%E7%A7%81%E6%9C%89API/"/>
    
      <category term="bug修复" scheme="http://zuikyo.github.io/categories/%E7%A7%81%E6%9C%89API/bug%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS Crash分析必备：符号化系统库方法</title>
    <link href="http://zuikyo.github.io/2016/12/18/iOS%20Crash%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%BF%85%E5%A4%87%EF%BC%9A%E7%AC%A6%E5%8F%B7%E5%8C%96%E7%B3%BB%E7%BB%9F%E5%BA%93%E6%96%B9%E6%B3%95/"/>
    <id>http://zuikyo.github.io/2016/12/18/iOS Crash日志分析必备：符号化系统库方法/</id>
    <published>2016-12-17T20:52:00.000Z</published>
    <updated>2018-03-29T02:59:04.130Z</updated>
    
    <content type="html"><![CDATA[<p>如果你有过分析iOS崩溃日志的经验，一定经常看到日志里出现很多<code>&lt;redacted&gt;</code>的字段。这篇文章就是帮助开发者将这些字段符号化为对应的系统库方法名。</p>
<p>如果你已经掌握了这方面的知识，就直接去这里<a href="https://github.com/Zuikyo/iOS-System-Symbols" target="_blank" rel="external">iOS-System-Symbols</a>，下载我整理好的系统库符号文件吧。</p>
<h2 id="符号化的作用"><a href="#符号化的作用" class="headerlink" title="符号化的作用"></a>符号化的作用</h2><p>当获取到app的crash日志时，第一步就是将其符号化。作用是把日志堆栈中的方法调用显示出来，对于来自app内部的方法，还能直接给出方法对应.m文件的所在行。</p>
<p>符号化前（这里项目的<code>Build Settings</code>里的<code>Strip Style</code>设为了<code>Debugging Symbols</code>，所以这里能直接看到<code>MyApp</code>的方法名。更多和symbol相关的设置，请看<a href="http://www.jianshu.com/p/11710e7ab661" target="_blank" rel="external">这里</a>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread 7:</div><div class="line">0   libsystem_kernel.dylib          0x000000018efb416c 0x18efb3000 + 4460 (mach_msg_trap + 8)</div><div class="line">1   libsystem_kernel.dylib          0x000000018efb3fdc 0x18efb3000 + 4060 (mach_msg + 72)</div><div class="line">2   MyApp                           0x000000010091e558 0x1000bc000 + 8791384 (ksmachexc_i_handleExceptions + 148)</div><div class="line">3   libsystem_pthread.dylib         0x000000018f097860 0x18f094000 + 14432 (&lt;redacted&gt; + 240)</div><div class="line">4   libsystem_pthread.dylib         0x000000018f097770 0x18f094000 + 14192 (_pthread_start + 284)</div></pre></td></tr></table></figure>
<p>符号化后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread 7:</div><div class="line">0   libsystem_kernel.dylib          0x000000018efb416c mach_msg_trap + 8</div><div class="line">1   libsystem_kernel.dylib          0x000000018efb3fdc mach_msg + 72</div><div class="line">2   MyApp                           0x000000010091e558 ksmachexc_i_handleExceptions (KSCrashSentry_MachException.c:233)</div><div class="line">3   libsystem_pthread.dylib         0x000000018f097860 _pthread_body + 240</div><div class="line">4   libsystem_pthread.dylib         0x000000018f097770 _pthread_body + 0</div></pre></td></tr></table></figure>
<p>可以发现，frame 3里<code>libsystem_pthread.dylib</code>的<code>&lt;redacted&gt;</code>变成了<code>_pthread_body</code>，frame 2里<code>MyApp</code>的<code>ksmachexc_i_handleExceptions</code>变成了更为完整的<code>ksmachexc_i_handleExceptions (KSCrashSentry_MachException.c:233)</code>，直接给出了方法及其所在文件和行数。</p>
<p>详细的符号化方法，请参考<a href="http://wufawei.com/2014/03/symbolicating-ios-crash-logs/" target="_blank" rel="external">符号化iOS Crash文件的3种方法</a>。这里就不重复了。</p>
<p>需要注意的是，很多时候，crash日志里并不会有MyApp的调用，而全都是系统库的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</div><div class="line">Thread 0 Crashed:</div><div class="line">0   libobjc.A.dylib                 0x000000018b816f30 0x18b7fc000 + 110384 (objc_msgSend + 16)</div><div class="line">1   UIKit                           0x0000000192e0a79c 0x192c05000 + 2119580 (&lt;redacted&gt; + 72)</div><div class="line">2   UIKit                           0x0000000192c4db48 0x192c05000 + 297800 (&lt;redacted&gt; + 312)</div><div class="line">3   UIKit                           0x0000000192c4d988 0x192c05000 + 297352 (&lt;redacted&gt; + 160)</div><div class="line">4   QuartzCore                      0x00000001900d6404 0x18ffc5000 + 1119236 (&lt;redacted&gt; + 260)</div><div class="line">5   libdispatch.dylib               0x000000018bc551c0 0x18bc54000 + 4544 (&lt;redacted&gt; + 16)</div><div class="line">6   libdispatch.dylib               0x000000018bc59d6c 0x18bc54000 + 23916 (_dispatch_main_queue_callback_4CF + 1000)</div><div class="line">7   CoreFoundation                  0x000000018cd79f2c 0x18cc9d000 + 905004 (&lt;redacted&gt; + 12)</div><div class="line">8   CoreFoundation                  0x000000018cd77b18 0x18cc9d000 + 895768 (&lt;redacted&gt; + 1660)</div><div class="line">9   CoreFoundation                  0x000000018cca6048 0x18cc9d000 + 36936 (CFRunLoopRunSpecific + 444)</div><div class="line">10  GraphicsServices                0x000000018e729198 0x18e71d000 + 49560 (GSEventRunModal + 180)</div><div class="line">11  UIKit                           0x0000000192c80628 0x192c05000 + 505384 (&lt;redacted&gt; + 684)</div><div class="line">12  UIKit                           0x0000000192c7b360 0x192c05000 + 484192 (UIApplicationMain + 208)</div><div class="line">13  MyApp                           0x0000000100016e54 0x100004000 + 77396 (_mh_execute_header + 77396)</div><div class="line">14  libdyld.dylib                   0x000000018bc885b8 0x18bc84000 + 17848 (&lt;redacted&gt; + 4)</div></pre></td></tr></table></figure>
<p>这时候就必须符号化系统库了。符号化后的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</div><div class="line">Thread 0 Crashed:</div><div class="line">0   libobjc.A.dylib                 0x000000018b816f30 objc_msgSend + 16</div><div class="line">1   UIKit                           0x0000000192e0a79c -[UISearchDisplayController _sendDelegateDidBeginDidEndSearch] + 72</div><div class="line">2   UIKit                           0x0000000192c4db48 -[UIViewAnimationState sendDelegateAnimationDidStop:finished:] + 312</div><div class="line">3   UIKit                           0x0000000192c4d988 -[UIViewAnimationState animationDidStop:finished:] + 160</div><div class="line">4   QuartzCore                      0x00000001900d6404 CA::Layer::run_animation_callbacks(void*) + 260</div><div class="line">5   libdispatch.dylib               0x000000018bc551c0 _dispatch_client_callout + 16</div><div class="line">6   libdispatch.dylib               0x000000018bc59d6c _dispatch_main_queue_callback_4CF + 1000</div><div class="line">7   CoreFoundation                  0x000000018cd79f2c __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 12</div><div class="line">8   CoreFoundation                  0x000000018cd77b18 __CFRunLoopRun + 1660</div><div class="line">9   CoreFoundation                  0x000000018cca6048 CFRunLoopRunSpecific + 444</div><div class="line">10  GraphicsServices                0x000000018e729198 GSEventRunModal + 180</div><div class="line">11  UIKit                           0x0000000192c80628 -[UIApplication _run] + 684</div><div class="line">12  UIKit                           0x0000000192c7b360 UIApplicationMain + 208</div><div class="line">13  MyApp                           0x0000000100016e54 main (main.m:15)</div><div class="line">14  libdyld.dylib                   0x000000018bc885b8 start + 4</div></pre></td></tr></table></figure>
<p>可以看出是<code>UISearchController</code>的<code>delegate</code>导致的问题，检查一下就发现<code>UISearchDisplayController</code>的<code>delegate</code>是<code>assign</code>的，是由于点击搜索条的同时pop了界面导致的crash。</p>
<p>从这里可以发现，符号化系统库是很有必要的。</p>
<p>##如何符号化系统库</p>
<p>符号化自己app的方法名，需要编译ipa时生成的dySYM文件。而要将系统库的<code>&lt;redacted&gt;</code>符号化为完整的方法名，也需要系统库的符号文件。</p>
<h3 id="1-匹配对应的符号文件版本"><a href="#1-匹配对应的符号文件版本" class="headerlink" title="1. 匹配对应的符号文件版本"></a>1. 匹配对应的符号文件版本</h3><p>系统库符号文件不是通用的，而是对应crash所在设备的系统版本和CPU型号的。</p>
<p>crash日志中有这样两个信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Code Type:       ARM-64</div><div class="line">OS Version:      iOS 10.2 (14C82)</div></pre></td></tr></table></figure>
<p><code>Code Type</code>表示此设备的CPU为<code>armv7</code>、<code>armv7s</code>还是<code>arm64</code>。</p>
<p><code>OS Version</code>表示此设备的系统版本号，括号中的字符串代表了此系统的build号。可以在这里查找build号：<a href="https://en.wikipedia.org/wiki/IOS_SDK" target="_blank" rel="external">iOS SDK</a>，<a href="https://en.wikipedia.org/wiki/IOS_version_history#iOS_10" target="_blank" rel="external">iOS version history</a>。</p>
<h3 id="2-将对应版本的符号文件放到指定目录"><a href="#2-将对应版本的符号文件放到指定目录" class="headerlink" title="2. 将对应版本的符号文件放到指定目录"></a>2. 将对应版本的符号文件放到指定目录</h3><p>这时候，把获取到的对应版本的符号文件放到Mac的<code>~/Library/Developer/Xcode/iOS DeviceSupport</code>目录下，再使用<a href="http://wufawei.com/2014/03/symbolicating-ios-crash-logs/" target="_blank" rel="external">符号化iOS Crash文件的3种方法</a>里提到的Xcode自带的符号化工具<code>symbolicatecrash</code>进行符号化。这个工具会自动搜索系统库符号文件。</p>
<h2 id="获取系统符号文件的4个方法"><a href="#获取系统符号文件的4个方法" class="headerlink" title="获取系统符号文件的4个方法"></a>获取系统符号文件的4个方法</h2><h3 id="从真机上获取"><a href="#从真机上获取" class="headerlink" title="从真机上获取"></a>从真机上获取</h3><p>大部分系统库符号文件只能从真机上获取，苹果也没有提供下载。<br>当你用Xcode第一次连接某台设备进行真机调试时，会看到Xcode显示<code>Processing symbol files</code>，这时候就是在拷贝真机上的符号文件到Mac系统的<code>/Users/xxx/Library/Developer/Xcode/iOS DeviceSupport</code>目录下。</p>
<p>目录下的<code>10.2(14C82)</code>这样的文件夹就是对应的符号文件，通常都有1-3GB的大小，很占用空间，动不动就累积成3、40GB。很多讲清理Mac垃圾文件的教程都会说要删除这个目录下的文件，真是坑爹。正确做法是做成压缩包保存到外部硬盘里，需要符号化的时候再重新解压到此目录。</p>
<h3 id="寻找苹果官方的下载地址"><a href="#寻找苹果官方的下载地址" class="headerlink" title="寻找苹果官方的下载地址"></a>寻找苹果官方的下载地址</h3><p>之前watch的调试出现bug时，有人找出过几个watch的符号文件下载地址。见<a href="https://forums.developer.apple.com/thread/3380" target="_blank" rel="external">No symbols for paired Apple Watch</a>。<br>但是我尝试按照对应的命名格式，并没有找到iOS符号文件的下载地址。</p>
<h3 id="从已解密的固件中提取符号文件"><a href="#从已解密的固件中提取符号文件" class="headerlink" title="从已解密的固件中提取符号文件"></a>从已解密的固件中提取符号文件</h3><p>某些已经被破解的固件可以直接提取系统文件，但是未破解的固件（较新的固件和<code>arm64</code>的固件），无法用这种方式获取。</p>
<p>固件解密步骤：</p>
<p>1.下载对应版本的.ipsw固件，直接解压，解压后里面有几个<code>.dmg</code>格式的镜像文件，最大的<code>.dmg</code>文件就是系统镜像。<br>2.从<a href="https://www.theiphonewiki.com/wiki/Firmware_Keys" target="_blank" rel="external">Firmware_Keys</a>找到对应固件的解密key（页面上<code>Root Filesystem</code>字段的key）。<br>3.用一个<code>dmg</code>工具进行解密，<a href="http://modmyi.com/attachments/forums/general-verizon-sprint-cdma-iphone-chat/643832d1372672304-cant-decrypt-ios-7-beta-help-dmg.zip" target="_blank" rel="external">下载地址</a>。使用方式：<code>cd</code>到解压后的ipsw文件夹，执行<code>./dmg extract xxx-xxxx-xxx.dmg dec.dmg -k &lt;key&gt;</code>。<code>extract</code>后面跟两个参数，分别是系统镜像dmg的名字和解密后的文件名，-k 后面填写第2步获取到的key，如果key不对，解密会失败。<br>4.等待。最终会生成一个<code>dec.dmg</code>文件，双击打开即可加载系统镜像。</p>
<p>提取符号文件方法：<br>参考<a href="http://crash.163.com/#news/!newsId=31" target="_blank" rel="external">聊聊从iOS固件提取系统库符号</a>中的<code>二、系统库符号提取</code>部分。</p>
<p><strong>update</strong>:目前大多数固件都能解密了，而且iOS 10之后苹果不再进行加密，因此之后都可以用这个方式获取符号文件。</p>
<h3 id="下载旧版本Xcode，提取SDK"><a href="#下载旧版本Xcode，提取SDK" class="headerlink" title="下载旧版本Xcode，提取SDK"></a>下载旧版本Xcode，提取SDK</h3><p>旧版本的Xcode里包含了对应的iPhoneSDK，可以从中获得符号文件。<br>路径是<code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/</code>。里面的<code>System/Library</code>里就可以看到framework，而且同时包含了<code>armv7</code>,<code>armv7s</code>,<code>arm64</code>3个平台的版本。</p>
<p><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/version.plist</code>可以查看是哪个版本。把<code>iPhoneOS.sdk</code>文件夹的名字改成对应的<code>CFBundleVersion (ProductBuildVersion)</code>格式，然后在里面加一层<code>Symbols</code>子文件夹，把<code>System</code>,<code>Library</code>,<code>usr</code>都放进<code>Symbols</code>里，就可以和其他符号文件一样使用了。</p>
<p>但是当iOS版本只包含了bug修复，而没有改变API，Xcode就不会有附带对应的SDK，还是需要从真机上获取。而且从Xcode7开始，苹果用<code>tbd</code>文件代替了真机符号文件，所以这个方法也失效了。<br>参考：<a href="http://stackoverflow.com/questions/14941773/xcode-software-image-for-user-ios-in-order-to-symbolicate-ios-calls" target="_blank" rel="external">Xcode software image for user iOS in order to symbolicate iOS calls</a>, <a href="http://stackoverflow.com/a/28408052/6380485" target="_blank" rel="external">Missing iOS symbols at “~/Library/Developer/Xcode/iOS DeviceSupport”</a>。</p>
<h2 id="获取符号文件的难题"><a href="#获取符号文件的难题" class="headerlink" title="获取符号文件的难题"></a>获取符号文件的难题</h2><p>这个时候，游戏就开始了：</p>
<ul>
<li>很多时候crash日志只给出了系统的调用栈，不能直接定位到自己app的代码，因此需要符号化系统库。</li>
<li>用户的crash来自各种系统版本，需要对应版本的系统符号文件才能符号化。</li>
<li>系统库符号文件只能从真机上获取，苹果没有提供下载。</li>
<li>从<code>iOS 7.0(11A465)</code>到<code>iOS 10.2(14C92)</code>一共有50个build版本，公司的测试机是不会覆盖到这么变态的完整度的。</li>
<li>同一个版本，有时候会给iPhone和iPad、甚至6和6s提供不同build的固件。</li>
<li>某些版本是某些机子的特供版，例如<code>10.0.3(14A551)</code>是iPhone 7和 7 Plus独有的，这就更加大了收集难度。</li>
<li>同一个iOS版本可能有多个build，例如<code>10.1(14B72)</code>和<code>10.1(14B72c)</code>，苹果觉得更新幅度太小，就没有提升版本号。</li>
<li>除了build号的区别，符号文件在不同CPU平台上也有区别，意味着来自4s(<code>armv7</code>)和6s(<code>arm64</code>)的符号文件，即便build号是一样的，也无法通用。所以50个build号又要翻倍，达到了88个，所以精确来说我只是收集了（63/88）的进度。幸运的是，<code>arm64</code>机型的系统库里附带了<code>armv7s</code>。</li>
</ul>
<p>规则好厉害的收集游戏啊。收集品其实还有稀有度的区别，其中最厉害的应该是<code>10.0</code>，这是iPhone 7和7 Plus独有的出厂系统，而且没有固件可以下载，因此即便有iPhone 7也不能通过刷机来得到<code>10.0</code>。</p>
<p>其实我一直很奇怪为什么很少见到开发者抱怨找不到系统符号文件，从而召集大家进行收集并分享，猜测可能的原因是：</p>
<ul>
<li>懒。遇到无法符号化的问题，没有去解决。</li>
<li>有些公司可能很早就开始对crash日志自动符号化了，因此很早就开始收集符号文件。只要一直跟着苹果的每一个版本升级，收集起来还是挺简单的。而这些资源，开发者并不会注意到可以共享出来。</li>
<li>crash收集和符号化使用的是第三方服务，第三方平台会帮助符号化系统库。</li>
</ul>
<p>但是我找了一下，没有找到一家明确声明了能够符号化所有系统库的第三方平台。从腾讯的Bugly论坛里也能发现，有些系统方法并没有符号化出来，系统库是缺失的。（<strong>update</strong>：找到了一个国外的平台，在<a href="http://stackoverflow.com/questions/12058901/ios-system-symbol-symbolication-service" target="_blank" rel="external">stack overflow</a>上说能符号化所有版本的系统库，但是是收费服务，我也没有测试）</p>
<p>在公司小组里，大部分时候都是我来分析crash日志，所以当遇到缺少系统符号文件的情况，就会十分无奈。很多时候，没有符号化的crash日志根本无法提供有用信息。</p>
<h2 id="系统符号文件下载地址"><a href="#系统符号文件下载地址" class="headerlink" title="系统符号文件下载地址"></a>系统符号文件下载地址</h2><h3 id="暴力收集"><a href="#暴力收集" class="headerlink" title="暴力收集"></a>暴力收集</h3><p>收集不全一直让我很不爽。之前搜刮了组内的测试机，只收集到了有限的几个（感谢无私提供iPhone 7让我刷机降级的同事）。终于，这周末特意跑去了一趟二手机市场寻找旧版本的设备来拷贝，总算是收集得完整了一点，但是也花了我121块钱。</p>
<p>心情总算愉悦了。</p>
<p>其中大部分都是拷贝自<code>arm64</code>设备的，<code>armv7</code>的符号文件收集我是放弃了。有哪位大侠有兴趣把这个游戏玩通关的吗？还有 tvOS 和 watchOS的符号，我也放弃了。<br>(update:又花了些时间从Xcode的SDK和固件里提取了<code>armv7s</code>和<code>armv7</code>的固件，现在只剩下几个<code>arm64</code>的版本了)。</p>
<p>整理了一下传到了网盘，地址见下方，有需要的去下载吧。</p>
<h3 id="目前还缺少的符号文件"><a href="#目前还缺少的符号文件" class="headerlink" title="目前还缺少的符号文件"></a>目前还缺少的符号文件</h3><p>通过各种方式，目前已经收集得差不多了，只剩下最后一个<code>10.0(14A346)</code>版本没有得到。如果哪位小伙伴有这个版本，可以分享一下。</p>
<p>分享可以直接贴下载地址，也可以提交到这个github项目<a href="https://github.com/Zuikyo/iOS-System-Symbols" target="_blank" rel="external">iOS-System-Symbols</a>。如果我得到了新的符号文件，也会在这个项目里更新。</p>
<table>
<thead>
<tr>
<th>缺失符号的版本</th>
<th>缺失的CPU版本</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>10.0(14A346)</td>
<td>arm64</td>
<td>iPhone 7 和 7 Plus独占，出厂自带系统</td>
</tr>
</tbody>
</table>
<h3 id="网盘下载地址"><a href="#网盘下载地址" class="headerlink" title="网盘下载地址"></a>网盘下载地址</h3><p>下载地址请见这个项目：<a href="https://github.com/Zuikyo/iOS-System-Symbols" target="_blank" rel="external">iOS-System-Symbols</a>。如果我得到了新的符号文件，会在这个项目里更新。</p>
<p>我把里面的那几个<code>dyld_shared_cache_xxxx</code>大文件单独拿出来了，目的是减小压缩包大小。如果只是符号化的话，用不到这几个文件，只是在真机调试的时候才需要。</p>
<h3 id="符号文件版本列表"><a href="#符号文件版本列表" class="headerlink" title="符号文件版本列表"></a>符号文件版本列表</h3><p>这些是我已经收集到的符号文件，包括了对应的CPU信息。iOS10系统开始不支持<code>armv7</code>的机器。但是iOS9以下还是支持<code>armv7</code>的。</p>
<p>查看是否带有对应CPU架构的符号文件的方式：到<code>10.2 (14C92)/Symbols/System/Library/Caches/com.apple.dyld</code>这样的目录下，会有对应的<code>dyld_shared_cache_arm64</code>，<code>dyld_shared_cache_armv7s</code>，<code>dyld_shared_cache_armv7</code>文件，如果缺失了，就说明对应的CPU架构符号文件还不存在。（经过试验，这几个大文件并不影响符号化，只是在真机调试的时候才有用，因此如果嫌太占用空间，可以删去）。</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>已收集到的CPU版本</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>11.2.6 (15D100)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>11.2.5 (15D60)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>11.2.2 (15C202)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>11.2.1 (15C153)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>11.2 (15C114)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td><strong>11.2 (15C113)</strong></td>
<td><strong>none</strong></td>
<td>苹果在发布了15C114之后，又发布了一个低版本的15C113，之后又移除了15C113的下载地址，因此这个固件目前无法下载。应该只是误发布，可以忽略这个版本</td>
</tr>
<tr>
<td>11.1.2 (15B202)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>11.1.1 (15B150)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>11.1 (15B101)</td>
<td>arm64</td>
<td>iPad Pro2 12.9-inch and iPad Pro 10.5-inch only</td>
</tr>
<tr>
<td>11.1 (15B93)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>11.0.3 (15A432)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>11.0.2 (15A421)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>11.0.1 (15A403)</td>
<td>arm64</td>
<td>iPhone 8 and 8 Plus only</td>
</tr>
<tr>
<td>11.0.1 (15A402)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>11.0 (15A372)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>10.3.3 (14G60)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.3.2 (14F91)</td>
<td>arm64,armv7s</td>
<td>iPad mini4(Cellular) only</td>
</tr>
<tr>
<td>10.3.2 (14F90)</td>
<td>arm64,armv7s</td>
<td>iPad (5th gen) only</td>
</tr>
<tr>
<td>10.3.2 (14F89)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.3.1 (14E304)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.3 (14E277)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.2.1 (14D27)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.2 (14C92)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.1.1 (14B150)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.1.1 (14B100)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.1 (14B72c)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.1 (14B72)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.0.3 (14A551)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.0.2 (14A456)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.0.1 (14A403)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td><strong>10.0(14A346)</strong></td>
<td><strong>none</strong></td>
<td>iPhone 7 和 7 Plus独占，出厂自带系统</td>
</tr>
<tr>
<td>9.3.5 (13G36)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.3.4 (13G35)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.3.3 (13G34)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.3.2(13F72)</td>
<td>arm64,armv7s</td>
<td>iPad Pro 9.7寸独占，修复了变砖的问题</td>
</tr>
<tr>
<td>9.3.2 (13F69)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.3.1 (13E238)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.3(13E237)</td>
<td>armv7s,armv7</td>
<td>5s和更旧机型独占，修复了不能激活的问题</td>
</tr>
<tr>
<td>9.3(13E236)</td>
<td>armv7</td>
<td>iPad2独占，修复了不能激活的问题</td>
</tr>
<tr>
<td>9.3(13E234)</td>
<td>arm64,armv7s</td>
<td>6s, 6s Plus and iPad Pro 9.7寸独占</td>
</tr>
<tr>
<td>9.3 (13E233)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.2.1 (13D20)</td>
<td>arm64,armv7s</td>
<td>iPhone 6 和更新的机型独占</td>
</tr>
<tr>
<td>9.2.1 (13D15)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.2 (13C75)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.1 (13B143)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.0.2(13A452)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.0.1(13A404)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.0 (13A344)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.4.1 (12H321)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.4 (12H143)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.3 (12F70)</td>
<td>arm64,armv7s,armv7</td>
<td>iPhone独占</td>
</tr>
<tr>
<td>8.3 (12F69)</td>
<td>arm64,armv7s,armv7</td>
<td>iPad独占</td>
</tr>
<tr>
<td>8.2 (12D508)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.1.3 (12B466)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.1.2 (12B440)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.1.1 (12B436)</td>
<td>arm64,armv7s</td>
<td>iPhone 6 和更新的机型独占</td>
</tr>
<tr>
<td>8.1.1 (12B435)</td>
<td>armv7s,armv7</td>
<td>5s和更旧机型独占</td>
</tr>
<tr>
<td>8.1 (12B411)</td>
<td>arm64,armv7s,armv7</td>
<td>iPhone独占</td>
</tr>
<tr>
<td>8.1 (12B410)</td>
<td>arm64,armv7s,armv7</td>
<td>iPad独占</td>
</tr>
<tr>
<td>8.0.2 (12A405)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.0.1(12A402)</td>
<td>armv7s,armv7</td>
<td><code>8.0.1</code>有导致变砖的bug，发布后很快就停止推送了</td>
</tr>
<tr>
<td>8.0 (12A366)</td>
<td>arm64,armv7s</td>
<td>6 Plus独占</td>
</tr>
<tr>
<td>8.0 (12A365)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.1.2 (11D257)</td>
<td>armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.1.1 (11D201)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.1 (11D167)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.6 (11B651)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.4 (11B554a)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.3 (11B511)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.2(11A501)</td>
<td>armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.1(11A470a)</td>
<td>armv7s</td>
<td>5s 和 5c 独占</td>
</tr>
<tr>
<td>7.0(11A465)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="机型对应CPU架构"><a href="#机型对应CPU架构" class="headerlink" title="机型对应CPU架构"></a>机型对应CPU架构</h3><table>
<thead>
<tr>
<th>CPU</th>
<th>机型</th>
</tr>
</thead>
<tbody>
<tr>
<td>armv6</td>
<td>iPhone, iPhone2, iPhone3G, iPod Touch 1 and 2</td>
</tr>
<tr>
<td>armv7</td>
<td>iPhone3GS, iPhone4, iPhone4S，iPad, iPad2, iPad3(The New iPad), iPad mini，iPod Touch 3G, iPod Touch4, iPod Touch5</td>
</tr>
<tr>
<td>armv7s</td>
<td>iPhone5, iPhone5C, iPad4(iPad with Retina Display)</td>
</tr>
<tr>
<td>arm64</td>
<td>iPhone5S, iPad Air, iPad mini2(iPad mini with Retina Display), iPhone6, iPhone6s, iPhone7, iPhone7s and any new device in the future</td>
</tr>
</tbody>
</table>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>最后再次呼吁一下，如果谁有上面缺失的符号文件，就请共享一下吧。虽然只是做一点微小的工作，但是能够有很大帮助。</p>
<p>不觉得填满上面那个列表会很爽吗？</p>
<p><strong>update</strong>：现在基本上已经收集完了。</p>
<h3 id="额外提示"><a href="#额外提示" class="headerlink" title="额外提示"></a>额外提示</h3><p>其实这些符号文件就是真机上的系统库，包括了完整的系统库二进制文件。有时候要反编译某些系统framework，但是模拟器SDK里没有对应的framework（比如只有真机上才有的<code>CoreMotion.framework</code>），就可以在这些真机上的系统库里找到了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.jianshu.com/p/11710e7ab661" target="_blank" rel="external">http://www.jianshu.com/p/11710e7ab661</a></li>
<li><a href="http://wufawei.com/2014/03/symbolicating-ios-crash-logs/" target="_blank" rel="external">符号化iOS Crash文件的3种方法</a></li>
<li><a href="https://en.wikipedia.org/wiki/IOS_SDK" target="_blank" rel="external">iOS SDK</a></li>
<li><a href="https://en.wikipedia.org/wiki/IOS_version_history#iOS_10" target="_blank" rel="external">iOS version history</a></li>
<li><a href="https://forums.developer.apple.com/thread/3380" target="_blank" rel="external">No symbols for paired Apple Watch</a></li>
<li><a href="http://crash.163.com/#news/!newsId=31" target="_blank" rel="external">聊聊从iOS固件提取系统库符号</a></li>
<li><a href="http://stackoverflow.com/questions/14941773/xcode-software-image-for-user-ios-in-order-to-symbolicate-ios-calls" target="_blank" rel="external">Xcode software image for user iOS in order to symbolicate iOS calls</a></li>
<li><a href="http://stackoverflow.com/a/28408052/6380485" target="_blank" rel="external">Missing iOS symbols at “~/Library/Developer/Xcode/iOS DeviceSupport”</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你有过分析iOS崩溃日志的经验，一定经常看到日志里出现很多&lt;code&gt;&amp;lt;redacted&amp;gt;&lt;/code&gt;的字段。这篇文章就是帮助开发者将这些字段符号化为对应的系统库方法名。&lt;/p&gt;
&lt;p&gt;如果你已经掌握了这方面的知识，就直接去这里&lt;a href=&quot;https
    
    </summary>
    
      <category term="调试技巧" scheme="http://zuikyo.github.io/categories/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    
      <category term="crash分析" scheme="http://zuikyo.github.io/categories/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/crash%E5%88%86%E6%9E%90/"/>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>约束冲突调试工具：解决iOS7调试难题</title>
    <link href="http://zuikyo.github.io/2016/12/13/%E7%BA%A6%E6%9D%9F%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <id>http://zuikyo.github.io/2016/12/13/约束冲突调试工具/</id>
    <published>2016-12-13T13:43:29.000Z</published>
    <updated>2017-05-03T08:35:22.900Z</updated>
    
    <content type="html"><![CDATA[<p><em>功能</em>：</p>
<ul>
<li>在非调试模式下，获取出错的具体约束。</li>
<li>监测约束冲突，并获取出错的view和viewController。</li>
<li>监测iOS7上layoutSubViews导致的crash问题</li>
</ul>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><h3 id="iOS7对Auto-Layout的支持问题"><a href="#iOS7对Auto-Layout的支持问题" class="headerlink" title="iOS7对Auto Layout的支持问题"></a>iOS7对Auto Layout的支持问题</h3><ul>
<li>iOS7的约束有一些奇怪的bug，对Auto Layout支持并不完美。</li>
<li>在出现约束冲突时，系统会尝试修复约束。iOS7和iOS8的修复结果有可能不一样。</li>
<li>如果view的<code>layoutSubviews</code>里没有调用<code>[super layoutSubviews]</code>，那么在往这个view上添加子view时，在iOS7以下会crash。例如<code>UITableView</code>，<code>UITableViewCell</code>。</li>
</ul>
<h3 id="iOS7的调试问题"><a href="#iOS7的调试问题" class="headerlink" title="iOS7的调试问题"></a>iOS7的调试问题</h3><ul>
<li>Xcode7虽然不能使用iOS7模拟器调试，但是还能使用iOS7真机调试。而Xcode8已经连iOS7的真机调试都不支持了。</li>
<li>Xcode8中编辑过的xib文件在Xcode7上会有兼容性问题，需要手动删除xib中的<code>&lt;capability name=&quot;documents saved in the Xcode 8 format&quot; minToolsVersion=&quot;8.0&quot;/&gt;</code>这一行才能在Xcode7上编译。如果要继续使用Xcode7调试，就需要修改这些xib，十分麻烦。</li>
<li>内网开发时，无法进行真机调试，如果要用模拟器调试，需要另一台低版本的Mac OSX系统的机子以安装Xcode6，同时也会遇到Xcode的兼容性问题，因此遇到iOS7的约束问题十分麻烦，如果没有环境的话只能靠猜。</li>
<li>约束冲突导致的crash往往在堆栈上无法得到有用的信息，因为是在系统库里crash，无法直接看出是哪个界面的约束出错。如果是在Xcode里调试，还能使用llvm的内存命令进行调试，但是在真机上就没办法了。</li>
</ul>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>如果app能用代码监测到约束冲突，就可以在非调试模式下捕获到有用的信息，帮助快速定位问题。<br>当发生约束冲突时，控制台会输出这样的提示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">**Unable to simultaneously satisfy constraints.**</div><div class="line">    Probably at least one of the constraints in the following list is one you don&apos;t want. Try this: (1) look at each constraint and try to figure out which you don&apos;t expect; (2) find the code that added the unwanted constraint or constraints and fix it. (Note: If you&apos;re seeing NSAutoresizingMaskLayoutConstraints that you don&apos;t understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints)</div><div class="line">(</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x7fc82d3e18a0 H:[UIView:0x7fc82aba1210(768)]&gt;&quot;,</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x7fc82d6369e0 H:[UIView:0x7fc82aba1210]-(0)-|   (Names: &apos;|&apos;:UIView:0x7fc82d6b9f80 )&gt;&quot;,</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x7fc82d636a30 H:|-(0)-[UIView:0x7fc82aba1210]   (Names: &apos;|&apos;:UIView:0x7fc82d6b9f80 )&gt;&quot;,</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x7fc82d3e7fd0 &apos;UIView-Encapsulated-Layout-Width&apos; H:[UIView:0x7fc82d6b9f80(50)]&gt;&quot;</div><div class="line">)</div><div class="line"></div><div class="line">Will attempt to recover by breaking constraint</div><div class="line">&lt;NSLayoutConstraint:0x7fc82d3e18a0 H:[UIView:0x7fc82aba1210(768)]&gt;</div><div class="line"></div><div class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.</div><div class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful.</div></pre></td></tr></table></figure>
<p>提示我们在<code>UIViewAlertForUnsatisfiableConstraints</code>上打断点调试。<br>这是一个检测到出错约束时，进行处理的C函数。上面那串控制台的log就是在这个函数里输出的。</p>
<p>于是可以尝试用method swizzling替换系统库的方法，记录出现冲突时的信息。<br>监测iOS7的crash问题也是同理。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="获取UIView"><a href="#获取UIView" class="headerlink" title="获取UIView"></a>获取UIView</h3><p>runtime无法替换私有C函数，而调用栈里<code>NSISEngine</code>的那几个方法都没附带什么有用的信息，于是用hopper反编译<code>UIKit.framework</code>，找到使用<code>UIViewAlertForUnsatisfiableConstraints</code>的地方，是<code>-[UIView engine:willBreakConstraint:dueToMutuallyExclusiveConstraints:]</code>。</p>
<p>这个方法附带了出错约束的信息，也可以获取到冲突所在的UIView，于是也能通过UIView获取对应的viewController。接下来只要hook这个方法就可以了。</p>
<h3 id="获取view-controller"><a href="#获取view-controller" class="headerlink" title="获取view controller"></a>获取view controller</h3><p>获取view对应的view controller的方法有两种。</p>
<ul>
<li>使用<code>UIView</code>的私有API:<code>_viewDelegate</code>。</li>
<li>使用<code>UIResponder</code>的<code>nextResponder</code>：</li>
</ul>
<p>&gt;<br>The UIResponder class does not store or set the next responder automatically, instead returning nil by default. Subclasses must override this method to set the next responder. <strong>UIView implements this method by returning the UIViewController object that manages it (if it has one) or its superview (if it doesn’t)</strong>; UIViewController implements the method by returning its view’s superview; UIWindow returns the application object, and UIApplication returns nil.<br>&gt;</p>
<p>参考:<a href="http://stackoverflow.com/questions/1372977/given-a-view-how-do-i-get-its-viewcontroller" target="_blank" rel="external">Given a view, how do I get its viewController?</a></p>
<p>我选择了第二种方式。</p>
<h3 id="监测iOS7约束导致的crash"><a href="#监测iOS7约束导致的crash" class="headerlink" title="监测iOS7约束导致的crash"></a>监测iOS7约束导致的crash</h3><p>当你在实现自定义view的<code>layoutSubviews</code>方法时，记住：</p>
<ul>
<li>调用<code>[super layoutSubviews]</code></li>
<li>不要在<code>layoutSubviews</code>里增加约束</li>
</ul>
<p>如果不遵守这两条，当你向这个view上增加子view时，在iOS6和iOS7上会crash，控制台会输出提示：<code>&#39;Auto Layout still required after executing - layoutSubviews..&#39;</code> 。iOS8开始则不会crash。</p>
<p>某些系统控件，例如<code>UITableView</code>，<code>UITableViewCell</code>没有调用<code>[super layoutSubviews]</code>，所以在iOS6和iOS7上不能在它们上面增加子view，除非你用method swizlling修复它们的<code>layoutSubviews</code>方法。</p>
<p>经过反编译分析，<code>&#39;Auto Layout still required after executing - layoutSubviews..&#39;</code>发生在<code>UIView</code>的<code>layoutSublayersOfLayer:</code>里，发生错误之前会用<code>-[UIView _wantsWarningForMissingSuperLayoutSubviews]</code>来监测是否调用了<code>[super layoutSubviews]</code>，如果没有则抛出异常。<br>因此只需要hook<code>_wantsWarningForMissingSuperLayoutSubviews</code>就可以了。</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>设置监听方式如下，返回约束冲突所在的view，viewController，系统尝试打破的约束，目前所有的约束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[ZIKConstraintsGuard monitorUnsatisfiableConstraintWithHandler:^(UIView *view, UIViewController *viewController, NSLayoutConstraint *constraintToBreak, NSArray&lt;NSLayoutConstraint *&gt; *currentConstraints) &#123;</div><div class="line">    NSLog(@&quot;检测到约束冲突！&quot;);</div><div class="line">    NSString *className = NSStringFromClass([viewController class]);</div><div class="line">    if ([className hasPrefix:@&quot;UI&quot;] &amp;&amp; ![className isEqualToString:@&quot;UIApplication&quot;]) &#123;</div><div class="line">    	  //使用某些系统控件时会出现约束冲突，例如UIAlertController</div><div class="line">        NSLog(@&quot;ignore conflict in UIKit:%@&quot;,viewController);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;冲突所在的viewController:\n%@ \nview:\n%@&quot;,viewController,view);</div><div class="line">    //使用recursiveDescription来打印view的层级，注意这是private API</div><div class="line">    NSLog(@&quot;view hierarchy:\n%@&quot;,[view valueForKeyPath:@&quot;recursiveDescription&quot;]);</div><div class="line">    NSLog(@&quot;目前所有的约束:\n%@&quot;,currentConstraints);</div><div class="line">    NSLog(@&quot;系统尝试打破的约束:\n%@&quot;,constraintToBreak);</div><div class="line">    </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>打印结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">检测到约束冲突！</div><div class="line"></div><div class="line">冲突所在的viewController:</div><div class="line">&lt;MyViewController: 0x100201ba0&gt; </div><div class="line">view:</div><div class="line">&lt;UIView: 0x10020cbb0; frame = (0 0; 375 667); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x170242b50&gt;; layer = &lt;UIWindowLayer: 0x17002b240&gt;&gt;</div><div class="line"></div><div class="line">view hierarchy:</div><div class="line"></div><div class="line">&lt;UIView: 0x10020cbb0; frame = (0 0; 375 667); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x170242b50&gt;; layer = &lt;UIWindowLayer: 0x17002b240&gt;&gt;</div><div class="line">   | &lt;UIView: 0x10020fd00; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x17002b780&gt;&gt;</div><div class="line">   |    | &lt;_UILayoutGuide: 0x1002100a0; frame = (0 0; 0 0); hidden = YES; layer = &lt;CALayer: 0x17002b820&gt;&gt;</div><div class="line">   |    | &lt;_UILayoutGuide: 0x100210650; frame = (0 0; 0 0); hidden = YES; layer = &lt;CALayer: 0x17002b8e0&gt;&gt;</div><div class="line">   |    | &lt;UITableView: 0x10081cc00; frame = (100 100; 100 100); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x170243e70&gt;; layer = &lt;CALayer: 0x17002bf20&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt;</div><div class="line">   |    |    | &lt;UITableViewWrapperView: 0x10080fe00; frame = (0 0; 100 100); gestureRecognizers = &lt;NSArray: 0x1702441a0&gt;; layer = &lt;CALayer: 0x17002bf80&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;100, 100&#125;&gt;</div><div class="line"></div><div class="line">目前所有的约束:</div><div class="line">(</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x17008a500 UITableView:0x10081cc00.top == UITableView:0x10081cc00.top + 10   (active)&gt;&quot;</div><div class="line">)</div><div class="line"></div><div class="line">系统尝试打破的约束:</div><div class="line">&lt;NSLayoutConstraint:0x17008a500 UITableView:0x10081cc00.top == UITableView:0x10081cc00.top + 10   (active)&gt;</div></pre></td></tr></table></figure>
<p>这样就能根据记录到的内存地址，准确地找到是哪个界面的哪个控件的约束出错了，即便在iOS7上crash，也能在crash之前记录到错误信息。</p>
<h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><ul>
<li>某些系统控件本身存在约束冲突的问题，例如在使用<code>UIAlertController</code>的时候。目前是在检测到冲突时，再检测viewController的类型前缀，如果是<code>UI</code>前缀则忽略。</li>
<li>同一个约束冲突有时候会有多次回调。这些回调来自处理auto layout的不同阶段，例如添加重复约束时、<code>addSubview</code>时，<code>layoutSubLayer</code>时等。</li>
</ul>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>工具地址在此：<a href="https://github.com/Zuikyo/ZIKConstraintsGuard" target="_blank" rel="external">ZIKConstraintsGuard</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;功能&lt;/em&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在非调试模式下，获取出错的具体约束。&lt;/li&gt;
&lt;li&gt;监测约束冲突，并获取出错的view和viewController。&lt;/li&gt;
&lt;li&gt;监测iOS7上layoutSubViews导致的crash问题&lt;/li&gt;
&lt;/u
    
    </summary>
    
      <category term="调试技巧" scheme="http://zuikyo.github.io/categories/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>@inerface的11条规范写法</title>
    <link href="http://zuikyo.github.io/2016/12/07/interface%E7%9A%84%E8%A7%84%E8%8C%83%E5%86%99%E6%B3%95/"/>
    <id>http://zuikyo.github.io/2016/12/07/interface的规范写法/</id>
    <published>2016-12-07T00:55:29.000Z</published>
    <updated>2018-03-27T03:07:40.020Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些interface声明时的规范，相关宏的介绍，定义方法时有用的修饰符，编写注释的规范，最终写出一个合格的头文件。</p>
<ul>
<li><a href="#readwrite">1.读写权限</a><ul>
<li><a href="#readwrite-1">1.1实例变量的@public,@protected,@private关键字</a></li>
<li><a href="#readwrite-2">1.2属性的readonly,readwrite关键字</a></li>
</ul>
</li>
<li><a href="#forward-declaration">2.前向声明</a></li>
<li><a href="#private">3.只暴露必要的接口和实现</a><ul>
<li><a href="#private-1">3.1不要暴露任何只在类内部使用的私有方法</a></li>
<li><a href="#private-2">3.2不要在头文件里声明类内部遵循的protocol</a></li>
</ul>
</li>
<li><a href="#nullability">4.nullability说明</a></li>
<li><a href="#enum">5.定义枚举</a><ul>
<li><a href="#enum-1">5.1 NS_ENUM</a></li>
<li><a href="#enum-2">5.2 NS_OPTIONS</a></li>
<li><a href="#enum-3">5.3 字符串枚举</a></li>
</ul>
</li>
<li><a href="#extern">6.使用extern向外部提供只读常量</a></li>
<li><a href="#protected">7.向子类和category提供父类的私有属性</a></li>
<li><a href="#designated-initializer">8.标明designated initializer</a></li>
<li><a href="#version-control">9.API版本控制</a><ul>
<li><a href="#version-control-1">9.1 available</a></li>
<li><a href="#version-control-2">9.2 unavailable</a></li>
<li><a href="#version-control-3">9.3 deprecated</a></li>
</ul>
</li>
<li><a href="#keywords">10.额外的修饰符</a><ul>
<li><a href="#keywords-1">10.1泛型</a></li>
<li><a href="#keywords-2">10.2 NS_REQUIRES_SUPER</a></li>
<li><a href="#keywords-3">10.3 NS_NOESCAPE</a></li>
</ul>
</li>
<li><a href="#comment">11.写注释</a><ul>
<li><a href="#comment-1">11.1单行注释</a></li>
<li><a href="#comment-2">11.2多行注释</a></li>
<li><a href="#comment-3">11.3枚举注释</a></li>
<li><a href="#comment-4">11.4几个注释约定</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-读写权限"><a href="#1-读写权限" class="headerlink" title="1.读写权限"></a><a name="readwrite"></a>1.读写权限</h2><p>.h文件里的声明是用于暴露给外部的接口，而类内部的私有方法、私有属性和实例变量，应该放到.m文件的interface extension里。</p>
<h3 id="1-1-实例变量的-public-protected-private关键字"><a href="#1-1-实例变量的-public-protected-private关键字" class="headerlink" title="1.1 实例变量的@public,@protected,@private关键字"></a><a name="readwrite-1"></a>1.1 实例变量的@public,@protected,@private关键字</h3><p>这3个关键字用于修饰实例变量，不能用于修饰属性。当错误地使用了实例变量时，Xcode会报错提示。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@private</td>
<td>作用范围只能在自身类</td>
</tr>
<tr>
<td>@protected</td>
<td>作用范围在自身类和继承自己的子类，什么都不写，默认是此属性。</td>
</tr>
<tr>
<td>@public</td>
<td>作用范围最大，在任何地方。</td>
</tr>
</tbody>
</table>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">@interface SearchManager : NSObject &#123;</div><div class="line">    @public    NSInteger *state;</div><div class="line">    @public    NSInteger *timeout;</div><div class="line">    @protected id *searchAPI;</div><div class="line">    @private   id _privateIvar;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>由于会暴露私有变量，并且没有@property的一些高级关键字，很少在头文件里声明实例变量。优先使用@property。</p>
<h3 id="1-2-属性的readonly-readwrite关键字"><a href="#1-2-属性的readonly-readwrite关键字" class="headerlink" title="1.2 属性的readonly,readwrite关键字"></a><a name="readwrite-2"></a>1.2 属性的readonly,readwrite关键字</h3><p>头文件中的属性是用于描述这个对象的一系列特性集合。<br>声明@property时，在.h里使用readonly，让外部只有读的权限，在.m里使用readwrite，使内部拥有读写权限。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">@interface SearchManager : NSObject</div><div class="line">@property (nonatomic, readonly) NSInteger * state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//SearchManager.m</div><div class="line">@interface SearchManager : NSObject</div><div class="line">@property (nonatomic, readwrite) NSInteger * state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h2 id="2-前向声明"><a href="#2-前向声明" class="headerlink" title="2.前向声明"></a><a name="forward-declaration"></a>2.前向声明</h2><p>当在@interface的接口里用到了其他类，不要在.h里直接导入类的头文件，这样会让使用此头文件的地方也导入这些不必要的其他头文件。正确的做法是使用关键字<code>@class</code>进行前向声明。当然，如果是继承了父类，还是需要import父类的头文件。<br>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">#import &quot;SearchManagerBase.h&quot;//导入父类的头文件</div><div class="line"></div><div class="line">@class LocationModel;//前向声明LocationModel类</div><div class="line"></div><div class="line">typedef void(^LocationSearchCompletionHandler)(LocationModel *location, NSError *error);</div><div class="line">@interface LocationSearchManager : SearchManagerBase</div><div class="line">- (void)searchLocationWithKeyword:(NSString *)keyword completionHandler:(LocationSearchCompletionHandler)completionHandler;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用@class会告诉编译器有这么一个类存在，但是现在并不关心这个类的具体实现，等到调用者在.m里使用的时候再import这个类即可。使用@class和@protocol分别声明一个类和一个protocol。<br>使用前向引用的原因有两个：</p>
<ul>
<li>提升编译效率。<br>如果import了<code>LocationModel.h</code>，那么当<code>LocationModel.h</code>的内容发生变化时，所有import了<code>LocationModel.h</code>的地方都需要重新编译。如果.m引用了<code>SearchManager.h</code>，但是并没有使用<code>LocationModel</code>，就会增加不必要的编译，降低开发效率。</li>
<li>解决交叉引用的问题。<br>如果类A的头文件import了B，类B的头文件import了A，这样在编译时会报错：“can not find interface declaration”，这是因为Objective-C不允许交叉引用。</li>
</ul>
<h2 id="3-只暴露必要的接口和实现"><a href="#3-只暴露必要的接口和实现" class="headerlink" title="3.只暴露必要的接口和实现"></a><a name="private"></a>3.只暴露必要的接口和实现</h2><h3 id="3-1不要暴露任何只在类内部使用的私有方法"><a href="#3-1不要暴露任何只在类内部使用的私有方法" class="headerlink" title="3.1不要暴露任何只在类内部使用的私有方法"></a><a name="private-1"></a>3.1不要暴露任何只在类内部使用的私有方法</h3><p>头文件里只声明那些给外部使用的公开方法，并且在设计时需要考虑到可测试性，遵循单一职责。<br>私有方法只定义在类内部，并且为了进行区别，建议在私有方法前加上前缀，例如<code>- (void)p_myPrivateMethod</code>。<br>由于Apple在它的编码规范里声明了，Apple公司拥有下划线的方法前缀，就像它拥有<code>NS</code>,<code>UI</code>这些类名前缀一样，因此不建议我们的私有方法直接使用下划线作为前缀。否则，当你在继承Cocoa Touch的类时，有可能会覆盖父类的私有方法，造成难以调试的错误。</p>
<h3 id="3-2不要在头文件里声明类内部遵循的protocol"><a href="#3-2不要在头文件里声明类内部遵循的protocol" class="headerlink" title="3.2不要在头文件里声明类内部遵循的protocol"></a><a name="private-2"></a>3.2不要在头文件里声明类内部遵循的protocol</h3><p><strong>错误</strong>的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">@interface SearchManager : NSObject&lt;NSCoding, UITableViewDelegate&gt;</div><div class="line">@property (nonatomic, readonly) NSInteger * state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>UITableViewDelegate</code>是类内部使用时遵循的protocol，没有必要暴露给外部，因此应该放到.m文件里。<br>而<code>NSCoding</code>则描述了类的特性，用于告诉外部本类可以使用归档，因此应该放在头文件里。</p>
<h2 id="4-nullability说明"><a href="#4-nullability说明" class="headerlink" title="4.nullability说明"></a><a name="nullability"></a>4.nullability说明</h2><p>在声明时，可以使用下列关键字描述对象是否可以为nil。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>nullable</td>
<td>可空，用于描述objc对象</td>
</tr>
<tr>
<td>nonnull</td>
<td>不可空，用于描述objc对象</td>
</tr>
<tr>
<td>null_unspecified</td>
<td>不确定，用于描述objc对象</td>
</tr>
<tr>
<td>null_resettable</td>
<td>set可空，get不为空。仅用于property</td>
</tr>
<tr>
<td>_Nullable</td>
<td>可空，用于描述C指针和block</td>
</tr>
<tr>
<td>_Nonnull</td>
<td>不可空，用于描述C指针和block</td>
</tr>
<tr>
<td>_Null_unspecified</td>
<td>不确定，用于描述C指针和block</td>
</tr>
</tbody>
</table>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">#import &quot;SearchManagerBase.h&quot;</div><div class="line">@class LocationModel;</div><div class="line"></div><div class="line">typedef void(^LocationSearchCompletionHandler)(LocationModel *_Nullable location, NSError *_Nullable error);</div><div class="line">@interface LocationSearchManager : SearchManagerBase</div><div class="line">- (void)searchLocationWithKeyword:(nonnull NSString *)keyword completionHandler:(LocationSearchCompletionHandler _Nonnull)completionHandler;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果向一个使用nonnull修饰的值赋空，编译器会给出警告。<br>在开发时，大部分时候使用的都是nonnull，因此Apple提供了一对宏<code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>来进行快速修饰，写在两个宏之间的属性、方法，均会使用<code>nonnull</code>修饰。<br>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//LocationSearchManager.h</div><div class="line"></div><div class="line">#import &quot;SearchManagerBase.h&quot;</div><div class="line">@class LocationModel;</div><div class="line"></div><div class="line">NS_ASSUME_NONNULL_BEGIN</div><div class="line">typedef void(^LocationSearchCompletionHandler)(LocationModel *_Nullable location, NSError *_Nullable error);</div><div class="line">@interface LocationSearchManager : SearchManagerBase</div><div class="line">- (void)searchLocationWithKeyword:(NSString *)keyword completionHandler:(LocationSearchCompletionHandler)completionHandler;</div><div class="line">@end</div><div class="line">NS_ASSUME_NONNULL_END</div></pre></td></tr></table></figure>
<h2 id="5-定义枚举"><a href="#5-定义枚举" class="headerlink" title="5.定义枚举"></a><a name="enum"></a>5.定义枚举</h2><p>关于NS_ENUM和NS_OPTIONS的区别，参考<a href="http://nshipster.cn/ns_enum-ns_options/" target="_blank" rel="external">这里</a>。<br>简单来说，NS_OPTIONS提供了按位掩码的功能。</p>
<h3 id="5-1-NS-ENUM"><a href="#5-1-NS-ENUM" class="headerlink" title="5.1 NS_ENUM"></a><a name="enum-1"></a>5.1 NS_ENUM</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger,SearchState) &#123;</div><div class="line">    SearchStateNotSearch,</div><div class="line">    SearchStateSearching,</div><div class="line">    SearchStateSearchFinished,</div><div class="line">    SearchStateSearchFailed</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="5-2-NS-OPTIONS"><a href="#5-2-NS-OPTIONS" class="headerlink" title="5.2 NS_OPTIONS"></a><a name="enum-2"></a>5.2 NS_OPTIONS</h3><p>示例代码，参考<code>NSKeyValueObserving.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123;</div><div class="line">    NSKeyValueObservingOptionNew,</div><div class="line">    NSKeyValueObservingOptionOld,</div><div class="line">    NSKeyValueObservingOptionInitial,</div><div class="line">    NSKeyValueObservingOptionPrior</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在使用时就可以用<code>|</code>组合多个option：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[_webView addObserver:self forKeyPath:@&quot;title&quot; options:NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionNew context:NULL];</div></pre></td></tr></table></figure></p>
<h3 id="5-3-字符串枚举"><a href="#5-3-字符串枚举" class="headerlink" title="5.3 字符串枚举"></a><a name="enum-3"></a>5.3 字符串枚举</h3><p>当使用字典作为参数传递，或者作为返回值时，往往难以直接提供字典的key，现在使用字符串枚举即可解决这个问题。<br>示例代码，参考<code>NSKeyValueObserving.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//使用NS_STRING_ENUM宏，定义了一个枚举类型</div><div class="line">typedef NSString * NSKeyValueChangeKey NS_STRING_ENUM;</div><div class="line"></div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeKindKey;</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNewKey;</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeOldKey;</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeIndexesKey;</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNotificationIsPriorKey;</div><div class="line"></div><div class="line">//使用泛型，声明了change参数用到的key，是在NSKeyValueChangeKey的枚举范围中</div><div class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;</div></pre></td></tr></table></figure>
<h2 id="6-使用extern向外部提供只读常量"><a href="#6-使用extern向外部提供只读常量" class="headerlink" title="6.使用extern向外部提供只读常量"></a><a name="extern"></a>6.使用extern向外部提供只读常量</h2><p>这不关@interface的事，但是和头文件有关，就放在一起说明了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">extern NSString *const SearchErrorDomain;</div><div class="line">extern NSInteger SearchDefaultTimeout;</div><div class="line"></div><div class="line">@interface SearchManager : NSObject</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//SearchManager.m</div><div class="line">NSString *const SearchErrorDomain = @&quot;SearchErrorDomain&quot;;</div><div class="line">const NSInteger SearchDefaultTimeout = 20;</div><div class="line"></div><div class="line">@interface SearchManager()</div><div class="line">@end</div></pre></td></tr></table></figure>
<h2 id="7-向子类和category提供父类的私有属性"><a href="#7-向子类和category提供父类的私有属性" class="headerlink" title="7.向子类和category提供父类的私有属性"></a><a name="protected"></a>7.向子类和category提供父类的私有属性</h2><p>由于类的头文件只存放那些暴露给外部的属性和方法，在遇到这些情况时，会遇到障碍：</p>
<ul>
<li>在子类里或者category里，想要使用父类定义在.m里的私有属性。</li>
<li>在类的头文件里属性是readonly，但是在子类或者category里，需要readwrite权限。<br>由于这些属性并没有暴露在头文件里，因此需要另外建立一个私有头文件，用来存放这些需要暴露给子类和category的属性。<br>可以参考Apple官方的<code>UIGestureRecognizerSubclass.h</code>。<br>示例代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">@interface SearchManager : NSObject</div><div class="line">///外部访问，只有读权限</div><div class="line">@property (nonatomic, readonly) SearchState state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//SearchManager.m</div><div class="line">@interface SearchManager()</div><div class="line">///内部使用，有读写权限</div><div class="line">@property (nonatomic, assign) SearchState state;</div><div class="line">///只在内部使用的私有属性</div><div class="line">@property (nonatomic, strong) id searchAPI;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">///暴露给子类和category的私有属性和私有方法</div><div class="line">//SearchManagerInternal.h</div><div class="line">///限制使用此头文件，防止被别的类误用</div><div class="line">#ifdef SEARCHMANAGER_PROTECTED_ACCESS</div><div class="line"></div><div class="line">#import &quot;SearchManager.h&quot;</div><div class="line">@interface SearchManager()</div><div class="line">///在internal.h里，重新声明为readwrite权限</div><div class="line">@property (nonatomic, readwrite, assign) SearchState state;</div><div class="line">///暴露私有属性</div><div class="line">@property (nonatomic, strong) id searchAPI;</div><div class="line">///暴露私有方法</div><div class="line">- (void)p_privateMethod;</div><div class="line">@end</div><div class="line"></div><div class="line">#else</div><div class="line">#error Only be included by SearchManager&apos;s subclass or category!</div><div class="line">#endif</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">///category的实现文件</div><div class="line">//SearchManager+Category.m</div><div class="line">///声明私有头文件的使用权限</div><div class="line">#define SEARCHMANAGER_PROTECTED_ACCESS</div><div class="line">///导入私有头文件</div><div class="line">#import &quot;SearchManagerInternal.h&quot;</div><div class="line"></div><div class="line">@implementation SearchManager(Category)</div><div class="line">- (void)categoryMethod &#123;</div><div class="line">    //拥有了读写权限</div><div class="line">    self.state = SearchStateSearching;</div><div class="line">    //可以访问私有属性</div><div class="line">    [self.searchAPI startSearch];</div><div class="line">    //可以使用私有方法</div><div class="line">    [self p_privateMethod];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>SearchManagerInternal.h</code>其实也是公开的，其他类也能够导入并使用，只能在开发时进行约定。如果想要限制其他类导入，并且提示错误，<code>Internal.h</code>可以使用如下方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#ifdef MYCLASS_PROTECTED_ACCESS</div><div class="line">//声明部分</div><div class="line">#else</div><div class="line">#error Only be included by MYCLASS&apos;s subclass or category!</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>这样在别的类内意外地导入了<code>Internal.h</code>时就会产生编译警告，并且无法直接使用。缺点是需要在所有使用到<code>Internal.h</code>的地方都<code>#define MYCLASS_PROTECTED_ACCESS</code>。</p>
<h2 id="8-标明designated-initializer"><a href="#8-标明designated-initializer" class="headerlink" title="8.标明designated initializer"></a><a name="designated-initializer"></a>8.标明designated initializer</h2><p>指定初始化方法，即接收参数最多的那个初始化方法，其他初始化方法调用它即可，这样设计的目的是为了保证所有初始化方法都正确地初始化实例变量。<br>在方法后面加上<code>NS_DESIGNATED_INITIALIZER</code>宏即可。这样，当你子类化这个类时，在子类的初始化方法里如果没有正确地调用父类的designated initializer，编译器就会给出警告。<br>实例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface WKWebView : UIView</div><div class="line">- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</div><div class="line">- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>关于designated initializer更详细的说明，参考:</p>
<ul>
<li><a href="https://github.com/100mango/zen/blob/master/Objective-C%20拾遗：designated%20initializer/Objective-C%20拾遗：designated%20initializer.md" target="_blank" rel="external">Objective-C 拾遗：designated initializer</a></li>
<li><a href="http://www.starfelix.com/blog/2014/04/13/zheng-que-bian-xie-designated-initializerde-ji-ge-yuan-ze/" target="_blank" rel="external">正确编写Designated Initializer的几个原则</a></li>
</ul>
<h2 id="9-API版本控制"><a href="#9-API版本控制" class="headerlink" title="9.API版本控制"></a><a name="version-control"></a>9.API版本控制</h2><p>在更新接口，或者开发framework时，需要标明版本信息，告诉使用者此接口的平台限制、操作系统版本、是否可用、是否已弃用等。<br>苹果给出了几个自带的宏用于标明版本，Xcode在检测到错误使用时会给出警告。只需要在方法名后面加上对应的宏即可。</p>
<h3 id="9-1-available"><a href="#9-1-available" class="headerlink" title="9.1 available"></a><a name="version-control-1"></a>9.1 available</h3><p>声明本接口最低支持的操作系统版本。<br>当你的接口使用了新系统的API，例如iOS8以上才有的UIAlertController，但是项目的deployment target却是iOS7时，需要标明此接口的版本信息，让使用者进行兼容。<br>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line"></div><div class="line">typedef NS_ENUM(NSInteger,SearchState) &#123;</div><div class="line">    SearchStateNotSearch,</div><div class="line">    SearchStateSearching,</div><div class="line">    SearchStateSearchFinished,</div><div class="line">    SearchStateSearchFailed</div><div class="line">&#125; NS_ENUM_AVAILABLE_IOS(2_0);//此枚举在iOS2.0以上才能使用</div><div class="line"></div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) //此类在iOS2.0以上才能使用</div><div class="line">@interface SearchManager : NSObject</div><div class="line">- (void)reSearch NS_AVAILABLE_IOS(5_0);//此方法在iOS5.0以上才能使用</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这几个宏有对应平台的版本，例如NS_AVAILABLE_MAC, NS_AVAILABLE_IOS, NS_AVAILABLE_IPHONE。<br>iOS10开始提供了新的available宏<code>API_AVAILABLE</code>，用来统一macOS、iOS、watchOS、tvOS几个平台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">API_AVAILABLE(macos(10.10))</div><div class="line">API_AVAILABLE(macos(10.9), ios(10.0))</div><div class="line">API_AVAILABLE(macos(10.4), ios(8.0), watchos(2.0), tvos(10.0))</div></pre></td></tr></table></figure>
<h3 id="9-2-unavailable"><a href="#9-2-unavailable" class="headerlink" title="9.2 unavailable"></a><a name="version-control-2"></a>9.2 unavailable</h3><p>声明此接口不可用，大多数时候是用于声明所在平台限制。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface SearchManager : NSObject</div><div class="line">- (void)searchInWatch NS_UNAVAILABLE;//不能用此接口</div><div class="line">- (void)searchInHostApp NS_EXTENSION_UNAVAILABLE_IOS;//extension里不能用此接口</div><div class="line">- (void)search __TVOS_PROHIBITED;//tvOS里不能用此接口，可修饰枚举，类，方法，参数</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>iOS10开始提供了新的unavailable宏<code>API_UNAVAILABLE</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">API_UNAVAILABLE(macos)</div><div class="line">API_UNAVAILABLE(watchos, tvos)</div></pre></td></tr></table></figure>
<h3 id="9-3-deprecated"><a href="#9-3-deprecated" class="headerlink" title="9.3 deprecated"></a><a name="version-control-3"></a>9.3 deprecated</h3><p>声明此接口已经被弃用，可以同时加注释注明替代接口。<br>当deployment target版本号设置成大于或等于方法被弃用的版本号时，Xcode会给出警告。<br>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注明废弃类</div><div class="line">NS_CLASS_DEPRECATED_IOS(2_0, 9_0, &quot;UIAlertView is deprecated. Use UIAlertController with a preferredStyle of UIAlertControllerStyleAlert instead&quot;)</div><div class="line">@interface UIAlertView : UIView</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注明废弃API</div><div class="line">@interface UIViewController : UIResponder</div><div class="line">- (void)viewDidUnload NS_DEPRECATED_IOS(3_0,6_0);</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//注明废弃枚举</div><div class="line">typedef NS_ENUM(NSInteger, UIStatusBarStyle) &#123;</div><div class="line">    UIStatusBarStyleDefault                                     = 0, // Dark content, for use on light backgrounds</div><div class="line">    UIStatusBarStyleLightContent     NS_ENUM_AVAILABLE_IOS(7_0) = 1, // Light content, for use on dark backgrounds</div><div class="line">    </div><div class="line">    UIStatusBarStyleBlackTranslucent NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 1,</div><div class="line">    UIStatusBarStyleBlackOpaque      NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 2,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>iOS10开始提供了新的deprecated宏<code>API_DEPRECATED</code>和<code>API_DEPRECATED_WITH_REPLACEMENT</code>。前者可以注明弃用原因，后者可以注明替代接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">API_DEPRECATED(&quot;No longer supported&quot;, macos(10.4, 10.8))</div><div class="line">API_DEPRECATED(&quot;No longer supported&quot;, macos(10.4, 10.8), ios(2.0, 3.0), watchos(2.0, 3.0), tvos(9.0, 10.0))</div><div class="line"></div><div class="line">API_DEPRECATED_WITH_REPLACEMENT(&quot;-setName:&quot;, tvos(10.0, 10.4), ios(9.0, 10.0))</div><div class="line">API_DEPRECATED_WITH_REPLACEMENT(&quot;SomeClassName&quot;, macos(10.4, 10.6), watchos(2.0, 3.0))</div></pre></td></tr></table></figure>
<h2 id="10-额外的修饰符"><a href="#10-额外的修饰符" class="headerlink" title="10.额外的修饰符"></a><a name="keywords"></a>10.额外的修饰符</h2><h3 id="10-1-泛型"><a href="#10-1-泛型" class="headerlink" title="10.1 泛型"></a><a name="keywords-1"></a>10.1 泛型</h3><p>在声明时，对集合类型的对象增加泛型的修饰，就可以声明集合内存储的数据类型。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) NSMutableArray&lt;NSString *&gt; *myArray;</div></pre></td></tr></table></figure>
<p>当你向<code>myArray</code>里放入一个非<code>NSString *</code>类型的对象时，编译器会给出警告。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic, strong) NSMutableArray&lt;__kindof UIView *&gt; * viewArray;</div></pre></td></tr></table></figure>
<p><code>_kindof</code>只限定了存储类型为<code>UIView</code>，因此也可以存储<code>UIView</code>的子类，例如<code>UIButton</code>。<br>更详细的介绍，参考:<a href="https://my.oschina.net/u/2340880/blog/514804" target="_blank" rel="external">Objective—C语言的新魅力——Nullability、泛型集合与类型延拓</a></p>
<h3 id="10-2-NS-REQUIRES-SUPER"><a href="#10-2-NS-REQUIRES-SUPER" class="headerlink" title="10.2 NS_REQUIRES_SUPER"></a><a name="keywords-2"></a>10.2 NS_REQUIRES_SUPER</h3><p><code>NS_REQUIRES_SUPER</code>宏用于声明子类在重载父类的这个方法时，需要调用父类的方法。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)viewWillAppear:(BOOL)animated NS_REQUIRES_SUPER;</div></pre></td></tr></table></figure>
<h3 id="10-3-NS-NOESCAPE"><a href="#10-3-NS-NOESCAPE" class="headerlink" title="10.3 NS_NOESCAPE"></a><a name="keywords-3"></a>10.3 NS_NOESCAPE</h3><p><code>NS_NOESCAPE</code>用于修饰方法中的block类型参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSArray: NSObject</div><div class="line">- (NSArray *)sortedArrayUsingComparator:(NSComparator NS_NOESCAPE)cmptr</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>作用是告诉编译器，<code>cmptr</code>这个block在<code>sortedArrayUsingComparator:</code>方法返回之前就会执行完毕，而不是被保存起来在之后的某个时候再执行。<br>类似于这样的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)performWithLock:(NS_NOESCAPE void (^)())block &#123;  // exposed as @noescape to Swift</div><div class="line">    [myLock lock];</div><div class="line">    block();</div><div class="line">    [myLock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器知道之后，就会相应地做一些优化，例如去掉一些多余的对<code>self</code>的捕获、retain、release操作。因为block的存活范围仅限于本方法内，没有必要再在block内保留<code>self</code>了。<br>更详细的介绍，参考<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0012-add-noescape-to-public-library-api.md" target="_blank" rel="external">这里</a>。</p>
<h2 id="11-写注释"><a href="#11-写注释" class="headerlink" title="11.写注释"></a><a name="comment"></a>11.写注释</h2><p>头文件就是文档，需要让使用者快速知道这个类的作用。一个好的方法名可以让使用者快速理解，但大部分时候还是需要相应的注释。<br>写好格式化注释后，当光标停留在方法名和属性上时，在Xcode右侧的Quick Help栏里会出现注释内容，按住<code>option</code>并单击，也会弹出注释框。</p>
<h3 id="11-1单行注释"><a href="#11-1单行注释" class="headerlink" title="11.1单行注释"></a><a name="comment-1"></a>11.1单行注释</h3><p>直接在方法或者属性声明的上一行使用<code>///</code>，后面加注释，同时兼容Xcode和appleDoc。Xcode也支持<code>//!</code>，但是appleDoc不支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//SearchManagerBase.h</div><div class="line"></div><div class="line">///搜索manager的基类</div><div class="line">@interface SearchManagerBase : NSObject</div><div class="line">///搜索状态</div><div class="line">@property (nonatomic, readonly) NSInteger * state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="11-2多行注释"><a href="#11-2多行注释" class="headerlink" title="11.2多行注释"></a><a name="comment-2"></a>11.2多行注释</h3><p>多行注释使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 注释内容</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>Xcode8提供了快速生成格式化注释的快捷键：<code>option</code>+<code>command</code>+<code>/</code>。如果方法有参数，会自动添加@param关键字，用于描述对应的参数。<br>Apple提供了官方的headDoc语法，但是很多都已经在Xcode中失效了，而且有些关键字也和appleDoc不兼容。下面几种列举出了在Xcode中仍然有效的一些关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 演示苹果headDoc的语法。这里可以写方法简介</div><div class="line"> </div><div class="line"> @brief 方法的简介(appleDoc不支持此关键字)</div><div class="line"> @discussion 方法的详细说明</div><div class="line"> </div><div class="line"> @code //示例代码(这个在Xcode里常用，但是appleDoc不支持此关键字)</div><div class="line"> UIView *view;</div><div class="line"> @endcode</div><div class="line"> </div><div class="line"> @bug       存在的bug的说明</div><div class="line"> @note      需要注意的提示</div><div class="line"> @warning   警告</div><div class="line"> @since     iOS7.0</div><div class="line"> @exception 方法会抛出的异常的说明</div><div class="line"> </div><div class="line"> @attention 注意，从这里开始往下的关键字，appleDoc都不支持</div><div class="line"> @author    编写者</div><div class="line"> @copyright 版权</div><div class="line"> @date      日期</div><div class="line"> @invariant 不变量</div><div class="line"> @post      后置条件</div><div class="line"> @pre       前置条件</div><div class="line"> @remarks   备注</div><div class="line"> @todo      todo text</div><div class="line"> @version   版本</div><div class="line"> */</div><div class="line">- (void)sampleMethod;</div></pre></td></tr></table></figure>
<p>在Xcode中，就会显示为这样：<br><img src="http://upload-images.jianshu.io/upload_images/1865432-dfc9a9b1de31ec47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="comment.png"></p>
<h3 id="11-3-枚举注释"><a href="#11-3-枚举注释" class="headerlink" title="11.3 枚举注释"></a><a name="comment-3"></a>11.3 枚举注释</h3><p>如果要给枚举注释，需要在每个枚举值前注释，按照如下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">///搜索状态</div><div class="line">typedef NS_ENUM(NSInteger,SearchState) &#123;</div><div class="line">    ///没有开始搜索</div><div class="line">    SearchStateNotSearch,</div><div class="line">    ///搜索中</div><div class="line">    SearchStateSearching,</div><div class="line">    ///搜索结束</div><div class="line">    SearchStateSearchFinished,</div><div class="line">    ///搜索失败</div><div class="line">    SearchStateSearchFailed</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="11-4-几个注释约定"><a href="#11-4-几个注释约定" class="headerlink" title="11.4 几个注释约定"></a><a name="comment-4"></a>11.4 几个注释约定</h3><p>需要注释的内容：</p>
<ul>
<li>尽量为类添加描述，即便只有一句话。</li>
<li>标明某些参数和属性的默认值，比如超时time。</li>
<li>如果属性是KVO兼容的，即外部可以使用KVO监听此属性，则在属性注释里声明。</li>
<li>回调block参数需要说明回调所在的线程，避免让使用者在block里进行多余的线程判断。</li>
<li>如果需要的话，说明使用此API需要的前置条件，防止被错误地调用。</li>
<li>对使用了method swizzling的API进行统一形式的标注，方便遇到runtime的bug时进行排查。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/</a></li>
<li><a href="http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/" target="_blank" rel="external">http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一些interface声明时的规范，相关宏的介绍，定义方法时有用的修饰符，编写注释的规范，最终写出一个合格的头文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#readwrite&quot;&gt;1.读写权限&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#readwrite-1&quot;&gt;
    
    </summary>
    
      <category term="代码规范" scheme="http://zuikyo.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>私有API-iOS10 openURL方法跳转到设置界面失效的解决方法</title>
    <link href="http://zuikyo.github.io/2016/10/10/%E7%A7%81%E6%9C%89API-iOS10%20openURL%E6%96%B9%E6%B3%95%E8%B7%B3%E8%BD%AC%E5%88%B0%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://zuikyo.github.io/2016/10/10/私有API-iOS10 openURL方法跳转到设置界面失效的解决方法/</id>
    <published>2016-10-10T00:48:29.000Z</published>
    <updated>2017-05-03T08:23:01.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在iOS10之前，跳转到系统设置界面的某个指定界面的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//打开定位服务界面</div><div class="line">NSURL*url=[NSURL URLWithString:@&quot;prefs:root=Privacy&amp;path=LOCATION&quot;];</div><div class="line">if ([[UIApplication sharedApplication] canOpenURL:url]) &#123;</div><div class="line">    [[UIApplication sharedApplication] openURL:url];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>但是在iOS10上，调用canOpenURL:打开系统设置界面时控制台会报如下错误，并且无法跳转：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-canOpenURL: failed for URL: &quot;Prefs:root=Privacy&amp;path=LOCATION&quot; - error: &quot;The operation couldn’t be completed. (OSStatus error -10814.)&quot;</div></pre></td></tr></table></figure></p>
<p>原因是iOS10只允许如下方式跳转到设置里自己app的界面，对跳转到其他界面做了限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];</div></pre></td></tr></table></figure></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以使用<code>MobileCoreServices.framework</code>里的私有API:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)openSensitiveURL:(id)arg1 withOptions:(id)arg2;</div></pre></td></tr></table></figure></p>
<p>头文件参考：<a href="https://github.com/JaviSoto/iOS10-Runtime-Headers/blob/master/Frameworks/MobileCoreServices.framework/LSApplicationWorkspace.h" target="_blank" rel="external">LSApplicationWorkspace.h</a><br>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注意首字母改成了大写，prefs-&gt;Prefs</div><div class="line">NSURL*url=[NSURL URLWithString:@&quot;Prefs:root=Privacy&amp;path=LOCATION&quot;];</div><div class="line">Class LSApplicationWorkspace = NSClassFromString(@&quot;LSApplicationWorkspace&quot;);</div><div class="line">[[LSApplicationWorkspace performSelector:@selector(defaultWorkspace)] performSelector:@selector(openSensitiveURL:withOptions:) withObject:url withObject:nil];</div></pre></td></tr></table></figure></p>
<p><code>MobileCoreServices.framework</code>不是私有库，所以直接使用<code>performSelector:</code>即可调用私有API。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>iOS10的系统URLScheme改成了首字母大写，使用小写的方式会无法打开。</li>
<li>使用私有API的app无法通过App Store审核。你也可以尝试把私有类名和selector字符串混淆一下，绕过审核。例如<a href="http://blog.csdn.net/wenmingzheng/article/details/50475671" target="_blank" rel="external">这位仁兄</a>用ASCII混淆的方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (UIView *)statusBarView &#123; </div><div class="line">    UIView *statusBar = nil; </div><div class="line">    NSData *data = [NSData dataWithBytes:(unsigned char [])&#123;0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x42, 0x61, 0x72&#125; length:9]; </div><div class="line">    NSString *key = [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding]; </div><div class="line">    id object = [UIApplication sharedApplication]; </div><div class="line">    if ([object respondsToSelector:NSSelectorFromString(key)]) &#123;</div><div class="line">        statusBar = [object valueForKey:key]; </div><div class="line">    &#125;</div><div class="line">    return statusBar; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，还是不建议使用私有API，因为它是不可靠的。也许某天苹果就把它移除了。</p>
<h4 id="update"><a href="#update" class="headerlink" title="update:"></a><em>update:</em></h4><ul>
<li>还有一步遗漏了，app需要添加一个<code>Prefs</code>的URL Schemes，即添加到<code>info.plist</code>的<code>LSApplicationQueriesSchemes</code>项中。</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="http://stackoverflow.com/a/39102075/6380485" target="_blank" rel="external">http://stackoverflow.com/a/39102075/6380485</a><br><a href="https://www.zhihu.com/question/50635906/answer/125195317" target="_blank" rel="external">https://www.zhihu.com/question/50635906/answer/125195317</a><br><a href="https://github.com/cyanzhong/app-tutorials/blob/master/schemes.md" target="_blank" rel="external">iOS10系统URLScheme</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在iOS10之前，跳转到系统设置界面的某个指定界面的方式如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
    
    </summary>
    
      <category term="私有API" scheme="http://zuikyo.github.io/categories/%E7%A7%81%E6%9C%89API/"/>
    
    
      <category term="iOS" scheme="http://zuikyo.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
